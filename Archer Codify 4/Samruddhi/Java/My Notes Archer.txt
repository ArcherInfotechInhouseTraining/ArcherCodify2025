
---------------- Java Programming -----------------------

	Computer ---> 
	Language --->
	Programming Languages --> 



		     SIMULA
		     COBOL								   |-- Sun Microsystem --> Java
	Assembly --> Fortran ----> ALGOL60 --> CPL --> BCPL-----> B -----> C ----> C++ ====|-- Microsoft corpo.--> .Net
		     RPG	    (1960)   (1963)    (1967)    (1970)   (1972) (1983-84) |-- CWI -------------> Python
		     BASIC								   |
		     Pascal
		     ....


	// History of Java: 


		- JAMES GOSLING Introduced the Java Programming language.

		- Initially he started with the platform independancy, and developed GreenTalk with ext. (*.gt)

		- After some days he joined the Sun Microsystem, as head of green project team, formed to develop

		- The platform independent language as a internal tools of the company to develop application
		  for different consumer electronic product.

		 - 1990 --> Touch sencetive application

		 - 1991 -> language named Oak is introduced.

		 - 1995 --> OAK renamed as Java

// Different versions of Java: 

		1995 - jdk alpha and beta
		1996 - jdk 1.0
		1997 - jdk 1.1

		1998 - J2SE 1.2
		2000 - J2SE 1.3 
		2002 - J2SE 1.4 
		
		2004 - J2SE 5.0 

		2006 - Java SE 6
		2011 - Java SE 7 
		2014 - Java SE 8 
		
		2017 - Java SE 9                   Onwards ---> JSE 9 ...
		2018 - Java SE 10 (March)
		     - Java SE 11 (September)

		2019 - Java SE 12 (March)
		     - Java SE 13 (September)

		2020 - Java SE 14 (March)
		     - Java SE 15 (September)

		2021 - Java SE 16 (March)
		     - Java SE 17 (September)

		Java SE 18 (to be released by March 2022)



// ---------------------------------------------------------------------------------------------

	Different Java Editions:


			     |-> J2SE(Standard Edition)
			     |
 		Java --------|-> J2EE(Enterprise Edition)
			     |
			     |-> J2ME( Micro Edition)


// ----------------------------------------------------------------------------------------------

	// Java Environment: 

	Platform = OS + Processor Arct.

	It is basically divided into 2 parts

		jre --> java runtime environment: Needed to run the java program
		jdk ---> java developement Needed to develop and run the java program

//----------------------------------------------------------------------------------------------------------


	// Java Buzzwords (Features of Java)	

		-  Simple 
		-  Object Oriented
		-  Portable
		-  Platform Independent
		-  secure
		-  Robust
		-  Architecture neutral
		-  half compiled and half Interpreted
		-  Multithreaded
		-  Distributed
		-  Dynamic
		-  High Performance
//------------------------------------------------------------------------------------------------------------

	// Differences Between C and Java

		https://www.interviewbit.com/blog/difference-between-c-and-java/


	// Differences Between C++ and Java

		https://www.interviewbit.com/blog/difference-between-cpp-and-java/



//----------------------------------------------------------------------------------------------------------

// Execution flow of C/C++ and Java	


		C/C++									Java

	Instructions		Progr_nm					     *.java
		|_________________|							|
			 |								|	
			 |         Debug					     Compile(javac)	
	source code	*.c/*.cpp <---|							|
			 |            |							|
			 |            |						    *.class
		      Compile ------->| Compile-time 				    (byte code)	              		 ^
			 |            | error						|                	 Compile |
			 |            |							|			===================
	backup file    *.bak          |					-------------------------------------   Interpreter |
			 |            |					|		|		| ..                V
			 |            |				       JVM             JVM             JVM --> (Platform dependent JVM)	
	 Linker -------->| ---------> |  Linker error			|		|		|
			 |            |                               Windows         Linux            MAC  
			 |            |                                 | 		|		|                          
	object code    *.obj	      |				     Native code    Native code     Native code	
			 |            |					|		|		|
			 |	      ^				      Run              RUN             Run	
     Executable file   *.exe	      |                                 |               |               |
			 |	      |	                             Output           Output          Output  
		   	Run --------->| Runtime Error
			 |
		       Output							WRITE ONCE RUN EVERYWHERE	



//---------------------------------------------------------------------------------------------------------


	Java Editors and IDE's
	======================

		Editor: Notepad, Editplus, Notepad++ ...
		
		IDE: Best Java IDEs
			Eclipse. Platform – Linux/macOS/Solaris/Windows. ...
			NetBeans. Platform – Linux/macOS/Solaris/Windows. ...
			IntelliJ IDEA. Platform – Linux/macOS/Windows. ...
			BlueJ. Platform – Linux/macOS/Windows. ...
			(Oracle) JDeveloper. Platform – Linux/macOS/Windows. 


	Now we have see, how to write a code where:

		1. Use any editor/ide

		2. Install jdk/jre (https://www.oracle.com/in/java/technologies/javase/javase8-archive-downloads.html)

		3. Use notepad as a editor and write a code as

			class <cls_nm>
			{
				public static void main(String []args)
				{
					------------------;
					------------------;
					program_body ;
					------------------;
					------------------;
				}
			}

			class Demo
			{
				public static void main(String []args)
				{
					System.out.print("Welcome to Java Programming");
				}
			}

		4. Save the code in C:\Program Files\Java\jdk-17.0.1\bin As <class_nm>.java

		5. win+r --> cmd --> enter (attend the folder where the source file, compiler and interpreter is present) as

			C:\Users\hp>cd\
			C:\>cd "Program Files\Java\jdk-17.0.1\bin"
			C:\Program Files\Java\jdk-17.0.1\bin>javac Demo.java     (compilation where you get the bytecode (*.class) )
			C:\Program Files\Java\jdk-17.0.1\bin>java Demo  	 (Byte code interpretation)
				Welcome to Java Programming
			C:\Program Files\Java\jdk-17.0.1\bin>

	//------------------------------------------------------------------------------------------------------------------

	How to run, same code when source file (*.java) is in different folder
				
			C:\Users\hp>e:
			E:\>cd myjavafiles
			E:\myjavafiles>javac First.java

				'javac' is not recognized as an internal or external command,
				operable program or batch file.

			E:\myjavafiles>set path=C:\Program Files\Java\jdk-17.0.1\bin
			E:\myjavafiles>javac First.java
			E:\myjavafiles>java First
				Welcome to Java Programming-First
			E:\myjavafiles>

		Note that the path is applicable till the current session of the command prompt.
		to set the path in the permanent manner set the path in Environment variable


		Setting the environment variable: this pc --> rh+ click ---> properties --> adv. system settings
						--> Advanced tab --> environment variable --> user variable path


				-if already path is there -> edit --> new-> paste path (C:\Program Files\Java\jdk-17.0.1\bin)

				otherwise  user variable path--> new and write

				variable name --> path
				variable value --> C:\Program Files\Java\jdk-17.0.1\bin) --> ok....

//-------------------------------------------------------------------------------------------------------------
	Youtube Link: https://youtu.be/RBxum7M3B94?si=jepmNZAtetZfJKFp
//-------------------------------------------------------------------------------------------------------------


	Details of welcome program:
	============================

	class WelcomeProg
	{
		public static void main(String []args)
		{
			System.out.print("Welcome to Java by Archer InfoTech");
		}
	}
	
	Line 1: class WelcomeProg:

			class: It is keyword which allows you to create your own type.
			WelcomeProg: this is name of UDT, it must be valide identifier. Internally in java lib, the have
					  choosen, First letter of class name in uppercase and all other in lowercase if it is
					  made from from one word, if multiple words then first character of each word in ucase
					  and all other in lcase.

						e.g.	First, Demo, FirstProgram, ExampleDemoWelcome
					It is recommended, not compalsory

	Line 3: public static void main(String []args) 

			public: it is used to define the visiblity of method main(), coz the javac and java are not members of class
				as a outsiders they must have access to class members therefore visibility is public.
                               - This keyword makes the method accessible from anywhere. It ensures the JVM can access and call the main method 
                                  to start the program.


			static: The static members gains the memory space when class is loaded into memory, no need of object
				creation. therefore the method main() decl. as static
                               -The main method is declared as static so that it can be invoked without creating an instance of the class.     
                               This is important because the JVM starts execution without knowing the class's objects.


			void: It is returning type of method main(), it is void coz java program does not return any value to OS

			main(): It is method name, and as it is main(), it is considered as a starting point of of your program

			String []args: String is Built-in class from java.lang package, it is language support package, which is 
					imported bydefault. []args it is array of arguments, which is passed automatically at the
					time of execution from commandline, in absence null is collected. simply it is array of objects.

                               -This is an array of String objects that can hold command-line arguments passed to the program when it is executed.
                              For example, if you run the program as java MyProgram arg1 arg2, then args[0] will contain arg1 and args[1] will contain arg2.

	           Line 5:  System.out.print("Welcome to Java");

			"Welcome to Java" : It is data, to be displayed
			print() is a method from PrintStream class used to display the data on screen.
			out is predefined object of PrintStream class, declared as a static in System class
			System is a class from java.lang package.


	>>javac WelcomeProg.java (WelcomeProg - is a file name)
	>>java WelcomeProg (WelcomeProg - class name containing main() method)

 //-----------------------------------------------------------------------------------------------------------------------

	// When we write a file generally we keep file name and main class name same, but it may be different
	   In such case, compile using file name and run using main class name.
	
	   if a java file having two or more class defined within it, then there are those number of class
	   files, from which we have to use class name containing main() to run the program.

	lets see ...

class Sample
{
}
class Test
{
}
class WelcomeProgram
{
	public static void main(String []args)
	{
		System.out.print("Welcome to Java by Archer InfoTech");
	}
}

 --------- output ----------

C:\Users\archerinfotech>d:

D:\>cd jdyp

D:\jdyp>javac Welcome.java

D:\jdyp>java WelcomeProgram
Welcome to Java by Archer InfoTech
D:\jdyp>

//------------------------------------------------------------------------------------------

	// Knowing the String []args

	 - args : It refers to arguments, you can choose any name for it rather than args
	 - [] args: It represents array name
	 - String []args: Array of String objects, where String is class from java.lang package,
			  which is imported bydefault  

class MainArgu
{
	public static void main(String []args)
	{
		System.out.println(args);
		System.out.println("0 - "+args[0]);
		System.out.println("1 - "+args[1]);
		System.out.println("2 - "+args[2]);
	}
}

/*
  ------- How to run --------

	case 1:
		D:\jdyp>javac MainArgu.java

		D:\jdyp>java MainArgu
		[Ljava.lang.String;@4517d9a3
		Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length 0
       		 at MainArgu.main(MainArgu.java:6)

	case 2:

		D:\jdyp>javac MainArgu.java

		D:\jdyp>java MainArgu hello all
		[Ljava.lang.String;@4517d9a3
		0 - hello
		1 - all
		Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: Index 2 out of bounds for length 2
        		at MainArgu.main(MainArgu.java:8)

	case 3:
		D:\jdyp>javac MainArgu.java

		D:\jdyp>java MainArgu good morning all
		[Ljava.lang.String;@4517d9a3
		0 - good
		1 - morning
		2 - all

		D:\jdyp>java MainArgu good morning all of you
		[Ljava.lang.String;@4517d9a3
		0 - good
		1 - morning
		2 - all

		D:\jdyp>java MainArgu try 123 or 456
		[Ljava.lang.String;@4517d9a3
		0 - try
		1 - 123
		2 - or

 * Note that when there is no any argument at location, the interpreter will generate an error message at
   runtime class Exception which will terminate the program.

*/

//----------------------------------------------------------------------------------------------------

	Now we need to proceed using the path fillowed in the C and C++

	i.e.
				constant
	charcter set -----> 	keyword ------> Instructions ----> program ----> module ---> software
				variable


	Java Character set:

		- ASCII(American Standard Code for Information Interchange):  Provides the binary string to all symbols present
		  in the US English, which are used in different electronic devices.

		- ASCII used to code in english, but java supports different human understable languages for coding. means java
		  having rich character set as cmp to c/c++. The Standard Code system names unicode system used in the 
		  java which provides the 16 bit binary string to each symbol for different languages.     

		What is difference between ASCII and UNICODE.
		 - ASCII is suitable for basic, English-only text.
		 - Unicode is a comprehensive encoding system that supports global languages and symbols, making it the standard 
		   for modern computing.



	// Constants: These are the elements in the program having fix value.

							      Java Constants
								    |
							---------------------------
							|			  |
						    Numeric 		     Non-Numeric
							|			  |
						-----------------	-----------------
						|		|	|		|	
					   Integer     floating-point  character     String
					-6,4,56    -5.3,7.0,78.6755    'a', '$'     "A", "Hello"		
									'H' '4'	     "a123"

	// Keyword: These are reserved words, whose meaning is already known to compiler. 


		abstract	continue	for		new		switch

		assert***	default		goto*		package		synchronized
	
		boolean		do		if		private		this

		break		double		implements	protected	throw

		byte		else		import		public		throws

		case		enum****	instanceof	return		transient

		catch		extends		int		short		try

		char		final		interface	static		void

		class		finally		long		strictfp**	volatile

		const*		float		native		super		while 

		*	 	not used
		**	 	added in 1.2
		***	 	added in 1.4
		****	 	added in 5.0

	(https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html)


 	Java Data Types: Tool used for the memory allocation.

		- Primitive data types: These are provided by the language itself. e.g. int, char, byte..
		- Non-Primitive data types: The are defined by the programmers according to the need. e.g. class, interface


						Java Data Types
							|
					---------------------------------
					|				|
				Primitive Data Types		Non-Primitive Data Types
					|				|
			   --------------------------              - String
			   |			    |   	   - Array
		      Numeric		 	boolean	   	   - Vector
			  |	                (1 bit)
			------------------
			|		 |
		   Integrals	      character	
			|                |
	-------------------------      char(2)		
	|			|				
      integer		     floating point    		
      |				|					 
      |- byte (1)		|- float(4)    
      |- short (2)		|- double(8)
      |- int(4)
      |- long(8)


	- The default integer value is considered as a int and default fractional value considered as double.
	- When you decl the variable, java demands for the init. of variables, otherwise it will generate the
	  error message, 
				"variable xxx might not have been initialized"

	- When the value of variable having higher type is assigned to variable of lower type, then it will
	  generate the error message

		e.g.
			a=c;	gives the following error, when a is byte variable and c is int variable  e.g. = a(byte) = c(int)

			"possible lossy conversion from int to byte" 
		 
		In such case, where you want to convert the value from higher type to lower type, go for
		the type casting;

			i.e.	a=(byte)c;

		Note carefully that, lower type to higher type promoted automatically.

	- The long costant is represented using 'l' or 'L' as a prefix and for the float 'f' or 'F' is used.

	- Java allows you to decl. the variables anywhere in the program, just decl before using it.


	* What is difference between C,C++ data types and java data types?
	* Why java character needs 2 bytes?
	* Which are different higher level anguages used to code in java.

class Values
{
	public static void main(String []args)
	{
		int x=10;
		byte b=(byte)x;
		short s=(short)x;
		long l=25;
		System.out.println("\n x="+x+"\t b="+b+"\t s="+s+"\t l="+l);

		float f1=45.23F;
		double d1=f1;
		System.out.println("\n f1="+f1+"\t d1="+d1);

		float f2=(float)d1;
		System.out.println("\n f2="+f2);
	}

}

	----------- Execution Attempts ----------

D:\jdyp>javac Values.java
Values.java:6: error: incompatible types: possible lossy conversion from int to byte
                byte b=x;
                       ^
Values.java:7: error: incompatible types: possible lossy conversion from int to short
                short s=x;
                        ^
Values.java:11: error: incompatible types: possible lossy conversion from double to float
                float f1=45.23;
                         ^
Values.java:15: error: incompatible types: possible lossy conversion from double to float
                float f2=d1;
                         ^
4 errors

// after changing 

D:\jdyp>javac Values.java

D:\jdyp>java Values

 x=10    b=10    s=10    l=25

 f1=45.23        d1=45.22999954223633

 f2=45.23


	* What is widening conversion and narrowing conversion?

	In Java, widening conversion and narrowing conversion are two types of type conversions that occur when a value of one 
	data type is converted to another. These conversions happen in the context of primitive data types and determine whether 
	data is safely transformed or if precision might be lost.

	- Widening Conversion (Implicit Conversion): Converting a smaller (or less precise) data type to a larger (or more precise) 
	  data type. This is done automatically by the Java compiler because there’s no risk of data loss.

      public class WideningExample
           {
                 public static void main(String[] args)
              {
                   int num = 100; // Integer type
                   long longNum = num; // Widening from int to long
                   float floatNum = longNum; // Widening from long to float
  
                   System.out.println("Integer value: " + num);
                    System.out.println("Long value: " + longNum);
                    System.out.println("Float value: " + floatNum);
             }
         }



	- Narrowing Conversion (Explicit Conversion): Converting a larger (or more precise) data type to a smaller (or less precise) 
	  data type. This is not done automatically because there’s a risk of data loss or truncation.

          public class NarrowingExample
                 {
                     public static void main(String[] args)
                           {
                                double doubleNum = 99.99; // Double type
                                long longNum = (long) doubleNum; // Narrowing from double to long
                                int intNum = (int) longNum; // Narrowing from long to int

                                   System.out.println("Double value: " + doubleNum);
                                   System.out.println("Long value after narrowing: " + longNum);
                                   System.out.println("Integer value after narrowing: " + intNum);
                            }
                  }


  ****Questions: 

1. Can you list the data types in Java from smallest to largest for numeric widening conversions?
     -> Hint: byte → short → int → long → float → double.

2. What is the difference between widening a char to an int and narrowing an int to a char?

    Widening ( char ->int )
    - Implicit (automatic).
    - No data loss.
    - char's Unicode value is directly assigned to int

     Narrowing (int → char)
   - Explicit (requires casting).
   - Possible data loss or overflow.
   - Lower 16 bits of the int are used to determine the char.

    //----------------------------------------------------------------------------------------------------------------------

	// Different ways of Data Input in Java

 1. Data Input by direct initialzation

class InputUsinginit
{
	public static void main(String []args)
	{
		int x=134;	
		byte b=10;	
		char ch='$';	
		double db=56.2323;
		float ft=3.4F;
		boolean b=true;

		System.out.println("x="+x);		
		System.out.println("b="+b);
		System.out.println("value of ch is "+ch);
		System.out.println("db is"+db);
		System.out.println("float value "+ft);
		System.out.println("boolean value "+b);
	}
}

//----------------------------------------------------------------------------------------

 2. Data Input as a commandline argument

class DataInputCmdln
{
	public static void main(String []args)
	{
		String s1="-",s2="-";

		s1=args[0];
		s2=args[1];

		System.out.printn("String s1 is: "+s1);
		System.out.printn("String s2 is: "+s2);
	}
}
output:

E:\javapfsdn23>javac DataInputCmdln.java

E:\javapfsdn23>java DataInputCmdln hello all
String s1 is: hello
String s2 is: all

E:\javapfsdn23>java DataInputCmdln hello
Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length 1
        at DataInputCmdln.main(DataInputCmdln.java:8)

E:\javapfsdn23>java DataInputCmdln
Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length 0
        at DataInputCmdln.main(DataInputCmdln.java:7)


How to deal with such runtime errors called exception, which are generated when we will try to 
access the location which is not present.


class DataInputCmdln
{
	public static void main(String []args)
	{
		String s1="-",s2="-";

		try
		{
			s1=args[0];
			s2=args[1];
		}
		catch(Exception e){}

		System.out.println("String s1 is: "+s1);
		System.out.println("String s2 is: "+s2);
	}
}

output:

E:\javapfsdn23>javac DataInputCmdln.java

E:\javapfsdn23>java DataInputCmdln hello all
String s1 is: hello
String s2 is: all

E:\javapfsdn23>java DataInputCmdln hello
String s1 is: hello
String s2 is: -

E:\javapfsdn23>java DataInputCmdln
String s1 is: -
String s2 is: -


//----------------------------------------------------------------------------------------------------

We know the input is in form of strings and is true even when we try to pass numeric 
values coz they are automatically converted into strings, then how to input the numeric values

class DataInputCmdln
{
	public static void main(String []args)
	{
		int x=args[0];
		double y=args[1];

		System.out.println("x is: "+x);
		System.out.println("y is: "+y);
	}
}

on compile 


E:\javapfsdn23>javac DataInputCmdlnNumeric.java
DataInputCmdlnNumeric.java:6: error: incompatible types: String cannot be converted to int
                int x=args[0];
                          ^
DataInputCmdlnNumeric.java:7: error: incompatible types: String cannot be converted to double
                double y=args[1];
                             ^
2 errors

can be eliminated using ...
class DataInputCmdlnNumeric
{
	public static void main(String []args)
	{
		String x=args[0]; // "12"--> 12
		String y=args[1];

		System.out.println("x is: "+x);
		System.out.println("y is: "+y);
		System.out.println("Sum is: "+(x+y));
	}
}

will gives....!! 
D:\jdyp>javac DataInputCmdlnNumeric.java

D:\jdyp>java DataInputCmdlnNumeric 12 34
x is: 12
y is: 34
Sum is: 1234

To get correct output...
we have to convert the arguments in args(which are always Strings). into the required primitive
data type. And for that we have use pre-defined functionality,

 i.e. there are group of classes defined to represent the primitive type into equivalent 
 object type, known as "Wrapper Classes". All such class having method


 Q. Wrapper Classes in Java

    Wrapper classes in Java are used to convert primitive data types into objects. Each primitive type (e.g., int, char, double)
    has a corresponding wrapper class in the java.lang package. Wrapper classes are especially useful when working with collections like
    ArrayList or HashMap, which require objects instead of primitives.

	static <return_type> parse<xxxx>(String arg);

 which will convert the string into curresponding primitive numeric value.	

 primitive type -> Wrapper Class
	byte   -->  Byte
	short  -->  Short
	int   -->  Integer
	long  -->  Long
	float  --> Float
	double --> Double

difference

     primitive                             Wrapper Class
   
  1. Stores values directly.               Stores objects with values.
  2. Cannot be null.                       Can be null.
  3. Default Values (0, false)             null for wrapper objects.
  4. No methods available.                  Utility methods available.


Why Wrapper Classes?

Object Representation: Primitive types are not objects, but wrapper classes allow primitive values to be treated as objects.
Example: Storing int values in a List<Integer> (since List only accepts objects).

Utilities: Wrapper classes provide useful methods for parsing, converting, and performing operations.
Example: Converting a String to a primitive using Integer.parseInt().


class DataInputCmdlnNumeric
{
	public static void main(String []args)
	{
		int x=Integer.parseInt(args[0]); // "12"--> 12
		double y=Double.parseDouble(args[1]);

		System.out.println("x is: "+x);
		System.out.println("y is: "+y);
		System.out.println("Sum is: "+(x+y));
	}
}
E:\javapfsdn23>javac DataInputCmdlnNumeric.java

E:\javapfsdn23>java DataInputCmdlnNumeric
Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length 0
        at DataInputCmdlnNumeric.main(DataInputCmdlnNumeric.java:6)

E:\javapfsdn23>java DataInputCmdlnNumeric 12 67.45
x is: 12
y is: 67.45
Sum is: 79.45

//-------------------------------------------------------------------------------------------

	// 3. Input using java.io.InputStreamReader and java.io.BufferedReader

	In this communication InputStreamReader and BufferedReader are predefined classes from java.io Package.
	from which InputStreamReader communicates with default sterams System.in and provides the data to 
	BufferedReader and then after processing that data converted into string by the BufferedReader using
	methods like readLine().

	* How may default stream are present in java.
	- In Java, three default streams are provided for handling input and output. These streams are part of 
	  the java.lang.System class and are available by default for every Java application

		- System.in:  Used to read input from the standard input stream, typically the keyboard.
		- System.out: Used to write output to the standard output stream, typically the console.
		- System.err: Used to write output to the standard error stream, typically for logging 
			      or error messages.

 // Input different values from keyboard and just display them.

import java.io.BufferedReader;
import java.io.InputStreamReader;
class IOUsingBI
{
	public static void main(String []args)
	{
		InputStreamReader isr = new InputStreamReader(System.in);
		BufferedReader br = new BufferedReader(isr);

		System.out.println("\n Enter the string: ");
		String str = br.readLine();
		
		System.out.println("\n Enter the int value: ");
		int x=Integer.parseInt(br.readLine());
		
		System.out.println("\n Enter the fractional value: ");
		double y=Double.parseDouble(br.readLine());

		System.out.println("\n Enter the short value: ");
		Short z=Short.parseShort(br.readLine());

		System.out.printn("\n str: "+str+"\n x="+x+"\n y="+y+"\n z="+z);
	}
}

D:\jdyp>javac IOUsingBI.java
IOUsingBI.java:12: error: unreported exception IOException; must be caught or declared to be thrown
                String str = br.readLine();
                                        ^
IOUsingBI.java:15: error: unreported exception IOException; must be caught or declared to be thrown
                int x=Integer.parseInt(br.readLine());
                                                  ^
IOUsingBI.java:18: error: unreported exception IOException; must be caught or declared to be thrown
                double y=Double.parseDouble(br.readLine());
                                                       ^
IOUsingBI.java:21: error: unreported exception IOException; must be caught or declared to be thrown
                Short z=Short.parseShort(br.readLine());
                                                    ^
4 errors

	// Now we have two options to solve the problem.
		
	- Use try-catch block
	- use throws clause


 - using try-catch

import java.io.BufferedReader;
import java.io.InputStreamReader;
class IOUsingBI
{
	public static void main(String []args)
	{
		InputStreamReader isr = new InputStreamReader(System.in);
		BufferedReader br = new BufferedReader(isr);

		try
		{
			System.out.println("\n Enter the string: ");
			String str = br.readLine();
		
			System.out.println("\n Enter the int value: ");
			int x=Integer.parseInt(br.readLine());
		
			System.out.println("\n Enter the fractional value: ");
			double y=Double.parseDouble(br.readLine());

			System.out.println("\n Enter the short value: ");
			Short z=Short.parseShort(br.readLine());

			System.out.println("\n str: "+str+"\n x="+x+"\n y="+y+"\n z="+z);
		}
		catch(Exception e){ }
	}
}

 ------ Output -----------------

D:\jdyp>javac IOUsingBI.java

D:\jdyp>java IOUsingBI

 Enter the string:
hello

 Enter the int value:
12

 Enter the fractional value:
6.7

 Enter the short value:
34

 str: hello
 x=12
 y=6.7
 z=34

	// Character input using java.io.InputStreamReader and java.io.BufferedReader
	
- use throws clause

import java.io.BufferedReader;
import java.io.InputStreamReader;
class CharIOUsingBI
{
	public static void main(String []args) throws Exception
	{
		InputStreamReader isr = new InputStreamReader(System.in);
		BufferedReader br = new BufferedReader(isr);
		char ch=' ';
		
		System.out.println("\n Enter the character: ");
		ch = br.readLine().charAt(0);
		
		System.out.println("\n character is="+ch);
	}
}


//-------------------------------------------------------------------------------------------

	4. Using java.util.Scanner to take the input from keyboard

import java.util.Scanner;
class InputUsingScannerObject
{
	public static void main(String []args)
	{
		Scanner sc=new Scanner(System.in);

		String str="";
		int x=0;
		double db=0.0;
		char ch='$';

		System.out.println("Enter any String: ");
		str=sc.nextLine();

		System.out.println("Enter any int value: ");
		x=sc.nextInt();

		System.out.println("Enter any double value: ");
		db=sc.nextDouble();

		System.out.println("Enter any character: ");
		ch=sc.next().charAt(0);

		System.out.println("String str: "+str);
		System.out.println("int value: "+x);
		System.out.println("double value: "+db);
		System.out.println("char value: "+ch);		
	}
}

output:

E:\javapfsdn23>javac InputUsingScannerObject.java

E:\javapfsdn23>java InputUsingScannerObject
Enter any String:
aaaa
Enter any int value:
12
Enter any double value:
3.3
Enter any character:
r
String str: aaaa
int value: 12
double value: 3.3
char value: r

 //-------------------------------------------------------------------------------------------------------

	5. Using javax.swing.JOptionPane.showInputDialog()

import javax.swing.JOptionPane;
class InputUsingShowIpDialog
{
	public static void main(String []args)
	{
		int x=0;
		double y=0.0;

		x=Integer.parseInt(JOptionPane.showInputDialog("Enter any int value: "));	
		y=Double.parseDouble(JOptionPane.showInputDialog("Enter any double value: "));	

		System.out.println("int value: "+x);
		System.out.println("double value: "+y);		
	}
}	

///=========================================================================================================================

// Operators in Java: Operators are used to process the data. There are following operators
			      present in the java.

			- Assignment Operators (= and short-hand operators)
			- Unary Operators ( - ++ -- (type) )
			- Arithmetic Operators ( + - * / % )
			- Relational Operators ( < <= > >= == != )
			- Logical Operators (&& || !)
			- conditional Operator ( ? : )
			- Bitwise Operators (& | ^ >> << >>>)
			- special Operators (. and instanceof )




- Assignment Operators (= and short-hand operators): will assigns constant value at its rh+, value of variable at its rh+ or
			answer of exper at its rh+ to variable at left.

		e.g.
			int x=10;	int y=x;	int z=x+y;

			shorthand expr: 	suppose,	x=x+10	can be written as x+=10;
								x=x/10  --> x/=10
								....

class DemoAssignment
{
	public static void main(String []args)
	{
		int x=10;
		int y=x;
		int z=x+y;
	
		System.out.println("\n x="+x+"\t y="+y+"\t z="+z);

		x+=100;
		y*=2;
		System.out.println("\n x="+x+"\t y="+y+"\t z="+z);

	}
}

//-------------------------------------------------------------------------------------------------------------------

- Unary Operators ( - ++ -- (type) )

	- will gives oppisite value
	++ incr by 1
	-- decr by 1

		inc/dec
		  |
	--------------------------
	|			|
     pre 		      post
  (++x, --x)		  (x++, x--)		


	++x  <-----> x=x+1	<------> x++
	--x  <-----> x=x-1      <------> x--

	when these operators are used in the expression, 

		pre --> expr --> post

	suppose x=5, and y=9

		z = ++x + y-- ;

	- find the basic expr
	- operate all pre operators
	- calc. the basic expr. with current values
	- operator all post operators

	- x becomes 6
	- assigned 15 to z
	-y becomes 8

import java.util.Scanner;
class DemoUnary
{
	public static void main(String []args)
	{
		int x=0;
		int y=0;
		int z=0;
	
		Scanner sc= new Scanner(System.in);
		System.out.println("\n Enter the values of x and y: ");
		x=sc.nextInt();
		y=sc.nextInt();

		z=-x;
		x++;
		--y;
		System.out.println("\n x="+x+"\t y="+y+"\t z="+z);

		z=++x+y--;
		System.out.println("\n x="+x+"\t y="+y+"\t z="+z);
	}
}

//------------------------------------------------------------------------


	(type): It refers to type casting, means changing the data type of variable obly at the of calc.


import java.util.Scanner;
class DemoCasting
{
	public static void main(String []args)
	{
		int x=0,y=0;
		double z=0;
	
		Scanner sc= new Scanner(System.in);
		System.out.println("\n Enter the values of x and y: ");
		x=sc.nextInt();
		y=sc.nextInt();  // 13, 5

		z=x/y;		
		System.out.println("\n x="+x+"\t y="+y+"\t z="+z);

		z=(double)x/y;		
		System.out.println("\n x="+x+"\t y="+y+"\t z="+z);

		z=x/(double)y;		
		System.out.println("\n x="+x+"\t y="+y+"\t z="+z);

		z=(double)x/(double)y;		
		System.out.println("\n x="+x+"\t y="+y+"\t z="+z);

	}
}

output: 
E:\jprodyp>javac DemoCasting.java

E:\jprodyp>java DemoCasting

 Enter the values of x and y:
13
5

 x=13    y=5     z=2.0

 x=13    y=5     z=2.6

 x=13    y=5     z=2.6

 x=13    y=5     z=2.6

//----------------------------------------------------------------------------------------
- Arithmetic Operators ( + - * / % )

	// program to calc the simple interst.

import java.io.InputStreamReader;
import java.io.BufferedReader;
class DemoArith
{
	public static void main(String []args) throws Exception
	{
		BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
		int p=0,n=0;
		double r=0.0,si=0.0;

		System.out.println("Enter the value of p: ");
		p=Integer.parseInt(br.readLine());

		System.out.println("Enter the value of r: ");
		r=Double.parseDouble(br.readLine());

		System.out.println("Enter the value of n: ");
		n=Integer.parseInt(br.readLine());
	
		si=(p*r*n)/100;

		System.out.println("Simple Interst is: "+si);
	}
}


	Using % and / operator

	lets see simple example, we have to calculate 13/5

		   2 <------------- (13/5)
		________
	      5 )  13
		 - 10
		---------
		    3 <----------- (13%5)

 lets see some examples, ovserve the result and write the conclusion

	13/5=2		13%5=3
	27/7=3		27%7=6
	67/9=7		67%9=4
	123/10=12	123%10=3
	459/10=45	459%10=9
	3857/10=385	3857%10=7
	7/10=0		7%10=7

	- Div by 10 eliminates the last digit from number.
	  and mod by 10 gives the last digit.
	- In N/D, when N<D then div is 0 and rem is N

   // Enter any 3 digit number from keyboard and find addition of its all digits.
  // no=285 then ans = 5+8+2 => 15

import java.util.Scanner;
class DemoDivMod
{
	public static void main(String []args)
	{
		int no=0,rem=0,tot=0;
		Scanner sc=new Scanner(System.in);

		System.out.println("\n Enter any 3 digit number: ");
		no=sc.nextInt(); //285
	
		rem=no%10; //5
		tot=tot+rem; // 0+5=5
		no=no/10; //28
	
		rem=no%10; //8
		tot=tot+rem; // 5+8=13
		no=no/10; //2	

		rem=no%10; //2
		tot=tot+rem; // 13+2=15
		no=no/10; //0

		System.out.println("\n Total is "+tot);
	}		
} 

Unlike C/C++, Here in java you can operate the % operator on fractional and -ve values,
when you operate the % operator on -ve values the sign of ans is taken as the sign of N form N/D.
class DemoMod
{
	public static void main(String []args)
	{
		int x=-13, y=5, z=-2;

		System.out.println("-%+: "+(x%y));
		System.out.println("-%-: "+(x%z));
		System.out.println("+%-: "+(21%z));
		System.out.println("+%+: "+(33%4));

		System.out.println("+%+: "+(33.5%4));
		System.out.println("+%+: "+(36.5%2.3));
	}
}

//-----------------------------------------------------------------------------------------

	// Relational Operators: (<, <=, >, >= ==, !=): These operators are used to find the
		relation between two operands. It will forms the condition which is useful in the
		conditional conditional control statements.

		thw ans of condition is boolean value true when it is true and false when false.


	suppose x=23	y=5;

		x>y	----> true 	means if we write z=x>y then true assigned to z.

		x!=y	----> true 
		
		y<1	----> false
		
		x%10==0 ----> false 

		100%y==0 ---> true 

class DemoRel
{
	public static void main(String []args)
	{
		int x=23,y=5;
		boolean b;
		System.out.println("\n x is: "+x+"\t y is: "+y);

		b=x>y;
		System.out.println("\n (x>y) is: "+b);

		b=x!=y;
		System.out.println("\n (x!=y) is: "+b);

		b=y<1;
		System.out.println("\n (y<1) is: "+b);

		b=x%10==0;
		System.out.println("\n (x%10==0) is: "+b);

		b=100%y==0;
		System.out.println("\n (100%y==0) is: "+b);
		
	}
}
output

E:\jprodyp>javac DemoRel.java

E:\jprodyp>java DemoRel

 x is: 23 y is: 5

 (x>y) is: true

 (x!=y) is: true

 (y<1) is: false

 (x%10==0) is: false

 (100%y==0) is: true

//-----------------------------------------------------------------------------------------------

	/// Logical Operator ( && || !): These operators are used to join two or more conditions

		when the conditions are joind by

		- && --> gives true only when both true otherwise false
		- || --> gives false only when both false otherwise true
		- !  --> gives
				!(true) ---> false
				!(false) ---> true
				

	suppose x=23	y=5;

		(x>y)&&(y<100)	----> true 
		(x>y)&&(y>100)	----> false

		(x>y)||(y>100)	----> true 
		(x<y)||(y>100)	----> false
	
		!(x!=y)	----> false 	
		!(y<1)	----> true


class DemoLogical
{
	public static void main(String []args)
	{
		int x=23,y=5;
		boolean b;
		System.out.println("\n x is: "+x+"\t y is: "+y);

		b=(x>y)&&(y<100);
		System.out.println("\n ((x>y)&&(y<100)) is: "+b);

		b=(x>y)&&(y>100);
		System.out.println("\n ((x>y)&&(y>100)) is: "+b);

		b=(x>y)||(y>100);
		System.out.println("\n ((x>y)||(y>100)) is: "+b);

		b=(x<y)||(y>100);
		System.out.println("\n ((x<y)||(y>100)) is: "+b);

		b=!(x!=y);
		System.out.println("\n (!(x!=y)) is: "+b);

		b=!(y<1);
		System.out.println("\n (!(y<1)) is: "+b);
		
	}
}

output: 
E:\jprodyp>javac DemoLogical.java

E:\jprodyp>java DemoLogical

 x is: 23        y is: 5

 ((x>y)&&(y<100)) is: true

 ((x>y)&&(y>100)) is: false

 ((x>y)||(y>100)) is: true

 ((x<y)||(y>100)) is: false

 (!(x!=y)) is: false

 (!(y<1)) is: true

///--------------------------------------------------------------------------------------
// Conditional operator or ternary operator or if-then-else operator(?:):

		This is the only operator which has decision abiity.
	
		syntax:

			<condition> ? <options>;

			<condition> ? <true_part> : <false_part> ;

	// WAP to find the max from 2 nos

import java.util.Scanner;
class DemoConditionalOperator
{
	public static void main(String []args)
	{
		Scanner sc=new Scanner(System.in);
		int x=0,y=0;

		System.out.println("\n Enter any two nos: ");
		x=sc.nextInt();
		y=sc.nextInt();

		int z = (x>y) ? x : y ;
		System.out.println("\n Max no: "+z);
	}
}

output:
E:\jprodyp>javac DemoConditionalOperator.java

E:\jprodyp>java DemoConditionalOperator

 Enter any two nos:
45
78

 Max no: 78

E:\jprodyp>java DemoConditionalOperator

 Enter any two nos:
90
23

 Max no: 90

///------- Nesting of conditional operators


	// WAP to find the max from 3 nos

import java.util.Scanner;
class DemoConditionalOperator1
{
	public static void main(String []args)
	{
		Scanner sc=new Scanner(System.in);
		int x=0,y=0,z=0;

		System.out.println("\n Enter any three nos: ");
		x=sc.nextInt();
		y=sc.nextInt();
		z=sc.nextInt();

		int max = (x>y) ? (x>z?x:z) : (y>z?y:z) ;
		System.out.println("\n Max no: "+max);
	}
}

output:
E:\jprodyp>javac DemoConditionalOperator1.java

E:\jprodyp>java DemoConditionalOperator1

 Enter any three  nos:
11
22
33

 Max no: 33

E:\jprodyp>java DemoConditionalOperator1

 Enter any three nos:
111
22
33

 Max no: 111

E:\jprodyp>java DemoConditionalOperator1

 Enter any three nos:
11
222
33

 Max no: 222

//-----------------------------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------------------------------------

   	/// Bitwise Operator: [ & | ^ >> << >>> ]
 
    These operators are used in the bit level operations.

        & ==> 1 & 1 -> 1 otherwise 0
        | ==> 0 | 0 -> 0 otherwise 1

              0^0
        ^ -->     ==> 0 otherwise 1
              1^1

    suppose x=10       y=12

        (0000 1010)     (0000 1100)

    (x&y)       (x|y)       (x^y)

    1010        1010        1010
   &1100       |1100       ^1100
  ========    ========     =======
    1000        1110        0110
    (8)          (14)        (6)


    x=10 (0000 1010)     y=12  (0000 1100)

     z=x<<2              z=y>>2
       (0010 1000)       (0000 0011)
       ==>40            ==> 3


class DemoBitwise
{
	public static void main(String []args)
	{
		int x=10,y=12;
		System.out.println("\n (x&y) is"+ (x&y) );

		System.out.println("\n (x|y) is"+ (x|y) );

		System.out.println("\n (x^y) is"+ (x^y) );

		System.out.println("\n (x<<2) is"+ (x<<2) );

		System.out.println("\n (y>>2) is"+ (y>>2) );
		
	}
}

//---------------------------------------------------------------------------------------------------------------------------------

	Associativity and precedence are fundamental concepts in programming that determine how operators 
	are evaluated in expressions.

	Precedence: Precedence refers to the order in which operators are evaluated when multiple operators 
		    are present in an expression. Operators with higher precedence are evaluated first.

	Associativity: Associativity defines the order in which operators with the same precedence are 
		       evaluated. There are two types of associativity:

			1. Left-to-Right (LTR): Operators are evaluated from left to right.
			2. Right-to-Left (RTL): Operators are evaluated from right to left.

Java Operator Precedence and Associativity Table:

Here's a summary of Java operators, their precedence, and associativity:

| Operator        		| Precedence 	| Associativity |
| ---             		| ---       	| ---          	|
| Postfix ([])    		| 1         	| LTR         	|
| Unary (+, -, !) 		| 2         	| RTL          	|
| Multiplicative (*, /, %) 	| 3 		| LTR          	|
| Additive (+, -) 		| 4         	| LTR          	|
| Shift (<<, >>, >>>) 		| 5 		| LTR       	|
| Relational (<, >, <=, >=) 	| 6 		| LTR          	|
| Equality (==, !=) 		| 7 		| LTR          	|
| Bitwise AND (&) 		| 8         	| LTR          	|
| Bitwise XOR (^) 		| 9         	| LTR          	|
| Bitwise OR (|)  		| 10        	| LTR          	|
| Logical AND (&&) 		| 11 		| LTR          	|
| Logical OR (||) 		| 12        	| LTR          	|
| Ternary (? :)  		| 13        	| RTL         	|
| Assignment (=, +=, -=, ...) 	| 14 		| RTL          	|

Examples:

1. Expression: 2 + 3 * 4

Precedence: Multiplication (*) has higher precedence than addition (+).
Evaluation: 2 + (3 * 4) = 2 + 12 = 14

1. Expression: 5 - 3 + 2

Precedence: Subtraction (-) and addition (+) have the same precedence.
Associativity: Left-to-Right.
Evaluation: (5 - 3) + 2 = 2 + 2 = 4

1. Expression: true && false || true

Precedence: Logical AND (&&) has higher precedence than Logical OR (||).
Associativity: Left-to-Right.
Evaluation: (true && false) || true = false || true = true

1. Expression: x = 5 + 3

Precedence: Addition (+) has higher precedence than assignment (=).
Associativity: Right-to-Left.
Evaluation: x = (5 + 3) = x = 8

//---------------------------------------------------------------------------------------------------------------------------------

// Control Statements in Java: 


				Control Statements
					|
			-------------------------------------
			|				    |
		   Conditional				Un-Conditional
			|					|
	------------------------------	        ---------------------------------
	|		|	    |		|	|		|	|
      Decision	      Loop	  case	       break   continue     lbl.break	return
	|		|	    |				    and 
	|- if()		|- for()   switch			    lbl. continue	
	|- if() else	|- while()
	|- nesting	|- do..while()
	|- ladder


//  Decision Conditional Control statment: 

	
	// Using if(): used to decide, execute the block of code or not. That block is mentioned in the program as

			syntax:
				if(<condi>)
				{
					-------------;
					-------------;
					block of code;
					-------------;
					-------------;
				}
				
	- Block of code will be executed only when the condition is true otherwise it will be skipped

import java.io.InputStreamReader;
import java.io.BufferedReader;
class DemoIf
{
	public static void main(String []args)
	{
		InputStreamReader isr=new InputStreamReader(System.in);
		BufferedReader br=new BufferedReader(isr);

		int a=0;
		try
		{
			System.out.println("Enter the value of a: ");
			a=Integer.parseInt(br.readLine());
		}
		catch(Exception e){}		

		if(a%7==0)
		{
			System.out.println("Entered no is div by 7 ");
		}
		if(a%7!=0)
		{
			System.out.println("Entered no is not div by 7 ");
		}
	}
}

//-----------------------------------------------------------------------------------


	// Using if() else: It is used when you want to execute any one code block from two different blocks
	//		    according to condition.


		syntax:
			if(<condi>)
			{
				-----------------;
				---------------;
				----------------;
			}
			else 
			{
				-----------------;
				---------------;
				----------------;
			}

		when <condi> is  TRUE --> will execute the if() block only
				 FALSE -> will execute the else block only

import java.io.InputStreamReader;
import java.io.BufferedReader;
class DemoIfElse
{
	public static void main(String []args)
	{
		InputStreamReader isr=new InputStreamReader(System.in);
		BufferedReader br=new BufferedReader(isr);

		int a=0;
		try
		{
			System.out.println("Enter the value of a: ");
			a=Integer.parseInt(br.readLine());
		}
		catch(Exception e){}		

		if(a%7==0)
		{
			System.out.println("Entered no is div by 7 ");
		}
		else
		{
			System.out.println("Entered no is not div by 7 ");
		}
	}
}


	// 	Using Nesting of if() else:

			Nesting refers to using one control statment in to same or another control statement


	some combinations:


		if()				if()				if()			if()
		{				{				{			{
			if()				if()			}				if()
			{				{			else				{
			}				}			{				}
		}					else				if()		}
							{				{		else
							}				}		{
						}				}				if()
														{
														}
													}


		
		if()					if()
		{					{
			if()					if()	
			{					{
			}					}
		}						else
		else						{
		{						}
			if()				}
			{				else
			}				{
			else					if()
			{					{
			}					}
		}						else
								{
								}
							}


class DemoIfElseNesting
{
	public static void main(String []args)
	{
		int a=Integer.parseInt(args[0]);
		int b=Integer.parseInt(args[1]);
		int c=Integer.parseInt(args[2]);

		if(a>b)
		{
			if(a>c)
			{
				System.out.println("\n a is max");
			}
			else
			{
				System.out.println("\n c is max");
			}
		}	
		else
		{
			if(b>c)
			{
				System.out.println("\n b is max");
			}
			else
			{
				System.out.println("\n c is max");
			}
		}
	}
}

//---------------------------------------------------------------------------------------------------------------------


	// Using if() else Ladder

	syntax:

		if(<>)
		{
			---------;
			---------;
		}
		else if(<>)
		{
			---------;
			---------;
		}
		else if(<>)
		{
			---------;
			---------;
		}
		else if(<>)
		{
			---------;
			---------;
		}
		[<else>]
		{
			---------;
			---------;
		}


	// Enter the co-ordinates of point in 2D system, and display the exact location of that point.


			       y axis
                                ^
                       II QD    |   I QD
                                |
                        -+      |   ++
                                |
                  <-------------|------------> x axis
                                |(0,0)
                                |
                        --      |   +-
                                |
                    III QD      V     IV QD



                There are 7 different possibilities.

import java.util.Scanner;
class DemoIfElseLadder
{
	public static void main(String []args)
	{
    		int x=0,y=0;
		Scanner sc=new Scanner(System.in);

    		System.out.println("\n Enter the x cord: ");
    		x=sc.nextInt();
    		System.out.println("\n Enter the y cord: ");
    		y=sc.nextInt();

    		if(x>0&&y>0)
    		{
        		System.out.println("\n Point present in I st qd");
    		}
    		else if(x<0&&y>0)
    		{
        		System.out.println("\n point present in II nd qd");
    		}
    		else if(x<0&&y<0)
    		{
        		System.out.println("\n Point is present in 3 rd qd");
    		}
    		else if(x>0&&y<0)
    		{
        		System.out.println("\n Point is present in 4 th qd");
    		}
    		else if(x!=0&&y==0)
    		{
        		System.out.println("\n Point is present on x axis");
    		}
    		else if(x==0&&y!=0)
    		{
        		System.out.println("\n Point is present on y axis");
    		}
    		else 
    		{
        		System.out.println("\n Point present at org");
    		}
	}
}


------------------------------------------------------------------------------------------------------------------------------------

		// Using the Loops in Java: Loops are used to avoid the continue repitition of code in the program.
					 There are three different loops in C.

				1. For() loop		2. While() loop		3. do..While() loop



	1. For() loop:

		syntax:	
				
			for( [<init>] ; <condi> ; [<inc/dec/stat/expr>] )					
			{									
				--------------;							   
				--------------;						
				--------------;							 
				--------------;							
				--------------;				
			}
		


import javax.swing.JOptionPane;
class DemoFor
{
	public static void main(String []args)
	{
		int no=Integer.parseInt(JOptionPane.showInputDialog("Enterany number:"));
	
		int t=0,tot=0;
		for(t=no;no!=0;no=no/10)
		{
			tot=tot+(no%10); 
		}
		System.out.println("\n Addition of all digits from "+t+" is "+tot");
	}
}

                ///-------------------------------------------------------------------------------------------------------------------------

	//  Using while loop: 

		Again the aim is same i.e. used to avoid the code rep.

		syntax:
			while(<cond>)
			{
				----------------;
				----------------;
				----------------;
				----------------;
				****************;
			}

			- It will execute the body of loop, till the condition is true.

			- <init> block is absent in while() but you have init. the iterator before starting of loop.

			- <inc/dec> block is absent, but you have to add atleast one statement which will make the <cond> false
			  after some iterations. otherwise it will attend the infinite looping


	/// WAP to display 1 to 15 nos using while loop

class DemoWhile
{
	public static void main(String []args)
	{
		int i;

		i=1;
		while(i<=15)
		{
			System.out.println(" "+i);
			i++;
		}
	}
}

//-------------------------------------------------------------------------------------------
	/// WAP to display list of odd nos from 1 to 50 using while loop.

class DemoWhile
{
	public static void main(String []args)
	{
		int i;

		i=1;
		while(i<=50)
		{
			if(i%2!=0)
			{
				System.out.println(" "+i);
			}
			i++;
		}
	}
}

//--------------------------------------------------------------------------


	// WAP to find the entered number is prime

import java.util.*;
class DemoWhile
{
	public static void main(String []args)
	{
		Scanner sc=new Scanner(System.in);

		System.out.println("\n Enter any no: ");
		int no=sc.nextInt();
		int d=2;
		int flg=0;
		while(d<=(no/2))
		{
			if(no%d==0)
			{
				flg=1;
				break;
			}
			d++;
		}
		if(flg==0)
		{
			System.out.println("\n Entered no is prime ");
		}
		else
		{
			System.out.println("\n Entered no is not prime ");
		}
	}
}

//-----------------------------------------------------------------------------------------

	/// using  do while()

	syntax:

	do
	{
		----------;
		----------;
		----------;
		----------;
		----------;
	}while(<cond>);

// Display list of prime nos from given range 

import java.util.*;
class DemoWhile
{
	public static void main(String []args)
	{
		Scanner sc=new Scanner(System.in);

		System.out.println("\n Enter the range starts from: ");
		int n1=sc.nextInt();
		System.out.println("\n Enter the range ends to: ");
		int n2=sc.nextInt();

		int d=2,flg=0;
		System.out.println("\n List of prime nos: ");
		for(no=n1;no<=n2;no++)
		{
			d=2;
			flg=0;
			while(d<=(no/2))
			{
				if(no%d==0)
				{
					flg=1;
					break;
				}
				d++;
			}
			if(flg==0)
				System.out.println("  "+no);
		}
	}

//------------------------------------------------------------------------------------------------------------------------------
	
	// WAP to display *

class StarPattern
{
	public static void main(String []args)
	{
		System.out.print("*")
	}
}


class StarPattern
{
	public static void main(String []args)
	{
		System.out.print("*");
	}
}

//-----------------------------------------------------

	WAP to print 
	*****

class StarPattern
{
	public static void main(String []args)
	{
		int j=0;
		for(j=0;j<5;j++)
		{
			System.out.print("*");
		}
	}
}



//-----------------------------------------------------

	WAP to print 
	*****
	*****
	*****
	*****
	*****

class StarPattern
{
	public static void main(String []args)
	{
		int i, j=0;
		for(i=0;i<5;i++)
		{
			for(j=0;j<5;j++)
			{
				System.out.print("*");
			}
			System.out.print("\n");
		}
	}
}

//-----------------------------------------------------

	WAP to print 
           j
        01234 
	*****  i=0
	*   *  i=1
	*   *  i=2
	*   *  i=3
	*****  i=4

class StarPattern
{
	public static void main(String []args)
	{
		int i, j=0;
		for(i=0;i<5;i++) // No of lines
		{
			for(j=0;j<5;j++) // no of cols
			{
				if(i==0 || i==4)
				{
					System.out.print("*");
				}
				else if(j==0 || j==4)
				{
					System.out.print("*");
				}
				else
				{
					System.out.print(" ");
				}
			}
			System.out.print("\n");
		}
	}
}

//-------------------------------------------------------------------------------------

	WAP to print 
	* 
	** 
	*** 
	**** 
	*****


class StarPattern
{
	public static void main(String []args)
	{
		int i, j=0;

		for(i=0;i<5;i++)
		{
			for(j=0;j<5;j++)
			{
				if(j<=i)
				{
					System.out.print("*");	
				}			
			}
			System.out.print("\n");
		}
	}
}



//-----------------------------------------------------

	WAP to print 
	*****
	**** 
	*** 
	** 
	* 

class StarPattern
{
	public static void main(String []args)
	{
		int i, j=0;

		for(i=0;i<5;i++)
		{
			for(j=0;j<5;j++)
			{
				if(j<(5-i))
				{
					System.out.print("*");	
				}			
			}
			System.out.print("\n");
		}
	}
}

//---------------------------------------------------------------------

		*
	       ***
	      *****
	     *******
	    *********
           *********** 	

class StarPattern
{
	public static void main(String []args)
	{
		int i, j=0;
		for(i=0;i<6;i++)
		{
			for(j=0;j<(6+i);j++)
			{
				if(j<(5-i))
				{
					System.out.print(" ");	
				}
				else
				{
					System.out.print("*");
				}
			}
			System.out.print("\n");
		}
	}
}

//-------------------------------------------------------------------------
 
     1
    222
   33333
  4444444
 555555555
66666666666

class StarPattern
{
	public static void main(String []args)
	{
		int i, j=0;
		for(i=0;i<6;i++)
		{
			for(j=0;j<(6+i);j++)
			{
				if(j<(5-i))
				{
					System.out.print(" ");	
				}
				else
				{
					System.out.print(i+1);
				}
			}
			System.out.print("\n");
		}
	}
}

//---------------------------------------------------------------------------------


     A
    ABC
   ABCDE
  ABCDEFG
 ABCDEFGHI
ABCDEFGHIJK

class StarPattern
{
	public static void main(String []args)
	{
		int i, j=0;
		char ch;
		for(i=0;i<6;i++)
		{
			ch='A';
			for(j=0;j<(6+i);j++)
			{
				if(j<(5-i))
				{
					System.out.print(" ");	
				}
				else
				{
					System.out.print(ch);
					ch++;
				}
			}
			System.out.print("\n");
		}
	}
}

//----------------------------------------------------------------------------------------

switch(): It is used in the menu driven programming.

	syntax:
		
		switch(<opt>)
		{
			case <CC>:
				---------;
				---------;
				break;
			case <CC>:
				---------;
				---------;
				break;
			case <CC>:
				---------;
				---------;
				break;
			case <CC>:
				---------;
				---------;
				break;
			[<default>]:
				-----------;
				----------;
		}
		------------------;


	The switch case is used when there are more possibilities, and from which we have to 
	choose any one according to users choice.


import java.util.Scanner;
class DemoSwitch
{
	public static void main(String []args)
	{
		Scanner sc=new Scanner(System.in);
		int opt=0;
		double a=0.0, b=0.0, ans=0.0;

		System.out.println("\n*** Menu ****");
		System.out.println("1.add \n 2.sub \n 3.multi \n 4.div ");
		System.out.println("select your option: ");
		opt=sc.nextInt();

		System.out.println("Enter any two nos: ");
		a=sc.nextDouble();
		b=sc.nextDouble();
		
		switch(opt)
		{
			case 1:
				ans=a+b;
				break;
			case 2:
				ans=a-b;
				break;
			case 3:
				ans=a*b;
				break;
			case 4:
				ans=a/b;
				break;
			default:
				System.out.println("\n Incorrect Option");			
		}	
		System.out.println("\n Ans is: "+ans);					
	}
}

//--------------------------------------------------------------------------------------

	// Using the character as a option (both lcase and ucase for a single case)

import java.util.Scanner;
class DemoSwitch
{
	public static void main(String []args)
	{
		Scanner sc=new Scanner(System.in);
		char opt=0;
		double a=0.0, b=0.0, ans=0.0;

		System.out.println("\n*** Menu ****");
		System.out.println(" a.add \n b.sub \n c.multi \n d.div ");
		System.out.println("select your option: ");
		opt=sc.nextLine().charAt(0);

		System.out.println("Enter any two nos: ");
		a=sc.nextDouble();
		b=sc.nextDouble();
		
		switch(opt)
		{
			case 'A':
			case 'a':
				ans=a+b;
				break;
			case 'B':
			case 'b':
				ans=a-b;
				break;
			case 'C':
			case 'c':
				ans=a*b;
				break;
			case 'D':
			case 'd':
				ans=a/b;
				break;
			default:
				System.out.println("\n Incorrect Option");			
		}	
		System.out.println("\n Ans is: "+ans);					
	}
}
//-------------------------------------------------------------------------------------------

import java.util.Scanner;
class DemoSwitch
{
	public static void main(String []args)
	{
		Scanner sc=new Scanner(System.in);
		int i=0, opt=0;
		double a=0.0, b=0.0, ans=0.0;

		while(i<3)
		{
			i++;
			System.out.println("\n*** Menu ****");
			System.out.println("1.add \n 2.sub \n 3.multi \n 4.div ");
			System.out.println("select your option: ");
			opt=sc.nextInt();

			System.out.println("Enter any two nos: ");
			a=sc.nextDouble();
			b=sc.nextDouble();
		
			switch(opt)
			{
				case 1:
					ans=a+b;
					break;
				case 2:
					ans=a-b;
					break;
				case 3:
					ans=a*b;
					break;
				case 4:
					ans=a/b;
					break;
				default:
					System.out.println("\n Incorrect Option");			
			}	
			System.out.println("\n Ans is: "+ans);					
		}
	}
}
//-------------------------------------------------------------------------------------------

	// Using the switch within infinite loop (Termination using break)

import java.util.Scanner;
class DemoSwitch
{
	public static void main(String []args)
	{
		Scanner sc=new Scanner(System.in);
		int opt=0;
		double a=0.0, b=0.0, ans=0.0;

		while(true)
		{
			System.out.println("\n*** Menu ****");
			System.out.println("1.add \n 2.sub \n 3.multi \n 4.div \n 5.stop");
			System.out.println("select your option: ");
			opt=sc.nextInt();

			if(opt==5)
				break;

			System.out.println("Enter any two nos: ");
			a=sc.nextDouble();
			b=sc.nextDouble();
		
			switch(opt)
			{
				case 1:
					ans=a+b;
					break;
				case 2:
					ans=a-b;
					break;
				case 3:
					ans=a*b;
					break;
				case 4:
					ans=a/b;
					break;
				default:
					System.out.println("\n Incorrect Option");			
			}	
			System.out.println("\n Ans is: "+ans);					
		}
	}
}



//-------------------------------------------------------------------------------------------

	// Using the switch within infinite loop (Termination using System.exit(0) )

import java.util.Scanner;
class DemoSwitch
{
	public static void main(String []args)
	{
		Scanner sc=new Scanner(System.in);
		int opt=0;
		double a=0.0, b=0.0, ans=0.0;

		while(true)
		{
			System.out.println("\n*** Menu ****");
			System.out.println("1.add \n 2.sub \n 3.multi \n 4.div \n 5.stop");
			System.out.println("select your option: ");
			opt=sc.nextInt();
			System.out.println("Enter any two nos: ");
			a=sc.nextDouble();
			b=sc.nextDouble();
		
			switch(opt)
			{
				case 1:
					ans=a+b;
					break;
				case 2:
					ans=a-b;
					break;
				case 3:
					ans=a*b;
					break;
				case 4:
					ans=a/b;
					break;
				case 5:
					System.exit(0);
				default:
					System.out.println("\n Incorrect Option");			
			}	
			System.out.println("\n Ans is: "+ans);					
		}
	}
}
//---------------------------------------------------------------------------------------

	// We can use string as a case constant.
import java.util.Scanner;
class DemoSwitchStr
{
	public static void main(String []args)
	{
		Scanner sc=new Scanner(System.in);
		
		double a=0.0, b=0.0, ans=0.0;

		System.out.println("\n*** Menu ****");
		System.out.println("add \n sub \n multi \n div ");
		System.out.println("select your option: ");
		String opt=sc.nextLine();

		System.out.println("Enter any two nos: ");
		a=sc.nextDouble();
		b=sc.nextDouble();
		
		switch(opt)
		{
			case "add":
				ans=a+b;
				break;
			case "sub":
				ans=a-b;
				break;
			case "multi":
				ans=a*b;
				break;
			case "div":
				ans=a/b;
				break;
			default:
				System.out.println("\n Incorrect Option");			
		}	
		System.out.println("\n Ans is: "+ans);					
	}
}
//---------------------------------------------------------------------------------------

	Unconditional control statements: The control statement does not need any condition.

	NOTE: In Java goto is not present.

	- using the continue: It will keep the enclosing loop in the running condition without
			      considering the remaining body of loop.

class DemoContinue
{
	public static void main(String []args)
	{
		int i,j;

		for(i=0;i<10;i++)
		{
			System.out.print("-");
			for(j=0;j<10;j++)
			{
				if(j>i)
				{
					continue;
				}
				System.out.print("*");
			}
			System.out.println();
		}
	}
}

//-----------------------------------------------------------------------

			  
		// Using Labelled Continue: It will keep loop in running condition, not only
					   enclosing, but outer loops using label(tag)

class DemoLabelledContinue
{
	public static void main(String []args)
	{
		int i,j;

		outer:for(i=0;i<10;i++)
		{			
			System.out.print("-");
			for(j=0;j<10;j++)
			{
				if(i>5)
				{
					continue outer;
				}
				if(j>i)
				{
					continue;
				}
				System.out.print("*");
			}
			System.out.println();
		}
	}
}		


//-----------------------------------------------------------------------

// Using the break ans labelled break


class DemoBreak
{
	public static void main(String []args)
	{
		int i,j;

		for(i=0;i<10;i++)
		{
			System.out.print("-");
			for(j=0;j<10;j++)
			{
				if(j>i)
				{
					break;
				}
				System.out.print(""+j);
			}
			System.out.println();
		}
	}
}

//----------------------------------------------------------------------------------------------

class DemoLabelledBreak
{
	public static void main(String []args)
	{
		int i,j;

		outer:for(i=0;i<10;i++)
		{
			System.out.print("-");
			for(j=0;j<10;j++)
			{
				if(i>5)
				{
					break outer;
				}
				if(j>i)
				{
					break;
				}
				System.out.print(""+j);
			}
			System.out.println();
		}
	}
}	


//---------------------------------------------------------------------------------------

	// Using return: pass back the value from called method to calling function method.

//===============================================================================================
//===============================================================================================
//===============================================================================================
//===============================================================================================

	// Array in Java

	It is ordered collection of indexed elements having same data type which are
	conti. arranged in the memory.

	Decl. Syntax:
	
		<data_type> <arr_nm>[];		<data_type> []<arr_nm>;	

		e.g.
		int ar[];			int []ar;

	* Note 
		- In this decl, <element_count> is absent.
		- Above decl. creates the reference only.(same as pointer variable in C)

		In above both cases,

		ar
		 [  ]


	To allocate the memnory we need to use new keyword as..

		- Syntax
			<data_type> []<arr_nm> = new <data_type>[<size>];

			e.g.
				int []ar = new int[5];

			ar
			[   ] ----------------> [] [] [] [] []

	* Note that, Here in java array gains the dynamic memory space(like pointer in C), and
	  new keyword used to allocate the memory for it.

	// Init of array in java

	It is simple and same as we have seen in the C-C++, except [] does not contains the SIZE.

	e.g.
		int []x = {12,45,83,42,39};

		x            0    1    2    3    4 
		[ ] ------> [12] [45] [83] [42] [39]

	// WAP to init and display the array.

class InitArray
{
	public static void main(String []args)
	{
		int []x = {12,45,83,42,39,78};

		System.out.println("\n1. Array elements are: ");
		for(int i=0 ; i<6 ; i++)
		{
			System.out.print("   "+x[i]);
		}

		System.out.println("\n2. Array elements are: ");
		for(int i=0 ; i<x.length ; i++)
		{
			System.out.print("   "+x[i]);
		}

		// using for-each loop
		System.out.println("\n3. Array elements are: ");
		for(int val : x)
		{
			System.out.print("   "+val);
		}
	}
}

//-----------------------------------------------------------------------------------

	Array input and display - using BufferedReader and InputStreamReader

import java.io.*;
class ArrayIOBI
{
	public static void main(String []args) throws Exception
	{
		int []ar = new int[5];

		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

		System.out.println("\n Enter array: ");
		for(int i=0 ; i<5 ; i++)
		{
			ar[i]=Integer.parseInt(br.readLine());
		}

		System.out.println("\n1. Array elements are: ");
		for(int i=0 ; i<ar.length ; i++)
		{
			System.out.print("   "+ar[i]);
		}
	}
}

//-----------------------------------------------------------------------------------

	Array input and display - using Scanner

import java.util.Scanner;
class ArrayIOSI
{
	public static void main(String []args) 
	{
		int []ar = new int[5];

		Scanner sc = new Scanner(System.in);

		System.out.println("\n Enter array: ");
		for(int i=0 ; i<5 ; i++)
		{
			ar[i]=sc.nextInt();
		}

		System.out.println("\n1. Array elements are: ");
		for(int i=0 ; i<ar.length ; i++)
		{
			System.out.print("   "+ar[i]);
		}
	}
}

//-----------------------------------------------------------------------------------

	Array input and display - using Commandline arguments

import java.util.Scanner;
class ArrayIOSI
{
	public static void main(String []args) 
	{
		int []ar = new int[5];

		Scanner sc = new Scanner(System.in);

		System.out.println("\n Enter array: ");
		for(int i=0 ; i<5 ; i++)
		{
			ar[i]=sc.nextInt();
		}

		System.out.println("\n1. Array elements are: ");
		for(int i=0 ; i<ar.length ; i++)
		{
			System.out.print("   "+ar[i]);
		}
	}
}

//-----------------------------------------------------------------------------------

	Array input and display - showInputDialog()

import javax.swing.JOptionPane;
class ArrayIOSIDialog
{
	public static void main(String []args) 
	{
		String data = JOptionPane.showInputDialog("Enter the Space seperated array of integers");
		System.out.println("Entered string: "+data);

		String []nums = data.split(" ");
		int []ar = new int[nums.length];		

		System.out.println("\n Enter array: ");
		for(int i=0 ; i<nums.length ; i++)
		{
			ar[i]=Integer.parseInt(nums[i]);
		}

		System.out.println("\n1. Array elements are: ");
		for(int x : ar)
		{
			System.out.print("    "+x);
		}
	}
}

//-----------------------------------------------------------------------------------------------------------

	// Dynamic Memory Allocation ( Using java array as a pointer)

import java.util.Scanner;
class DynamicAllocation
{
	public static void main(String []args)
	{
		Scanner sc = new Scanner(System.in);

		System.out.println("\n Enter the Element count: ");
		int cnt=sc.nextInt();
		int []a = new int[cnt];

		System.out.println("Enter the "+cnt+" Elements: ");
		for(int i=0;i<cnt;i++)
		{
			a[i]=sc.nextInt();
		}

		System.out.println("Elements: ");
		for(int t : a)
		{			
			System.out.println("  "+t);
		}
	}
}

//---------------------------------------------------------------------------------------------
	
	// Some Array Operations

	 - search
	 - sort
	 - sortrange
	 - insert
	 - delete
	 - reverse
	 - copy
	 - copyrange
	 - Reverse Copy
	 - merge
	 - split
	 - concate
	 - compare
	 - fill
	 - fillrange

//---------------------------------------------------------------------------------------------
	
	// Characher Array in Java:

		decl. syntax:
		
			char []<ar_nm>;
			e.g.
				char []ch;	// creates reference only
				char []ch={'H','e','l','l','o'}; // initialization of character array

	Note that in java input is not inform of characters, it is in form of String. so no any
	special way is there to input the character array. The class String used to represent the
	character concation in its equivalent object form, having one method names toCharArray(),
	used to convert string into character array.

	here character array and String are different

	
import java.util.*;
class DemoCharArray
{
	public static void main(String []args)
	{
		char []ch;	// creates reference only
		char []ch1={'H','e','l','l','o'}; // init of character array

		Scanner sc = new Scanner(System.in);

		System.out.print("\n Enter the any string: ");
		String str=sc.nextLine();
		
		System.out.println("Entered String: "+str);

		ch=str.toCharArray();
		System.out.println("Converted String: ");

		for(char t : ch)
		{
			System.out.print(" "+t);
		}
	}
}
o/p:
 Enter the any string: hello
 Entered String: hello
 Converted String:
 h e l l o


*What is difference between character array and String?

 -- Character Array
1. A collection of characters stored as an array.
2. Mutable: You can modify the contents of a character array (e.g., change a character at a specific index).
3. Takes less memory as it only stores characters.
4. Directly modify the array's elements (e.g., charArray[0] = 'A';).
5. Can be converted to a String using new String(charArray).

-- String Array
1. A sequence of characters represented as an object of the String class.
2. Immutable: Once created, a String cannot be changed. Any modification creates a new String object.
3. Takes more memory because it stores additional metadata (e.g., length, hashcode).
4. Modifications create a new String object, not affecting the original.
5. Can be converted to a character array using toCharArray().


-- Example of a Character Array:
   
public class CharArrayExample
 {
    public static void main(String[] args)
 {
        char[] charArray = { 'H', 'e', 'l', 'l', 'o' };

        // Access and modify character array
        charArray[0] = 'h';

        System.out.println("Modified char array: ");

        for (char c : charArray) 
        {
            System.out.print(c);
        }
    }
}

o/p: Modified char array: hello



-- Example of a String Array:

public class StringExample {
    public static void main(String[] args) {
        String str = "Hello";

        // Strings are immutable; concatenation creates a new object
        String newStr = str.replace('H', 'h');
        System.out.println("Original String: " + str);
        System.out.println("Modified String: " + newStr);
    }
}

o/p:
Original String: Hello
Modified String: hello

//--------------------------------------------------------------------------------------------------------

	Multi-dimentional Array: Collection of references to another arrays.

	<data_type> [][]<ar_ name>;	-->	int [][]ar;

						  ar
						   [ ]

	memory allocation:
						
	<data_type> [][]<ar_ name> = new <data_type>[rows][cols] ;

	case 1:	int [][]ar;

			ar
			[  ]

		
	case 2:	int [][]ar = new int[3][];

			ar
			[  ] -------->  [ ]
					[ ]
					[ ]


		
	case 3:	int [][]ar = new int[3][4];    == [3 rows][4 cols]

			ar								ar
			[  ] -------->  [ ]------>[][][][]				[  ] ----> [][][][]
					[ ]------>[][][][]     Simply it is refered as 		   [][][][]
					[ ]------>[][][][]					   [][][][] 
							       ans can be accessed as ar[i][j]	

	// init. of 2D Array:

class Init2dArray
{
	public static void main(String []args)
	{
		int [][]ar = { {12,34,45,56}, {11,22,33,44}, {10,20,30,40} };

		System.out.println("Array elements are");
		for(int i=0;i<3;i++)
		{
			for(int j=0;j<4;j++)
			{
				System.out.print("  "+ar[i][j]);
			}
			System.out.println();
		}
		System.out.println("\n Array elements are");
		for(int i=0;i<ar.length;i++)
		{
			for(int j=0;j<ar[i].length;j++)
			{
				System.out.print("  "+ar[i][j]);
			}
			System.out.println();
		}
	}
}
//----------------------------------------------------------------------------------------
	// input and display 2D Array of 3x4

import java.util.Scanner;
class Init2dArray
{
	public static void main(String []args)
	{
		int [][]ar = new int[3][4];
		Scanner sc = new Scanner(System.in);
		System.out.println("Enter the Array elements");
		for(int i=0;i<3;i++)
		{
			for(int j=0;j<4;j++)
			{
				ar[i][j] = sc.nextInt();
			}
		}
		System.out.println("\n Array elements are");
		for(int i=0;i<ar.length;i++)
		{
			for(int j=0;j<ar[i].length;j++)
			{
				System.out.print("  "+ar[i][j]);
			}
			System.out.println();
		}
	}
}

///--------------------------------------------------------------------------------------

	// WAP to perform matrix multi.

import java.util.Scanner;
class Array2DMulti
{
	public static void main(String []args)
	{
		Scanner sc=new Scanner(System.in);
		int [][]x=new int[3][3];
		int [][]y=new int[3][3];
		int [][]z=new int[3][3];
		int i,j,k;

		System.out.println("Enter array of 3x3: \n");
		for(i=0;i<3;i++)
		{
			for(j=0;j<3;j++)
			{
				x[i][j]=sc.nextInt();
			}
			System.out.println();
		}

		System.out.println("Enter another array of 3x3: \n");
		for(i=0;i<3;i++)
		{
			for(j=0;j<3;j++)
			{
				y[i][j]=sc.nextInt();
			}
			System.out.println();
		}

		// multi.
		for(i=0;i<x.length;i++)
		{
			for(j=0;j<x[i].length;j++)
			{
				z[i][j]=0;
				for(k=0;k<x[i].length;k++)
				{
					z[i][j]=z[i][j]+(x[i][k]*y[k][j]);
				}
			}
		}
		
		System.out.println("\n Array elements are: \n");
		for(i=0;i<x.length;i++)
		{
			for(j=0;j<x[i].length;j++)
			{
				System.out.print("  "+x[i][j]);
			}
			System.out.print("\t");
			for(j=0;j<y[i].length;j++)
			{
				System.out.print("  "+y[i][j]);
			}
			System.out.print("\t");
			for(j=0;j<z[i].length;j++)
			{
				System.out.print("  "+z[i][j]);
			}
			System.out.println();
		}
	}
}
///-----------------------------------------------------------------------------------------

 // Different operations of matrix:

	- Tranpose
	- unit matrix
	- upper triangular
	- lower triangular
	- diagonal
	
///-----------------------------------------------------------------------------------------

	// Variable size Array or Jagged Array

	suppose, you decl. an array as,

		int [][]x=new int[3][];

	then see the memory map is as shown below,

		x
		[ ] --------->  [ ]
				[ ]
				[ ]
			  These all 3 are the references, which will able to refer
			  dynamically created location of correct type, having any SIZE. 

	Means to store data, we need to allocate memory for each location. So we need to
	write it as,
	
		x[0]=new int[5];
		x[1]=new int[7];
		x[2]=new int[4];

		x
		[ ] --------->  [ ] -------> [][][][][]
				[ ] -------> [][][][][][][]
				[ ] -------> [][][][]

	So Note that, In Jagged array(variable size array) size(length) of every row
	may be different.

Unlike a regular two-dimensional array, a jagged array allows rows to have varying sizes, making it more memory-efficient for certain applications.

** Characteristics of Jagged Arrays:

1. Flexible Row Sizes:
   Each row can have a different number of columns.

2. Memory Efficiency:
   Saves memory when the number of columns varies significantly between rows.

3. Declaration and Initialization:
   Declared as a two-dimensional array but initialized row by row.


	We have to create a 2D array to store runs of N player scored in M matches. where
	M may be different for each player.

import java.util.Scanner;
class DemoJagged
{
	public static void main(String []args)
	{
		Scanner sc=new Scanner(System.in);
		System.out.println("\n Enter the player count: ");
		int pcnt = sc.nextInt();
		int [][]data = new int[pcnt][];

		System.out.println("\n Enter the details of "+pcnt+" Players");
		for(int i=0;i<data.length;i++)
		{
			System.out.println("\n Enter the march count of player "+(i+1)+": ");
			int mcnt=sc.nextInt();
			data[i] = new int[mcnt];
			System.out.println("\n Enter the runs scored by player: ");
			for(int j=0;j<data[i].length;j++)
			{
				System.out.println("\n Match "+(j+1)+": ");
				data[i][j]=sc.nextInt();
			}
		}

		System.out.println("\n Score Board");

		int i=1;
		for(int []p : data)
		{
			System.out.print("\n Player "+(i++)+": ");
			for(int r : p)
			{
				System.out.print("  "+r);
			}
			System.out.println();
		}
	}
}



Questions on array:

 3. What is the default value of array elements in Java?
Default values depend on the data type:


Data Type	Default Value
int	            0
double         	   0.0
boolean	           false
char	          '\u0000'
Object	           null

2. What is an array in Java? How is it different from an ArrayList?
     Arrays are fixed-size, and can store both primitives and objects.
        ArrayLists are dynamic in size and can only store objects.

3. Can we change the size of an array once it is created?
   Answer: No, arrays are fixed in size. To resize, you need to create a new array and copy elements.

4. What is a multi-dimensional array? How is it different from a jagged array?
     A multi-dimensional array has rows and columns of the same size, 
    whereas jagged arrays allow rows of different sizes.

5. What is the difference between a shallow copy and a deep copy of an array?

   -Shallow Copy: Copies references for objects. Changes made to the objects in the shallow copy will affect the objects in the original array 
    (because they share the same references).
   -Suitable for immutable or read-only objects.

    Deep Copy: Copies actual objects by creating new instances.Changes made to the objects in the deep copy will not affect the objects 
    in the original array (because they are entirely separate).
   - Suitable for mutable objects needing independence.

6. What is the difference between length and length() in arrays?
    length is a property for arrays, while length() is a method for String.

1. What are the limitations of arrays in Java?
        Fixed Size: Once you define the size of an array, it cannot be changed dynamically.
        Same Data Type: Arrays can only store elements of the same data type.
        No Built-in Methods: Java arrays don’t provide built-in methods like add(), remove() (unlike ArrayList).
       Memory Waste: If the array size is overestimated, unused memory is wasted.
       Insertion/Deletion Overhead: Inserting or deleting elements in between is inefficient (you need to shift elements manually).



🔹 4. Is it possible to make an array of objects in Java? If yes, give an example.
✅ Yes! You can absolutely create an array of objects.

class Student {
    String name;
    int age;

    Student(String n, int a) {
        name = n;
        age = a;
    }
}

public class ObjectArrayExample {
    public static void main(String[] args) {
        Student[] students = new Student[3]; // Array of Student objects

        students[0] = new Student("Alice", 20);
        students[1] = new Student("Bob", 22);
        students[2] = new Student("Charlie", 19);

        for (Student s : students) {
            System.out.println(s.name + " - " + s.age);
        }
    }
}

 6. Can we store null in an array?
✅ Yes, if the array type is an object type, you can store null.
String[] arr = new String[3];
arr[0] = "Hello";
arr[1] = null; // valid
arr[2] = "World";
But in primitive type arrays (like int[]), you can’t assign null to elements, only to the entire array reference:
int[] arr = null; // valid
arr[0] = null;    // ❌ Error

 3. How are arrays stored in memory in Java? Heap or Stack?
     - Arrays are objects in Java, so they are stored in the heap memory.
     - If you declare an array inside a method:
     - The reference is on the stack.
     - The actual array data is in the heap.


🔹 7. Difference between length, length(), and size() in Java?

Term	     Usage	                       Applies To
length	    No parentheses	               Arrays (arr.length)
length()    With parentheses (a method)	       Strings (str.length())
size()	    With parentheses (a method)	       Collections (list.size())


//-----------------------------------------------------------------------------------------------------------

	// POINTER - EXPLICIT POINTER IS NOT PRESENT IN JAVA, COZ ITS NEED ALREADY FULLFILLED BY ARRAY.
		     BUT AS OBJECT GAINS THE DYNAMIC MEMORY SPACE, IMPLICITELY IT IS HANDLED BY POINTER.
		     SO IT IS NOT PRESENT FOR AS A PROGRAMMER.


		- Why pointer is not present in java?

1. Security Concerns:
     Pointers allow direct memory access and manipulation, which can lead to issues like memory corruption, 
     unauthorized access to memory locations, and vulnerabilities (e.g., buffer overflows).
     By disallowing pointers, Java ensures that programs cannot access memory directly, reducing the risk of accidental or malicious tampering.

   - Although Java does not support pointers explicitly, it uses references to access objects in memory


2. Simplicity and Ease of Use:
       Java aims to be beginner-friendly and easy to learn. Managing pointers involves complex tasks like memory allocation,
      deallocation, and pointer arithmetic, which can be error-prone.
      By removing pointers, Java simplifies programming and reduces the cognitive load on developers.

3. Automatic Memory Management (Garbage Collection):
        Java uses automatic garbage collection to manage memory. If pointers were allowed, it would complicate garbage collection 
       as objects could be referenced or manipulated directly through pointers, making it difficult for the garbage collector 
       to track and clean up unused memory safely.

4. Prevention of Common Programming Errors:
       Pointers can lead to issues like:
       Dangling pointers (accessing memory of deleted objects).
       Memory leaks (failure to deallocate memory properly).
       Null pointer dereferencing (though Java still has NullPointerException for null references).
       By avoiding pointers, Java eliminates many of these low-level programming errors.



//===================================================================================================================

	// OOPs in Java

	What we have seen in C++,

	- Fundamentals - class, Object, Data Hiding, Encapsulation, Abstraction,inheritance,ploymorphism
	- Methods - Method Overloading, and Overriding
	- Static members (static variables, and static methods)
	- constructors and destructors
	- Inheritance: single, multi-level, Multiple, Hierarchical, Hybrid, virtual base class
	- Polymorphism - virtual function, pure virtual function, abstract class.
	- Operator Overloading


	// Fundamentals of Object Oriented Programming:

	  1. class: It is user defined data type, which allows you to define a type using data member(instance
		   variables) and member functions(Methods). It is just blueprint, which divides the members
		   in the private, protected, public and default(No keyword) visibility modifiers.

          - A class is a blueprint or template for creating objects. It defines the properties (fields) and behaviors (methods) 
            that the objects created from the class will have.

		Syntax:
			class <class_name>
			{
				<visibility> <data_type> <var_nm>;
				<visibility> <return_type> <method_nm>();
				.......
			}

		e.g.
			class Demo
			{
				private int x;
				private double y;
				float z;
				public void input() {......}
				public void display() {......}
			}

		*Note: Remember that, visibility modifier must be used as a type qualifier for each member,
		       Absence of any keyword it will be considered as default.	and unlike C++, class does not 
		       ends with ;

	The visibility of class members in Java:	
	
	 - private:   member is only accessible within the same class.
	 - protected: member is accessible within its own package and by subclasses form same of different packages / folders
	 - public: member is accessible from any class, both inside and outside the package.
	 - default / Package-Private (no modifier)class member is accessible only within its own package.

	
	2. Object: It is variable of class type or we can define it as it is standard implementation of class.
		or can be defined as, It is runtime entity - which encapsulates the data and code used to
		process that data.

         - An object is an instance of a class. When a class is defined, no memory is allocated until an object of
             that class is created using the new keyword.

		Syntax:
			<class_nm> <object_nm> = new <class_constructor>();

	*Note that, C++ style decl. creates the REFERENCE VARIABLE only(like a pointer variable).

	 i.e.
		Demo ob;		ob
					 [  ]

		Demo ob = new Demo();	
		
		 ob
		 [  ] -------> [ Memory allocated for object ] 


	** There is one unwritten rule, which recommended for programmers and it is followed in
	   java internally while designing the library.

		- Method Names Should Be Verb-Phrase that describes what the method does.
		- Method names should start with a lowercase letter, and each subsequent word should start 
		  with an uppercase letter. This is called lower camel case.
		  e.g.
			calculateTotal(), sendEmail(), getUserDetails(), setAccountBalance()

		- Constants are typically written in uppercase letters with words separated by underscores (_), 
		  a style known as screaming snake case.
		  e.g.
			MAX_WIDTH, PI, DEFAULT_TIMEOUT

		- Class names should follow Upper Camel Case (also called Pascal Case), where the first letter 
		  of each word is capitalized and there are no spaces or underscores.
		  e.g.
			Person, EmployeeDetails, AccountManager

------------------------------------------------

✅ 2. What are the Four Main Principles of OOP?
These are often referred to as Pillars of OOP:

Principle	Description
Encapsulation	Wrapping data and code together into a single unit (class), and controlling access using access modifiers.
Inheritance	One class (child) inherits the properties and behaviors (methods) of another class (parent). Promotes code reuse.
Polymorphism	One interface, many implementations. The ability of an object to take many forms (method overloading/overriding).
Abstraction	Hiding complex implementation details and showing only the necessary features (using abstract classes/interfaces).
			
------------------------------------------------

	3. data hiding: The private data of class is not accessible directly using the dot
			operator, means that data is get hided from outside world, which is
			known as data hiding.  
		    -The Data Hiding provides the security to data.

        
 **** Data Hiding in Java

     -  Data hiding is one of the core principles of Object-Oriented Programming (OOP), which focuses on restricting access 
        to certain details of an object and ensuring that sensitive data is protected from unauthorized access. 
     - This is achieved in Java by using access modifiers (such as private) and providing controlled access through getter and setter methods.
     - Using getter and setter methods allows controlled read and write access to the private fields.

 e.g. = Banking Systems:
Hiding sensitive details like account numbers, balances, and PIN codes, while providing controlled access for transactions.

------------------------------------------------

	4. Encapsulation: Wrapping up of data members and member functions together under
			  single unit is known as encapsulation. 
			- Here in class the data member and member functions are encapsulated together.

   *** Encapsulation
        -  is one of the core principles of Object-Oriented Programming (OOP). It refers to binding data (fields/variables) 
           and methods (functions) together within a single unit (class) and restricting direct access to the data by
           using access modifiers like private.
        - Encapsulation ensures controlled access to the data through getter and setter methods.

✅ How Does Java Achieve Encapsulation?
Java achieves encapsulation using the following techniques:

🔸 1. Private Data Members
Declare variables private so they cannot be accessed directly from outside the class.

🔸 2. Public Getter and Setter Methods
Provide public methods (get and set) to read and modify the values of private variables safely.

------------------------------------------------
				
	5. Abstraction: - Hiding implementation details

                        In simple words "Without knowing too much about it"
			It is an art of defining the new type(class) without including its background details.

			here in case of class and object, we don't think about the amount of
			memory as well as its representation in the memory(memory map), means
			we are abstract about it.

			The data types which supports abstraction known as Abstract Data Types (ADT)

✅ Real-Life Analogy
Think of driving a car:
You use the steering, accelerator, and brakes.
But you don’t know or need to know how the engine or braking system works internally.

That’s abstraction — showing only the functionality, hiding the complexity.


✅ How is Abstraction Achieved in Java?
Java provides two main ways to achieve abstraction:

🔹 1. Abstract Classes
          - Declared using the abstract keyword.
          - Can have both abstract methods (no body) and concrete methods (with body).
          - Cannot be instantiated (no objects directly).

 2. Interfaces
          - Completely abstract (before Java 8).
          - All methods are implicitly public abstract (by default).
          - From Java 8 onwards, you can also have default and static methods with implementation.

----------------------------

✅ 2. What is Cohesion in OOP?
Cohesion means how closely related the functions in a class are.
🎯 High Cohesion: Class has a single, focused purpose (Good design)
❌ Low Cohesion: Class has unrelated responsibilities (Bad design)

Example:
✅ Student class that only handles student data – High Cohesion
❌ Student class that also sends emails and manages inventory – Low Cohesion
High cohesion = more readable, maintainable, and reusable code.

-----------------------

✅ 3. What is Coupling in OOP?
Coupling refers to how much one class is dependent on another.

🔗 Tight Coupling: Classes are highly dependent on each other (hard to change)
🧩 Loose Coupling: Classes are independent or depend on abstractions (better design)

Example:
Tight coupling: A directly calls methods of B with full knowledge of how B works.
Loose coupling: A calls methods via an interface, not caring how B is implemented.
Loose coupling = better flexibility and easier maintenance.

----------------

✅ 4. What is Object Cloning in Java?
        - Object Cloning means creating an exact copy of an object with the same data.
        - Java provides the .clone() method (from Object class) to do this.

o clone an object:
Implement Cloneable interface
Override clone() method


//---------------------------------------------------------------------------------------------------------------------


	ob
	 [  ] -------> [------------------]

class Demo
{
	private int x;
	public void in(){
		x=100;
	}
	public void out(){
		System.out.println("x="+x);
	}
}
class MainClass
{
	public static void main(String []args)
	{
		Demo ob = new Demo();

		ob.in();
		ob.out();
	}
}

//-------------------------------------------------------------------------

import java.util.Scanner;
class Person
{
	private String name;
	private int age;
	private double hig;
	public void setPersonDetails()
	{
		Scanner sc=new Scanner(System.in);

		System.out.println("Enter the name: ");
		name=sc.nextLine();

		System.out.println("Enter the age: ");
		age=sc.nextInt();

		System.out.println("Enter the height: ");
		hig=sc.nextDouble();
	}
	public void showPersonDetails()
	{
		System.out.println("Name: "+name+"\t Age: "+age+"\t Height: "+hig);
	}	
}

class MainClassExample
{
	public static void main(String []args)
	{
		Person p1 = new Person();
		p1.setPersonDetails();
		p1.showPersonDetails();

		Person p2 = new Person();
		p2.setPersonDetails();
		p2.showPersonDetails();
	}
}


//------------------------------------------------------------------------------
	
	// We can write same program as

import java.util.Scanner;
class Person
{
	private String name;
	private int age;
	private double hig;
	public void setPersonDetails(String nm, int ag, double h)
	{
		name=nm;
		age=ag;
		hig=h;
	}
	public void showPersonDetails()
	{
		System.out.println("Name: "+name+"\t Age: "+age+"\t Height: "+hig);
	}	
}

class MainClassExample1
{
	public static void main(String []args)
	{

		Scanner sc=new Scanner(System.in);

		System.out.println("Enter the name: ");
		String name=sc.nextLine();
		System.out.println("Enter the age: ");
		int age=sc.nextInt();
		System.out.println("Enter the height: ");
		double hig=sc.nextDouble();

		Person p1 = new Person();
		p1.setPersonDetails(name, age, hig);
		
		System.out.println("Enter the name: ");
		name=sc.nextLine();
		System.out.println("Enter the age: ");
		age=sc.nextInt();
		System.out.println("Enter the height: ");
		hig=sc.nextDouble();

		Person p2 = new Person();
		p2.setPersonDetails(name, age, hig);


		p1.showPersonDetails();
		p2.showPersonDetails();
	}
}

//-----------------------------------------------------------------------------------------

	// Again can be written as

import java.util.Scanner;
class Person
{
	private String name;
	private int age;
	private double hig;
	public void setPersonDetails()
	{
		Scanner sc=new Scanner(System.in);

		System.out.println("Enter the name: ");
		name=sc.nextLine();

		System.out.println("Enter the age: ");
		age=sc.nextInt();

		System.out.println("Enter the height: ");
		hig=sc.nextDouble();
	}
	public String getName()
	{
		return name;
	}
	public int getAge()
	{
		return age;
	}	
	public double getHeight()
	{
		return hig;
	}
}

class MainClassExample3
{
	public static void main(String []args)
	{
		Person p1=new Person();
		p1.setPersonDetails();

		Person p2=new Person();
		p2.setPersonDetails();

		System.out.println("Name: "+p1.getName()+"\t Age: "+p1.getAge()+"\t Height: "+p1.getHeight());
		System.out.println("Name: "+p2.getName()+"\t Age: "+p2.getAge()+"\t Height: "+p2.getHeight());
	}
}

//-----------------------------------------------------------------------------------------------------------

	// Write a class Number to hold one int value and arrange some methods to process that int value.

import java.util.Scanner;
class Number
{
	private int no;
	public void setNumber(int n) 
	{
		no=n;
	}
	public int getNumber()
	{
		return no;
	}
	public int findReverse()
	{
		int n=no;

		int rev=0;
		while(n!=0)
		{
			rev = (rev*10) + (n%10);
			n = n/10;
		}
		return rev;
	}
	public char isPalindrome()
	{
		if(no==findReverse())
			return 'y';
		else
			return 'n';
	}
	public String isEvenOrOdd()
	{
		if(no%2==0)
			return "even";
		else
			return "odd";
	}
	public void isPrime()
	{	
		int d=2,flg=0;
		while(d<=(no/2))
		{
			if(no%d==0)
			{
				flg=1;
				break;
			}
			d++;
		}
		if(flg==0)
			System.out.println("Number is Prime");
		else
			System.out.println("Number is not Prime");
	}
	public int findMax(int h)
	{
		int ans = (no>h) ? no : h;
		return ans;
	}
}

class DemoNumber
{
	public static void main(String []args)
	{
		Number nob = new Number();

		Scanner sc=new Scanner(System.in);
		System.out.println("Enter the Number: ");
		int t=sc.nextInt();

		nob.setNumber(t);

		System.out.println("\n Number is: "+nob.getNumber());

		int r = nob.findReverse();
		System.out.println("\n Reverse Number is: "+r);

		char ans=nob.isPalindrome();
		if(ans=='y')
			System.out.println("\n Number is Palindrome");
		else
			System.out.println("\n Number is Not Palindrome");

		System.out.println("\n Number is: "+nob.isEvenOrOdd());

		nob.isPrime();

		System.out.println("Enter the Number: ");
		int k=sc.nextInt();

		int max=nob.findMax(k);
		System.out.println("max Number: "+max);
	}
}

//------------------------------------------------------------------------------------------------------------		

	// Write a program to represent an array as a object and perform some operations on that array object.

import java.util.Scanner;
class MyArray
{
	private int []x;
	public void fill(int t)
	{
		x=new int[5];
		for(int i=0;i<x.length;i++)
		{
			x[i]=t;
		}
	}
	public void in()
	{
		Scanner sc = new Scanner(System.in);
		System.out.print("\n Enter element count: ");
		int k=sc.nextInt();
		x=new int[k];
		 
		System.out.print("Enter the "+k+" Elements: ");
		for(int i=0;i<k;i++)
		{
			x[i] = sc.nextInt();
		}
	}
	public void out()
	{
		System.out.print("\n Elements are: ");
		for(int val : x)
		{
			System.out.print("   "+val);
		}
	}
	public int search(int t)
	{
		for(int i=0;i<x.length;i++)
		{
			if(x[i]==t)
				return i;
		}
		return -1;
	}
}
class MyArrayExample
{
	public static void main(String[] args) 
	{
		MyArray ob = new MyArray();
		ob.fill(3);
		ob.out();

		ob.in();
		ob.out();

		Scanner sc = new Scanner(System.in);
		System.out.println("\n Enter the element to be searched: ");
		int n=sc.nextInt();
		int pos = ob.search(n);
		if(pos==-1)
			System.out.println("\n Number is not present in an array");
		else
			System.out.println("\n Number is present at "+pos+" position");
	}
}

//--------------------------------------------------------------------------------------

	// Create the class employee and just input and display the employee data.

import java.io.BufferedReader;
import java.io.InputStreamReader;
class Employee
{
	private int id;
	private String name;
	private double sal;
	public void inputInformation() throws Exception
	{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

		System.out.println("Enter the Name: ");
		name=br.readLine();
		
		System.out.println("Enter the id: ");
		id=Integer.parseInt(br.readLine());

		System.out.println("Enter the salary: ");
		sal=Double.parseDouble(br.readLine());
	}
	public void showInformation()
	{
		System.out.println("Employee Name: "+name+"\t ID: "+id+"\t Salary: "+sal);
	}	
}

class MainClassEmployee
{
	public static void main(String []args) throws Exception
	{
		Employee e1=new Employee();

		e1.inputInformation();
		e1.showInformation();
	}
}

//-----------------------------------------------------------------------------------------------------------

	// Creating Anonymous Object:

	Anonymous Object is an instance of class which can not be referred by any reference variable 
	when it is created. we are able to call the methods from same instance only once at the time
	of decl.
	It's often used for situations where you only need an object temporarily, without the need to store 
	or reuse it. You cannot refer to or modify the object later since it is not stored in a variable.

     1. No Reference Variable:
         The object is created and used directly without storing its reference.

    2. Single Use:
         It is generally used when the object is needed only once.

    3.Memory Efficiency:
         Since the object is not referenced, it becomes eligible for garbage collection immediately after use.

    4. Common Use Case:
         Typically used for calling methods or constructors on the fly.

class DemoObj
{
	public void show()
	{
		System.out.println("\n In the DemoObj-show()");
	}
}

class MainDemoObj
{
	public static void main(String []args)
	{
		// Creating Anonymous Object
		new DemoObj().show();
		new DemoObj().show();
	}
}

output:  

In the DemoObj-show()

 In the DemoObj-show()


//------------------------------------------------------------------------------------------------

	// Defining main() method in same class

class DemoMainSameClass
{
	private int x=1;
	private double y=2.2;
	public static void main(String []args)
	{
		System.out.println("\n main() started");
		
		System.out.println("\n x="+x);
		System.out.println("\n y="+y);

		System.out.println("\n main() end");
	}
}

---------- On Compile ---------------
Y:\jsmall>javac DemoMainSameClass.java
DemoMainSameClass.java:9: error: non-static variable x cannot be referenced from a static context
                System.out.println("\n x="+x);
                                           ^
DemoMainSameClass.java:10: error: non-static variable y cannot be referenced from a static context
                System.out.println("\n y="+y);
                                           ^


// Now i want to create multiple instances

	 Note that if you want to access the members of class where main() is defined then also you need to 
  	 create the object of same class and access the methods.
	 

class DemoMainSameClass
{
	private int x=1;
	private double y=2.2;
	public static void main(String []args)
	{
		System.out.println("\n main() started");
		
		DemoMainSameClass ob1 = new DemoMainSameClass();
		System.out.println("\n ob1.x="+ob1.x);
		System.out.println("\n ob1.y="+ob1.y);
		
		DemoMainSameClass ob2 = new DemoMainSameClass();
		System.out.println("\n ob2.x="+ob2.x);
		System.out.println("\n ob2.y="+ob2.y);

		System.out.println("\n main() end");
	}
}


// another ways is decl those variables as static

class DemoMainSameClass
{
	private static int x=1;
	private static double y=2.2;
	public static void main(String []args)
	{
		System.out.println("\n main() started");
		
		System.out.println("\n x="+x);
		System.out.println("\n y="+y);

		System.out.println("\n main() end");
	}
}

//-----------------------------------------------------------------------------

	// Defining methods within main() class

class DemoMainMethod
{
	public void sampleMethod()
	{
		System.out.println("\n In sampleMethod()");
	}
	public static void main(String []args)
	{
		System.out.println("\n main() starts");
		sampleMethod();
		System.out.println("\n main() end");
	}
}

 ------------- On Compile -----------------

Y:\jsmall>javac DemoMainMethod.java
DemoMainMethod.java:10: error: non-static method sampleMethod() cannot be referenced from a static context
                sampleMethod();
                ^
1 error

	Solution: 
	- Decl. sampleMethod() method as static	OR
	- Create an object of class DemoMainMethod and call sampleMethod()


//---------------------------------------------------------------------------------------------------

	// WAP to input and display the data of two students

import java.util.Scanner;
class Student
{
	private int id;
	private double per;

	public void in()
	{
		Scanner sc=new Scanner(System.in);
		System.out.println("Enter the student ID: ");
		id=sc.nextInt();

		System.out.println("Enter the Percentage: ");
		per=sc.nextDouble();
	}
	public void out()
	{
		System.out.println("\n Student ID: "+id+"\n Percentage: "+per);
	}
}
class DemoStudent
{
	public static void main(String []args)
	{
		Student s1=new Student();
		s1.in();
		s1.out();

		Student s2=new Student();
		s2.in();
		s2.out();
	}
}	

//--------------------------------------------------------------

	// Or can be passed from the main()

import java.util.Scanner;
class Student
{
	private int id;
	private double per;

	public void in(int t1, double t2)
	{
		id=t1;
		per=t2;
	}
	public void out()
	{
		System.out.println("\n Student ID: "+id+"\n Percentage: "+per);
	}
}
class DemoStudent
{
	public static void main(String []args)
	{
		Scanner sc=new Scanner(System.in);

		System.out.println("Enter the student ID: ");
		int sid=sc.nextInt();
		System.out.println("Enter the Percentage: ");
		double sper=sc.nextDouble();

		Student s1=new Student();
		s1.in(sid,sper);
		s1.out();

		//-----------------------------------------------

		System.out.println("Enter the student ID: ");
		sid=sc.nextInt();
		System.out.println("Enter the Percentage: ");
		sper=sc.nextDouble();

		Student s2=new Student();
		s2.in(sid,sper);
		s2.out();
	}
}	

//------------------------------------------------------------------------------------------------------

	// Method overloading with class

	Method overloading in Java allows you to define multiple methods with the same name but different parameter
	lists. It increases the flexibility, readability, and maintainability of your code. Just remember that
	overloading depends on differences in the method signatures (the method name and parameters), not the 
	return type, and visibility.

   1. Can constructor be overloaded in Java?
   Yes, constructors can be overloaded just like methods. A class can have more than one constructor with different parameter lists.


import java.util.Scanner;
class Student
{
	private int id;
	private double per;
	public void in()
	{
		Scanner sc=new Scanner(System.in);
		System.out.println("Enter the student ID: ");
		id=sc.nextInt();

		System.out.println("Enter the Percentage: ");
		per=sc.nextDouble();
	}
	public void in(int t1, double t2)
	{
		id=t1;
		per=t2;
	}
	public void out()
	{
		System.out.println("\n Student ID: "+id+"\n Percentage: "+per);
	}
}
class DemoStudent
{
	public static void main(String []args)
	{
		Scanner sc=new Scanner(System.in);
		
		Student s1=new Student();
		s1.in();
		s1.out();
		//-----------------------------------------------

		System.out.println("Enter the student ID: ");
		sid=sc.nextInt();
		System.out.println("Enter the Percentage: ");
		sper=sc.nextDouble();
		Student s2=new Student();
		s2.in(sid,sper);
		s2.out();
	}
}	


	In above program, there are two different copies of in() method i.e.

		public void in()
		public void in(int t1, double t2)

	as a class contains two copies of function having same name and differ in terms of
	signature, it is known as "Method Overloading"

//---------------------------------------------------------------------------------------------------------

	// Lets discuss the class by value and class by reference.

	- We know that, In C++, variable are passed by value by default. If you want to pass them
	  by reference then pointer is used.

class SwapDemo
{
	public static void swap(int a, int b)
	{
		int tmp;
		tmp=a;
		a=b;
		b=tmp;
	}
	public static void main(String[]args)
	{
		int x=10, y=20;
		System.out.println("\n Before Interchange x="+x+"\t y="+y);
		swap(x,y);
		System.out.println("\n After Interchange x="+x+"\t y="+y);
	}
}

 ----- Output -------
Y:\jsmall>javac SwapDemo.java
Y:\jsmall>java SwapDemo
 Before Interchange x=10   y=20
 After Interchange x=10  y=20

	Means java variables are passed by value bydefault. Then how to pass the byreference coz, in c++,
	pointer is used, here in java pointer is absent.

	solution is that, pass the values in form of object, coz object bydefault passesd by reference.
	for that,
	 - create custom class to reparent the int value in its equivalent object from. OR
	 - User wrapper classes.


	// Lets first confirm that, Object is bydefault passed by reference.

class Int
{
	private int data;
	public void setData(int data)
	{
		this.data=data;
	}
	public int getData()
	{
		return data;
	}
}
class ObjByRefConfirm
{
	public static void sample(Int t)
	{
		t.setData(t.getData()+100);
	}
	public static void main(String[]args)
	{
		int x=10;
		Int obx = new Int();
		obx.setData(x);

		System.out.println("Before - x="+obx.getData());
		sample(obx);
		System.out.println("After - x="+obx.getData());		
	}
}

 --- Output ----

Y:\jsmall>javac ObjByRefConfirm.java

Y:\jsmall>java ObjByRefConfirm
Before - x=10
After - x=110

	It is confirmation, that Object passed by reference.
//--------------------------------------------------------------------------------------------

	// Use same class for swapping (Using custom class) 

    -A custom class in Java is a user-defined class created by programmers to represent objects that encapsulate specific data and behavior.

class Int
{
	private int data;
	public void setData(int data)
	{
		this.data=data;
	}
	public int getData()
	{
		return data;
	}
	public String toString()
	{
		return ""+data;
	}
}
class SwapDemoUsingObj
{
	public static void swap(Int oba, Int obb)
	{
		int tmp;
		tmp=oba.getData();
		oba.setData(obb.getData());
		obb.setData(tmp);
	}
	public static void main(String[]args)
	{
		int x=10, y=20;

		Int obx = new Int();
		obx.setData(x);

		Int oby = new Int();
		oby.setData(y);

		System.out.println("\n Before Interchange x="+obx+"\t y="+oby);
		swap(obx,oby);
		System.out.println("\n After Interchange x="+obx+"\t y="+oby);
	}
}

 ----- output -----

 Before Interchange x=10         y=20

 After Interchange x=20  y=10
Press any key to continue . . .

//----------------------

	Another way to represent the data in its equivalent object from is to use Wrapper classes

     -Wrapper classes in Java are classes that provide a way to use primitive data types (e.g., int, float, char) as objects.
    Each primitive type has a corresponding wrapper class in the java.lang package.

class SwapDemoUsingObjUsingWrapper
{
	public static void swap(Integer  oba, Integer obb)
	{
		int tmp;
		tmp=oba;
		oba=obb;
		obb=tmp;
	}
	public static void main(String[]args)
	{
		int x=10, y=20;

		Integer obx = x;
		Integer oby = y;

		System.out.println("\n Before Interchange x="+obx+"\t y="+oby);
		swap(obx,oby);
		System.out.println("\n After Interchange x="+obx+"\t y="+oby);
	}
}


The output will not gives the swaped values coz Integer object is immutable. You need mutable object
or use the array. 

	The values of x and y are not swapping because:

	- Java passes object references by value.
	- The swap method only modifies the local copies of the references.
	- Integer objects are immutable, so their values cannot be changed directly.

	NOTE:
	- When you pass a primitive type (e.g., int, float, char) to a method, a copy of the value is 
	  passed. Changes made to the parameter inside the method do not affect the original variable.

	- When you pass an object to a method, a copy of the reference to the object is passed. This 
	  means that the method receives a reference to the same object, but the reference itself is a copy.
	
	- Changes made to the object through the reference inside the method will affect the original object. 
	  However, changes made to the reference itself (e.g., assigning it to a new object) will not affect 
	  the original reference.


	// Using the array to swap the value

public class SwapDemoUsingArray {
    public static void swap(int[] arr) {
        int tmp = arr[0];
        arr[0] = arr[1];
        arr[1] = tmp;
    }

    public static void main(String[] args) {
        int x = 10, y = 20;

        int[] arr = {x, y};

        System.out.println("\n Before Interchange x=" + arr[0] + "\t y=" + arr[1]);
        swap(arr);
        System.out.println("\n After Interchange x=" + arr[0] + "\t y=" + arr[1]);
    }
}


//------------------------------------

	What is a POJO Class in java?
	 - A POJO (Plain Old Java Object) is a simple object in Java that doesn't adhere to any special restriction 
	  other than those forced by the Java Language Specification and does not require any classpath. 
	  Here are the key points that define a POJO class:

	- No Implements: It does not implement any special interfaces such as Serializable, Externalizable, etc.
	- No Extends: It does not extend prespecified classes which may force it to behave in a certain way.
	- Simple Fields: Fields should be private to achieve encapsulation. Fields can be accessed directly 
	  via getters and setters.
	- Zero-arg Constructor: Often includes a no-argument constructor.

public class Person {
    private String name;
    private int age;

    public Person() {
    }

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "Employee{name='" + name + "', Age=" + age + "}";
    }
}

//-----------------------------------------------------------------------------------------------------

@Override is an annotation in Java that indicates a method in a subclass is overriding a method in its superclass. It is used to ensure that the method you intend to override is valid (i.e., it actually overrides a method in the superclass).

Key Features of @Override:

Compile-Time Check: If the method signature in the subclass does not match any method in the superclass, the compiler generates an error.

Improves Readability: Clearly shows that the method is intended to override a method in the parent class.

Prevents Errors: Avoids accidental overloading instead of overriding due to signature mismatches.


class Parent {
    public void display() {
        System.out.println("Display method in Parent class");
    }
}

class Child extends Parent {
    // Intentionally misspelled method name (mistake)
    public void displaay() {
        System.out.println("Display method in Child class");
    }
}

public class Main {
    public static void main(String[] args) {
        Child child = new Child();
        child.display(); // Calls Parent's display method because 'displaay' is not overriding
    }
}

o/p: Display method in Parent class
------------------------------------------------------------------------------


class Parent {
    public void display() {
        System.out.println("Display method in Parent class");
    }
}

class Child extends Parent {
    @Override
    public void displaay() {     // Error: No method with this name in Parent class
        System.out.println("Display method in Child class");
    }
}

public class Main {
    public static void main(String[] args) {
        Child child = new Child();
        child.display();
    }
}
o/p:Error: No method with this name in Parent class


//-----------------------------------------------------------------------------------------------------------

	// Constructors in Java Classes: 

	 A constructor in Java is a special method used to initialize objects when they are created. It has the same 
	 name as the class and does not have a return type (not even void). Constructors are automatically called when 
	 an object of the class is instantiated. You can define multiple constructors with different parameters 
	 (constructor overloading).

	Types of Constructors:
	  - Default Constructor (No-Argument Constructor):
	  - Parameterized Constructor:
	  - Copy Constructor (Not built-in like in C++):


	// Default Constructor (No-Argument Constructor): It is constructor without arguments. Can init.
	   instance variables using input or using literals. In absence of constructor in class, the default 
	   constructor with the empty body will be provided by the compiler itself. 

class Sample
{
	private int x;
	private double y;
	public Sample() // Default constructor
	{
		x=10;
		y=23.45;
		System.out.println("\n In default constructor of Sample class");
	}
	public void showData()
	{
		System.out.println("\n x="+x+"\t y="+y);
	}
}
class MainDefaultex
{
	public static void main(String []args)
	{
		Sample ob = new Sample();
		ob.showData();
	}
}

 In default constructor of Sample class

 x=10    y=23.45

//--------

	// Default constructor can take the values from keyboard

	
class Sample
{
	private int x;
	private double y;
	public Sample()
	{
		System.out.println("\n In default constructor of Sample class");
		java.util.Scanner sc = new java.util.Scanner(System.in);
		System.out.println("Enter the int value: ");
		x=sc.nextInt();
		System.out.println("Enter the double value: ");
		y=sc.nextDouble();
	}
	public void showData()
	{
		System.out.println("\n x="+x+"\t y="+y);
	}
}
class MainDefaultex
{
	public static void main(String []args)
	{
		Sample ob = new Sample();
		ob.showData();
	}
}

//--------------------------------------------------------------------------------------------------------

	- Parameterized Constructor: It is the constructors with arguments.

	 * If we define any constructor in class then it is our responsibility to define default constructor,
	   in such case compiler will not provide the default constructor with empty body. In absence of default 
	   constructor the error will be generated only when compiler will need it for allocation.
	 * A call may contain multiple constructors, but only one executed at a time.

class Sample
{
	private int x;
	private double y;
	public Sample() // Default constructor
	{
		System.out.println("\n In Default constructor of Sample class");
	}
	public Sample(int a1, double a2) // Parameterized constructor
	{
		System.out.println("\n In Para constructor of Sample class");
		x=a1;
		y=a2;
	}
	public void showData()
	{
		System.out.println("\n x="+x+"\t y="+y);
	}
}
class Mainparaex
{
	public static void main(String []args)
	{
		Sample ob = new Sample();
		ob.showData();

		Sample ob2 = new Sample(12,89.45);
		ob2.showData();

		System.out.println("\n In Main class");
		java.util.Scanner sc = new java.util.Scanner(System.in);
		System.out.println("Enter the int value: ");
		int x=sc.nextInt();
		System.out.println("Enter the double value: ");
		double y=sc.nextDouble();
		Sample ob3 = new Sample(x,y);
		ob3.showData();
	}
}


 In Default constructor of Sample class

 x=0     y=0.0

 In Para constructor of Sample class

 x=12    y=89.45

 In Main class
Enter the int value: 
12
Enter the double value: 
34.43

 In Para constructor of Sample class

 x=12    y=34.43

//---------------------------------------------------------------------------------------------

	Constructor Overloading: Defining multiple constructors in a same class. Only take case that
	there must not be two or more constructors with same signature.

class Sample
{
	private int x;
	private double y;
	public Sample() // Default constructor
	{
		System.out.println("\n In default constructor of Sample class");
		java.util.Scanner sc = new java.util.Scanner(System.in);
		System.out.println("Enter the int value: ");
		x=sc.nextInt();
		System.out.println("Enter the double value: ");
		y=sc.nextDouble();
	}
	public Sample(int a) // Parameterized constructor
	{
		System.out.println("\n In Para constructor-1 of Sample class");
		x=a;
		y=a;
	}
	public Sample(int a1, double a2) // Parameterized constructor
	{
		System.out.println("\n In Para constructor-2 of Sample class");
		x=a1;
		y=a2;
	}
	public void showData()
	{
		System.out.println("\n x="+x+"\t y="+y);
	}
}
class MainConOverloading
{
	public static void main(String []args)
	{
		Sample ob = new Sample();
		ob.showData();

		Sample ob2 = new Sample(12);
		ob2.showData();

		System.out.println("\n In Main class");
		java.util.Scanner sc = new java.util.Scanner(System.in);
		System.out.println("Enter the int value: ");
		int x=sc.nextInt();
		System.out.println("Enter the double value: ");
		double y=sc.nextDouble();
		Sample ob3 = new Sample(x,y);
		ob3.showData();
	}
}
o/p:

 In default constructor of Sample class
Enter the int value:
11
Enter the double value:
2.2
x=11    y=2.2

 In Para constructor-1 of Sample class

 x=12    y=12.0

 In Main class
Enter the int value:
6
Enter the double value:
6.6

 In Para constructor-2 of Sample class

 x=6     y=6.6

//-----------------------------------------------------------------------------------------------

	Copy Constructor: A constructor used to create a new object by copying an existing object's data.

class Sample
{
	private int x;
	private double y;
	public Sample() // Default constructor
	{
		System.out.println("\n In default constructor of Sample class");
		java.util.Scanner sc = new java.util.Scanner(System.in);
		System.out.println("Enter the int value: ");
		x=sc.nextInt();
		System.out.println("Enter the double value: ");
		y=sc.nextDouble();
	}
	public Sample(int a) // Parameterized constructor
	{
		System.out.println("\n In Para constructor-1 of Sample class");
		x=a;
		y=a;
	}
	public Sample(int a1, double a2) // Parameterized constructor
	{
		System.out.println("\n In Para constructor-2 of Sample class");
		x=a1;
		y=a2;
	}
	public Sample(Sample t) // copy constructor
	{
		System.out.println("\n In copy constructor of Sample class");
		x=t.x;
		y=t.y;
	}
	public void showData()
	{
		System.out.println("\n x="+x+"\t y="+y);
	}
}
class MainConCopy
{
	public static void main(String []args)
	{
		Sample ob = new Sample();
		ob.showData();

		Sample ob2 = new Sample(12);
		ob2.showData();

		System.out.println("\n In Main class");
		java.util.Scanner sc = new java.util.Scanner(System.in);
		System.out.println("Enter the int value: ");
		int x=sc.nextInt();
		System.out.println("Enter the double value: ");
		double y=sc.nextDouble();
		Sample ob3 = new Sample(x,y);
		ob3.showData();

		Sample ob4 = new Sample(ob3);
		ob4.showData();
	}
}

//--------------------------------------------------------------------------------------------------------

	Constructor chaining: 
	
	Constructor chaining in Java refers to the process of calling one constructor 
	from another within the same class or in a superclass. It allows you to reuse code by having one
	constructor invoke another, reducing redundancy and ensuring consistent initialization of an object.

	- Within the Same Class (Using this()):
		A constructor calls another constructor of the same class.

	- From a Superclass (Using super()):
		A subclass constructor calls a constructor of its superclass.



 class Person {
    private String name;
    private int age;

    // Constructor 1: No arguments
    public Person() {
        this("Unknown", 0); // Calls Constructor 2
        System.out.println("Default constructor called.");
    }

    // Constructor 2: Two arguments
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
        System.out.println("Parameterized constructor called.");
    }

    // Method to display details
    public void displayDetails() {
        System.out.println("Name: " + name + ", Age: " + age);
    }
}

public class Main {
    public static void main(String[] args) {

        // Calls the no-argument constructor
        Person person1 = new Person();
        person1.displayDetails();

        // Calls the parameterized constructor directly
        Person person2 = new Person("Alice", 25);
        person2.displayDetails();
    }
}
o/P:
Parameterized constructor called.
Default constructor called.
Name: Unknown, Age: 0
Parameterized constructor called.
Name: Alice, Age: 25


--------------------------------------------------------

	
public class DemoChainCon {
    private String name;
    private int age;
    private String grade;

    // Default constructor

    public DemoChainCon() {
        this("Unknown", 0, "Not Assigned");  // Calls the parameterized constructor
		System.out.println("\n Default constructor of DemoChainCon class");
    }


    // Constructor with two parameters

    public DemoChainCon(String name, int age) {
        this(name, age, "Not Assigned");  // Calls the constructor with three parameters
		System.out.println("\n Para(args-2) constructor of DemoChainCon class");
    }


    // Parameterized constructor with three parameters

    public DemoChainCon(String name, int age, String grade) {
		System.out.println("\n Para(args-3) constructor of DemoChainCon class");
        this.name = name;
        this.age = age;
        this.grade = grade;
    }


    public void display() {
        System.out.println("Name: " + name + ", Age: " + age + ", Grade: " + grade);
    }

    public static void main(String[] args) {
        DemoChainCon s1 = new DemoChainCon();  // Calls default constructor
        DemoChainCon s2 = new DemoChainCon("Amol", 20);  // Calls two-parameter constructor
        DemoChainCon s3 = new DemoChainCon("Baba", 22, "A");  // Calls three-parameter constructor

        s1.display();  // Output: Name: Unknown, Age: 0, Grade: Not Assigned
        s2.display();  // Output: Name: Alice, Age: 20, Grade: Not Assigned
        s3.display();  // Output: Name: Bob, Age: 22, Grade: A
    }
}

	** Note: this() must be first statement in constructor while chaining.

o/p:

Para(args-3) constructor of DemoChainCon class

 Default constructor of DemoChainCon class

 Para(args-3) constructor of DemoChainCon class

 Para(args-2) constructor of DemoChainCon class

 Para(args-3) constructor of DemoChainCon class
Name: Unknown, Age: 0, Grade: Not Assigned
Name: Amol, Age: 20, Grade: Not Assigned
Name: Baba, Age: 22, Grade: A

//--------------------------------------

	Constructor Chaining Between Superclass and Subclass:
		You use the keyword super() to call the constructor of the superclass.

class A {
    public A() {
        System.out.println("Class A constructor called.");
    }
}

class B extends A {
    public B() {
        super(); // Calls the constructor of Class A
        System.out.println("Class B constructor called.");
    }
}

class C extends B {
    public C() {
        super(); // Calls the constructor of Class B
        System.out.println("Class C constructor called.");
    }
}

public class Main {
    public static void main(String[] args) {
        C obj = new C(); // Triggers the constructor chain
    }
}

o/p:
Class A constructor called.
Class B constructor called.
Class C constructor called.

-------------------------------------

class Animal {
    String species;

    // Parent class constructor
    public Animal(String species) {
        this.species = species;
        System.out.println("Animal constructor called.");
    }
}

class Dog extends Animal {
    String breed;

    // Child class constructor
    public Dog(String species, String breed) {
        super(species); // Calls the parent class constructor
        this.breed = breed;
        System.out.println("Dog constructor called.");
    }

    public void displayDetails() {
        System.out.println("Species: " + species + ", Breed: " + breed);
    }
}

public class Main {
    public static void main(String[] args) {
        Dog dog = new Dog("Canine", "Labrador");
        dog.displayDetails();
    }
}

o/p:
Animal constructor called.
Dog constructor called.
Species: Canine, Breed: Labrador


---------------------------------------

class A
{
	int a;
	public A()
	{
		System.out.println("\n In default constructor of A class");
		a=10;
	}
	public A(int a)
	{		
		System.out.println("\n In para constructor of A class");
		this.a=a;
	}
	public void showa()
	{
		System.out.println("\n a="+a);
	}
}
class B extends A
{
	int b;
	public B()
	{
		System.out.println("\n In default constructor of B class");
		b=20;
	}
	public B(int a, int b)
	{		
		super(a);
		System.out.println("\n In para constructor of B class");
		this.b=b;
	}
	public void show()
	{
		showa();
		System.out.println("\n b="+b);
	}
}
class ChainConSuper
{
	public static void main(String []args)
	{
		B ob1 = new B();
		ob1.show();

		B ob2 = new B(100,200);
		ob2.show();
	}
}

o/p:

 In default constructor of A class

 In default constructor of B class

 a=10

 b=20

 In para constructor of A class

 In para constructor of B class

 a=100

 b=200

//---------------------------------------------------------------------------------------------------------

	// Private Constructor

	A private constructor in Java is a constructor that is declared with the private access modifier. Unlike public 
	or protected constructors, it restricts object creation from outside the class. This means instances of the 	
	class cannot be created directly from outside the class.

	public class Example {
    		private Example() {
        		// Initialization code
    		}
	}


	Why Use a Private Constructor?
	Private constructors are used to achieve specific design patterns and behaviors in Java. 
	Some common use cases include:

	1. Singleton Design Pattern: A singleton ensures that only one instance of a class is created during the 
	   application's lifecycle. The class provides a global access point to this instance.

class Singleton {

    // Static variable to hold the single instance
    private static Singleton instance;
    private static String msg;

   
    // Private constructor to prevent instantiation
    private Singleton() 
    {
        System.out.println("Singleton instance created.");
    }

    // Public method to provide access to the instance
    public static Singleton getInstance(String str)
         {

        if (instance == null)         // Checks whether the instance has already been created.  If instance == null, the method:

          {
	       msg=str;                    // Assigns the input string str to the static variable msg.

            instance = new Singleton();   //Creates a new Singleton object and assigns it to the static variable instance.

        }
        return instance;                // If instance != null, it skips the creation process and simply returns the existing instance.
    }

    public void displayMessage() {
        System.out.println("Hello from Singleton! "+msg);
    }
}
class DemoSingleton
{		
    public static void main(String[] args) {
        Singleton obj1 = Singleton.getInstance("One");  // Creates the instance
        Singleton obj2 = Singleton.getInstance("Two");  // Returns the same instance
        Singleton obj3 = Singleton.getInstance("Three");

        obj1.displayMessage();  // Output: Hello from Singleton!One
        obj2.displayMessage();  // Output: Hello from Singleton!One
        obj3.displayMessage();
        System.out.println(obj1 == obj2);  // Output: true(same instance) // obj1 and obj2 refer to the same instance, the result is true
    }
}

o/p:
Singleton instance created.
Hello from Singleton! One
Hello from Singleton! One
Hello from Singleton! One
true

 //--------------------------------

	2. Factory Method Pattern: A factory method uses a private constructor to control the 
	   creation of objects and delegates object creation to static methods.

class Product {
    
	private String name;

    // Private constructor
    private Product(String name) {
        this.name = name;
    }

    // Static factory method
    public static Product createProduct(String type) 
      {
        if (type.equalsIgnoreCase("Laptop")) 
              {
            return new Product("Laptop");
              }
            else if (type.equalsIgnoreCase("Phone"))
               {
            return new Product("Phone");
              } 
           else
          {
            return new Product("Unknown Product");
          }
    }

    public void display() {
        System.out.println("Product: " + name);
    }
}

class DemoFactoryMethodPattern
{
    public static void main(String[] args) {
        Product p1 = Product.createProduct("Laptop");
        Product p2 = Product.createProduct("Tablet");

        p1.display();  // Output: Product: Laptop
        p2.display();  // Output: Product: Unknown Product
    }
}

//-------------------------------------------------------------------------------

	3. Preventing Instantiation in Utility Classes:

	Utility classes contain static methods and constants. Since they don’t 
	need instances, a private constructor prevents instantiation.

class UtilityClass {

    // Private constructor to prevent instantiation
    private UtilityClass() {
        throw new UnsupportedOperationException("Cannot instantiate UtilityClass.");
    }

    // Static utility method
    public static int add(int a, int b) {
        return a + b;
    }
}
class DemoUtilityClasses
{
	
    public static void main(String[] args) {
        int result = UtilityClass.add(5, 10);
        System.out.println("Result: " + result);  // Output: Result: 15

        //  UtilityClass obj = new UtilityClass();  // Compilation error if uncommented
    }
}

//-------------------------------------------------------------------------------------------------------------------------------

	// Is Static Constructors Present in java? 

	No, the concept of "static constructors" does not exist in java. However, Java provides a way to 
	achieve similar functionality using static blocks. Static blocks are used to initialize static data 
	members of a class and are executed when the class is loaded.

	Static Blocks in Java
	Static blocks are used to initialize static fields and perform any necessary setup when the class is 
	loaded. They are executed only once, when the class is first loaded into memory.

	class <>
	{
		static {
    			// Initialization code
		}
	}

	As we need constructor in class to initialize the object, and it will be required for each object, means
	it must be at object level. as static makes it class level it is not allowed in java.
	

   class Example {
    static int x;
    static String message;

    // Static initialization block
    static {
        x = 10;
        message = "Static block initialized!";
        System.out.println("Static block executed.");
    }

    public static void main(String[] args) {
        System.out.println("x: " + x);
        System.out.println("Message: " + message);
    }
}

O/P:
Static block executed.
x: 10
Message: Static block initialized!

---------------------------------------------------------------
 Questions: 
    
   1.How is a constructor different from a method? 
 Constructor:
     A constructor is used to initialize an object
    Has the same name as the class.
    No return type (not even void).
    Constructors are automatically called when an object is created,
   
 Method:
    Used to perform operations.
    Can have any name and a return type.
    A method is used to define behaviors of an object and has a return type, such as int, String, or void.
    while methods are invoked explicitly using an object reference.


  2.Can a constructor be final, static, or abstract in Java?
         No, because:
        final: Constructors cannot be overridden, so marking them final is unnecessary.
        static: A constructor is invoked on an object, not a class, so it cannot be static.
        abstract: Constructors cannot be abstract as they must always have a body.


  3. What happens if no constructor is defined in a class?
        Java provides a default constructor that initializes the object with default values.


   3.1 What will happen if a class does not have a constructor?
         If a class does not explicitly define a constructor, the Java compiler automatically provides a default constructor 
        (a no-argument constructor) that initializes the instance variables with their default values (e.g., 0 for integers, null for objects).

         Explanation:
         However, if you define any constructor (default or parameterized), the compiler will not provide a default constructor.
          If you want a default constructor after defining others, you must explicitly define it.



  4. Why can’t constructors be inherited?
           Constructors are not inherited because they are specific to the class they belong to. However, 
           the child class can call the parent class constructor using super().


  5.What is the role of the this() keyword in constructors?
        The this() keyword is used to call another constructor. this() keyword is used to call one constructor from another 
       constructor in the  same class. It must be the first statement in the constructor.


  6. What is the difference between the this() and super() keywords in a constructor?
          this() calls another constructor in the same class.
          super() calls a constructor of the parent class.


  7. What is the difference between a default constructor and a no-argument constructor?
       A default constructor is provided by the Java compiler if no constructor is explicitly defined.
       A no-argument constructor is explicitly written by the programmer.


  8. What is the significance of a private constructor?
        A private constructor is used to restrict object creation. It is often used in:
       Singleton Design Pattern (ensures only one instance of the class exists).
       Utility classes where all methods are static.


   9. What happens if we explicitly define a parameterized constructor but not a default constructor?
        If a parameterized constructor is defined, the compiler does not generate a default constructor. Attempting 
        to create an object without arguments will result in a compilation error unless a no-argument constructor is explicitly defined.
 
  
  10. What happens if a parent class does not have a no-argument constructor?
          If the parent class does not have a no-argument constructor, the child class must explicitly call one of the 
          parent class's parameterized constructors using super().


   11.What is the difference between object initialization using a constructor and using instance initializer blocks?
        Constructor:
            1.Executes every time an object is created.
            2.Can accept parameters.

       Instance Initializer Block:
           1. Executes before the constructor, whenever an object is created.
           2. Cannot accept parameters.


   12.Why is a constructor not inherited in Java?
            Constructors are not inherited because they are specific to their class. However, the child class 
            can call the parent class constructor using super().



//-----------------------------------------------------------------------------------------------------------


	// Default arguments in methods:  it is not allowed to write default arguments in java methods. Unlike some 
	   other programming languages (such as C++ or Python), Java does not support default arguments for methods. 
	   This means that when you define a method in Java, you must specify all the parameters explicitly, and 
	   the caller must provide values for all the parameters.

	Why Java Does Not Support Default Arguments?

	- Java aims to keep the language simple and readable. Default arguments can sometimes make the code harder 
	  to understand, especially when methods are overloaded or when the default values are not obvious.
	- Java emphasizes consistency in its syntax and semantics. Introducing default arguments could lead to 
	  inconsistencies and potential ambiguities in method overloading and method resolution.
	- Java has a strong emphasis on backward compatibility. Introducing default arguments could break existing 
	  code or introduce subtle bugs in legacy systems.

	Alternatives to Default Arguments: 

	While Java does not support default arguments, there are several alternatives to achieve similar functionality:

	1. Method Overloading: You can define multiple versions of a method with different parameter lists. This allows 
	you to provide default values by calling the appropriate overloaded method.

public class Example {
    public void display(String message) {
        System.out.println(message);
    }

    public void display() {
        display("Default message");
    }

    public static void main(String[] args) {
        Example example = new Example();
        example.display(); // Output: Default message
        example.display("Custom message"); // Output: Custom message
    }
}

//--------------

	2. Builder Pattern: The Builder pattern is a design pattern that allows you to construct complex objects 
	   step by step. It provides a flexible way to set default values and build objects with optional parameters.


class Product {
    private String name;
    private double price;
    private String category;

    private Product(Builder builder) {
        this.name = builder.name;
        this.price = builder.price;
        this.category = builder.category;
    }

    public static class Builder {
        private String name = "Default Name";
        private double price = 0.0;
        private String category = "Default Category";

        public Builder setName(String name) {
            this.name = name;
            return this;
        }

        public Builder setPrice(double price) {
            this.price = price;
            return this;
        }

        public Builder setCategory(String category) {
            this.category = category;
            return this;
        }

        public Product build() {
            return new Product(this);
        }
    }

    @Override
    public String toString() {
        return "Product [name=" + name + ", price=" + price + ", category=" + category + "]";
    }
}

public class MainBuilderPattern {
    public static void main(String[] args) {
        Product product1 = new Product.Builder().build();
        Product product2 = new Product.Builder().setName("Laptop").setPrice(999.99).build();

        System.out.println(product1);
        System.out.println(product2);
    }
}

o/p:
Product [name=Default Name, price=0.0, category=Default Category]
Product [name=Laptop, price=999.99, category=Default Category]

//----------------------------
	3. Varargs: Varargs (variable-length arguments) allow you to pass a variable number of 
	   arguments to a method. This can be used to simulate default arguments by checking the 
	   length of the varargs array.

public class VarargsExample {
    public void display(String... messages) {   // syntax
        if (messages.length == 0) {
            System.out.println("Default message");
        } else {
            for (String message : messages) {
                System.out.println(message);
            }
        }
    }

    public static void main(String[] args) {
        VarargsExample example = new VarargsExample();
        example.display(); // Output: Default message
        example.display("Custom message 1", "Custom message 2"); // Output: Custom message 1 Custom message 2
        example.display("One", "Two", "Three"); 
    }
}

o/p:
Default message
Custom message 1
Custom message 2
One
Two
Three
//-----------------------------------------------------------------------------------------------------------

	// Is friend function allowed in Java like C++?

		No, the concept of "friend functions" as found in C++ does not exist in Java. Friend functions 
		in C++ allow a function to access the private and protected members of a class, even if the function 
		is not a member of that class. This is not possible in Java due to its strict access control and 
		encapsulation principles.

	Alternatives to Friend Functions in Java
	While Java does not support friend functions, there are several design patterns and techniques that can achieve 
	similar functionality:

	- Package-Private Access:
		By placing classes in the same package, you can allow them to access each other's package-private 
		(default) members. This provides a level of encapsulation while still allowing controlled access.

	- Nested Classes:
		Nested classes (inner classes) can access the private members of their enclosing class. This allows 
		for controlled access to private members.

	- Getter and Setter Methods:
		Provide public getter and setter methods to access and modify private fields. This is a common 
		practice in Java to control access to private members.
	
	- Interfaces:
		Define interfaces that provide access to specific methods or fields. This allows controlled access 
		to private members through the interface.


//-----------------------------------------------------------------------------------------------------------------

	Garbage Collector (GC): 

	 In Java, the Garbage Collector (GC) is a part of the Java Virtual Machine (JVM) responsible for 
	 managing memory. It automatically reclaims memory that is no longer in use, ensuring efficient memory 
	 utilization and preventing memory leaks.

	 In another words, It will release the derefernced locations, the derefernced locations are those allocated
	 locations, which are not referred by any reference variables.


			[][][][][][][][][][][][]
			[][][][][][][][][][][][]
			[][][/][][][][][][][/][][]
			[][][][][][][][][][][][]
			[][][][][][][][][][][][]
			[][][/][][][][][][][][][]
			[][][][][][][][][][][][]
			[][][][][][][][][][][][]
			[][][][][][][][][][][][]
			[][][][][][][][][][][][]
			[][][][][][][][][][][][]
			[][][][][][][][][][][][]


	Demo ref=new Demo();
	Demo dob=new Demo();
	

		ref
 		 [ ] ------------> [][][][][][][][][][][][]


		dob
 		 [ ] ------------> [][][][][][][][][][][][]



	ref=dob;

		ref		  Dereferenced Location
 		 [ ]		 [][][][][][][][][][][][]
		  |_________________
		 	           |
	      dob                  V
 		 [ ] ------------> [][][][][][][][][][][][]


 
	Garbage collector is a member which is used to free the dereferenced location. It will
	perform same task when it will get enough idle time of processor.

	If you want to utilize the resources hold by that object just before release of that location
	(done with the help of destructor in C++), the java provides the following method.

	protected void finalize()
	{
		--------------;
		-------------;
	}


	If you want to request early release then call System.gc();

import java.util.Scanner;
class Employee
{
	private String nm;
	private int eid;
	private double sal;

	Employee()
	{
		nm="";
		eid=-1;
		sal=-1.0;
	}	
	Employee(String nm,int eid,double sal)
	{
		this.nm=nm;      //The this keyword differentiates the instance variables (this.nm, this.eid, this.sal) from the parameters.
		this.eid=eid;
		this.sal=sal;
	}
	public void display()
	{
		System.out.println("Name: "+nm);
		System.out.println("Employee ID: "+eid);
		System.out.println("salary: "+sal);
	}
	protected void finalize()
	{
		System.out.println(" In finalize() method");
	}
}

class EmployeeMain
{ 
	public static void main(String []args) throws InterruptedException
	{
		{
			Employee eob=new Employee("Abhi",11,50000);
			eob.display();

			eob=null;  //Removes the reference to the Employee object, making it eligible for garbage collection.
                                   //When the eob reference is set to null and System.gc() is called,
                                   // the garbage collector invokes the finalize() method:
		}
		System.gc();
		Thread.sleep(5000);
		System.out.println(" End of program: ");
	}
}
Name: Abhi
Employee ID: 11
salary: 50000.0
 In finalize() method
 End of program:

--------------------------------------------------

class Example {
    private String resourceName;

    // Constructor
    Example(String resourceName) {
        this.resourceName = resourceName;
        System.out.println(resourceName + " resource acquired.");
    }

    // Overriding finalize()
    @Override
    protected void finalize() throws Throwable {
        System.out.println(resourceName + " resource released.");
        super.finalize();  // Optional: Call parent class's finalize()
    }
}

public class Main {
    public static void main(String[] args) {
        Example obj1 = new Example("Resource1");
        Example obj2 = new Example("Resource2");

        // Making objects eligible for garbage collection
        obj1 = null;
        obj2 = null;

        // Requesting garbage collection
        System.gc();

        System.out.println("End of program.");
    }
}

O/P:

Resource1 resource acquired.
Resource2 resource acquired.
Resource1 resource released.
Resource2 resource released.
End of program.

      How It Works:
    1. When obj1 and obj2 are set to null, they become eligible for garbage collection.
    2. Calling System.gc() suggests the JVM to run the garbage collector.
    3. Before the objects are destroyed, the finalize() method is called for each object.
    4. After finalize() is executed, the objects are removed from memory.


----------------------------------------------

	The Garbage Collector (GC) in programming, particularly in languages like Java, is a mechanism for automatic memory 
	management. Its primary purpose is to reclaim memory occupied by objects that are no longer in use by a program, 
	preventing memory leaks and ensuring efficient utilization of system memory.

	Key Points About Garbage Collection

	Automatic Memory Management:
	In languages like Java, developers do not manually allocate or deallocate memory for objects. The GC handles the cleanup 
	of unused objects, freeing the programmer from this responsibility.

	Managed Heap Memory:
	Objects in Java are created in the heap memory. The GC identifies objects that are no longer reachable and removes them 
	to free up space for new objects.

	Reachability:
	An object is considered unreachable if it is no longer accessible through any reference in the program. If no thread can 
	access an object, it becomes eligible for garbage collection.

	Garbage Collection Process:

       1. Object Allocation:
               When an object is created using the new keyword, memory is allocated in the heap.
                e.g. String str = new String("Hello");
   
      2. Object Reference:
           If an object is referenced (i.e., accessible through a variable or another object), it is considered reachable
           and not eligible for garbage collection.

     3. Unreachable Objects:
            When there are no active references to an object, it becomes unreachable and is eligible for garbage collection.
              e.g. MyClass obj = new MyClass();     // obj refers to the object
                   obj = null;                     // Object becomes unreachable

     4. Marking Phase:
            The GC identifies which objects are reachable or currently in use and marks them.
            Objects not marked as reachable are considered garbage.


     5. Sweeping Phase:
             The GC removes objects that are no longer reachable (unreachable) objects. and reclaims memory

     6. Compacting Phase (optional):
            The GC compacts the heap by reorganizing remaining objects to improve memory usage and reduce fragmentation.

    
    **** Generational Garbage Collection:
	Many modern GCs, including those in Java, use a generational model, dividing the heap into:

	1. Young Generation: 1. Newly created objects. Most objects are short-lived and are quickly collected.
                          2. Further divided into:
                            i> Eden Space: New objects are allocated here.
                            ii> Survivor Spaces (S0, S1): Objects that survive a garbage collection in the Eden Space are
                                                          moved to one of the two Survivor Spaces.

                             ***3. Uses Minor GC for cleanup: Fast and frequent because most objects in the Young Generation are short-lived.

	2. Old Generation (Tenured): 1. Objects that survive multiple GC cycles in the young generation are moved here. 

                              ***2. Uses Major GC for cleanup:
                                        Major GC is slower than Minor GC because it involves scanning a larger memory space and
                                        typically pauses the application for a longer time.Since Major GC is more expensive, 
                                        objects promoted to the Old Generation are expected to remain in memory for a longer duration.

	3. Permanent Generation (Metaspace): Stores metadata about classes and methods. (In Java 8 and later, this is replaced by 
	Metaspace.)



      ****Types of Garbage Collectors in Java:

	1. Serial Garbage Collector: A simple GC for single-threaded applications.

	2. Parallel Garbage Collector: Uses multiple threads for GC tasks, suited for multi-threaded environments.

	3. Concurrent Mark-Sweep (CMS) Collector: Reduces pause times by running GC concurrently with the application threads.

	4. G1 Garbage Collector: Divides the heap into regions and collects garbage in a mixed approach (young and old generation).

	5. ZGC: Designed for very low-latency applications, with extremely short pauses. Handles very large heaps 
                 with extremely low pause times.

	6. Shenandoah GC: Another low-latency garbage collector.


	GC Triggers:
	The JVM triggers garbage collection when it detects that memory is running low or at certain points in the program 
	execution. It can also be triggered explicitly using the method:

	System.gc();
         
          System.gc() is used to explicitly request garbage collection.
	However, calling this method does not guarantee immediate garbage collection; it's just a suggestion to the JVM.
        The actual invocation of garbage collection depends on the Garbage Collector implementation and whether the JVM deems it necessary.


	Advantages of Garbage Collection:
	Prevents memory leaks.
	Simplifies memory management for developers.
	Helps in managing complex object lifecycles automatically.

	Disadvantages of Garbage Collection:
	Performance Overhead: GC can cause pauses in program execution (known as "stop-the-world" events).
	Less control over memory management compared to manual memory management (e.g., in C/C++).

	//-----------------------------------------

	Generational Garbage Collection is a strategy used in modern garbage collection systems (including Java's JVM) to 
	optimize memory management. It is based on the observation that most objects have a short lifespan, while a smaller 
	number live longer. This strategy divides the heap memory into generations, where objects are grouped by their age, 
	to improve performance and minimize overhead.

	Generations in the Heap Memory
	The heap is divided into three main regions:

	Young Generation:
	This is where all newly created objects are allocated.
	It is further divided into:
	Eden Space: All new objects are initially allocated here.
	Survivor Spaces (S0 and S1): After the first garbage collection, objects that survive are moved here.
	Most objects in the Young Generation are short-lived and are quickly garbage collected. This process is called a Minor GC.
	
	Old Generation (Tenured Generation):
	Objects that survive multiple Minor GCs are promoted to the Old Generation.
	These objects tend to have a longer lifespan.
	Garbage collection in this space is called a Major GC or Full GC.
	Major GC is more time-consuming compared to Minor GC, as it operates on a larger memory space.

	Permanent Generation (or Metaspace):
	In older versions of Java (up to Java 7), the Permanent Generation was used to store metadata about classes, 
	methods, and other JVM structures.
	In Java 8 and later, this was replaced by Metaspace, which is not part of the heap and is allocated in native memory.

		+-------------------+-------------------+-------------------+
		|   Young Gen       |    Old Gen        |   (Metaspace)     |
		|                   |                   |                   |
		|   +-----------+   |                   |                   |
		|   |   Eden    |   |                   |                   |
		|   +-----------+   |                   |                   |
		|   | Survivor0 |   |                   |                   |
		|   +-----------+   |                   |                   |
		|   | Survivor1 |   |                   |                   |
		+-------------------+-------------------+-------------------+


   Questions: 

          1.1. How does the Garbage Collector know which objects to collect?
                    - The Garbage Collector uses a concept called reachability. An object is eligible for garbage collection 
                         if it is no longer reachable through any references from:
                          Local variables, Static fields , Active threads
                    - if an object cannot be accessed directly or indirectly, it becomes eligible for GC.


        1. What are the main areas of the Java Heap Memory?
               Young Generation: For short-lived objects.
                                 Divided into Eden Space and Survivor Spaces (S0, S1).
               Old Generation (Tenured Generation): For long-lived objects.
               Metaspace: For class metadata (introduced in Java 8).


       1.1  What is the difference between null and garbage?
                   -  An object becomes garbage when it is no longer reachable.
                   - Setting a reference variable to null only means that the variable no longer refers to the object, 
                        but the object itself may still exist if there are other references to it.


       1.2 What are the main phases of Garbage Collection?
              The GC process typically involves the following phases:
             - Mark: Identify reachable objects.
             - Sweep: Remove unreferenced objects.
             - Compact (optional): Rearrange remaining objects to optimize memory usage and avoid fragmentation.


        2. What are the types of Garbage Collection in Java?
               Minor GC: Cleans up the Young Generation.
               Major GC: Cleans up the Old Generation.
               Full GC: Cleans up both Young and Old Generations, and may include the Metaspace.
                        It is triggered when the heap is full, or when system-level conditions require memory compaction.

       3. What are the different Garbage Collectors in Java?
               Serial GC: Single-threaded; 
               Parallel GC: Multi-threaded; 
               CMS (Concurrent Mark-Sweep): 
               G1GC (Garbage First GC): 
               ZGC (Z Garbage Collector):
               Shenandoah GC: 

     4. What is the finalize() method?
             The finalize() method is called / invoked by the Garbage Collector before an object is removed from memory.      
        It is used to perform cleanup operations, but it is not recommended for production use.

   
      5. What is memory fragmentation in the Old Generation?
               Memory fragmentation occurs when the Old Generation has enough free space in total,  
               but not in a contiguous block, leading to allocation failures for large objects.

     6.  What is a memory leak in Java?
              A memory leak occurs when objects that are no longer needed remain reachable because of lingering references,
               preventing them from being garbage collected.

    7. What are soft, weak, and phantom references in Java?
           Soft Reference: Objects are cleared if the JVM runs low on memory.
           Weak Reference: Objects are cleared on the next garbage collection cycle.
           Phantom Reference: Objects are cleared only after the finalize() method is invoked.


     8. 11. How can you manually make an object eligible for Garbage Collection?

             1>  Set all references to the object to null: When you set all references pointing to an object to null, 
                       the object becomes unreachable, and as a result, it becomes eligible for garbage collection. 
                       If no other active reference exists to the object, the garbage collector can reclaim its memory.

            2>  Reassign the reference to point to another object:
                     When you assign a new object to an existing reference variable, the previous object that was 
                    referenced by that variable becomes unreachable (assuming no other references to that object exist). 
                     This makes the previous object eligible for garbage collection.

class Test {
    public static void main(String[] args) {
        String str1 = new String("Object 1");
        String str2 = new String("Object 2");

        // Assigning str1 to str2, making "Object 1" eligible for GC
        str1 = str2;

        // Requesting garbage collection (optional)
        System.gc(); // "Object 1" is now eligible for GC
    }
}
             In this example, after str1 = str2;, the "Object 1" string is no longer referenced and becomes eligible for garbage collection.





//-----------------------------------------------------------------------------------------------------------------

	// Using the static keyword in java.


	// Static variable(static data member): In Java, a static data member (also known as a static variable) is a 
               variable that is shared among all instances of a class. It is declared with the static keyword, meaning 
		that it belongs to the class itself rather than to any specific instance of the class. As a result,
		static data members have the same value across all instances of the class.

	 Characteristics of Static Data Members:

	- Shared Among Instances: All objects of the class share the same static variable, which means that if one 
	  object modifies the static variable, the change is reflected across all objects.

	- Class Level: A static variable is associated with the class rather than any instance of the class. 
	  It can be accessed directly using the class name without creating an object of the class.

	- Memory Allocation: Static variables are allocated memory only once, when the class is loaded into memory, 
	  and they retain their values throughout the execution of the program.


	// static method (static member function):

	A static member function (also known as a static method) in Java is a method that belongs to the class itself,
	rather than to instances (objects) of the class. It can be called on the class directly, without needing to 
	create an object of that class. Static methods are often used for utility or helper functions, where the method 
	does not need access to instance variables or methods.

	Characteristics of Static Member Functions:

	- Class-Level Function: A static method is associated with the class itself rather than with any specific 
	  object or instance of the class. This means that it can be called without creating an object.

	- Access to Static Members: Static methods can access other static members (variables and methods) of the class.
	  However, they cannot directly access instance variables or instance methods, because instance variables belong 
	  to specific objects, and static methods do not belong to any specific object.

	- Memory Allocation: Static methods are allocated memory once, when the class is loaded into memory, and they 
	  exist as long as the class exists in memory.

	- Cannot Use this: Since static methods do not belong to any particular object, they cannot use the this keyword. 
	  The this keyword refers to the current object, which does not exist for static methods.

		Memory allocated for all objects of class Item
	 ________________________________________________________________________
	 |common memory area							|
	 |	void setData(){}		tot				|
	 |	void showData(){}		 [ 0.0 ]			|
	 |	static void showTotalBill()					|
	 |______________________________________________________________________|
	 |Individual memory area						|
	 |	ob1		ob2		list				|
	 |	[]              []  		[    ] - For data only		|
	 |									|
	 |______________________________________________________________________|
	

	In above program, the variable tot holds the data i.e. total bill which is not secure, so we want to hide
	it within a class.


import java.util.Scanner;
class Item
{
	private int icode;
	private double iprice;
	private static double tot;
	public void setData()
	{
		Scanner sc = new Scanner(System.in);
		System.out.println("Enter the code of item: ");
		icode=sc.nextInt();
		System.out.println("Enter the price of item: ");
		iprice=sc.nextDouble();
		tot = tot + iprice;
	}
	public void showData()
	{
		System.out.print("\n Item Code: "+icode+"\t Price: "+iprice);
	}
	public static void showTotalBill()
	{
		System.out.println("\n Total Bill: "+tot);
	}
}
class MainItemClass2
{
	public static void main(String []args)
	{
		Item.showTotalBill();
		Item []list = new Item[5];
		
		System.out.println("Enter the details of five Items: ");
		for(int i=0;i<5;i++)
		{
			list[i]=new Item();
			list[i].setData();
		}

		System.out.println("\n Item List ");
		for(int i=0;i<5;i++)
		{
			list[i].showData();
		}
		Item.showTotalBill();
	}
}

o/p:
 Total Bill: 0.0
Enter the details of five Items:
Enter the code of item:
11
Enter the price of item:
9000
Enter the code of item:
22
Enter the price of item:
800
Enter the code of item:
33
Enter the price of item:
400
Enter the code of item:
55
Enter the price of item:
90
Enter the code of item:
66
Enter the price of item:
40

 Item List

 Item Code: 11   Price: 9000.0
 Item Code: 22   Price: 800.0
 Item Code: 33   Price: 400.0
 Item Code: 55   Price: 90.0
 Item Code: 66   Price: 40.0
 Total Bill: 10330.0
//-----------------------------------------------------------------------------------------------------------

	// In a different Style: Using the setter and getter methods


import java.util.Scanner;
class Product
{
	private int id;	
	private static int tot;
	private String name;
	private double price;
	
	public void setId(int id) {
		this.id=id;
	}
	public int getId() {
		return id;
	}
	
	public void setName(String name) {
		this.name=name;
	}
	public String getName() {
		return name;
	}
	
	public void setPrice(double price) {
		this.price = price;
		tot+=this.price;
	}
	public double getPrice() {
		return price;
	}

	public String toString() {
		return "Produce Details: ID: "+id+" Name: "+name+"\n Price: "+price;
	}

	public static float getTot() {
		return tot;
	}
}
class DemoProduct
{
	public static void main(String[] args) 
	{
		Scanner sc = new Scanner(System.in);
		System.out.println("Enter the prduct count: ");
		int cnt = sc.nextInt();
		Product []p1 = new Product[cnt];

		int i=0;
		int id;
		String name="";
		double price;

		while(true) {
			System.out.println("Enter 1 insert and the 2 to display product details 3 to display total Bill: ");
			int opt = sc.nextInt();

			if(opt==1) {
				 System.out.println("Enter the id, name and price: ");
				 p1[i]=new Product();
				 id=sc.nextInt();
				 p1[i].setId(id);

				 name=sc.nextLine();
				 name=sc.nextLine();
				 p1[i].setName(name);

				 price=sc.nextDouble();
				 p1[i].setPrice(price);

				 i++;
			}
			else if (opt==2) {
				System.out.println("\n ----------- List of Product ---------- ");
				for(int j=0; j<i ; j++)	{
					System.out.println(p1[j]);
				}
			
			}
			else if (opt==3) {
				System.out.println("\n ----------- Pay Bill: "+Product.getTot()+" ---------- ");

			}
		}
	}
}

	//-----------------------------

	// Static initializer (Static Block):

	In Java, a static initializer (also known as a static block) is a special code block that is used to initialize 
	static variables when the class is loaded into memory. It is executed only once when the class is first loaded, 
	and not every time an object of the class is created. This is different from instance initialization, which 
	occurs whenever a new instance of the class is created.

	- Declaration: A static block is declared using the static keyword, followed by a block of code enclosed in 
	  curly braces {}. It is placed inside the class, but outside any methods or constructors.

	  i.e.
		class Example
		{
			int x;
			static double y;
			static
			{
				y=100.0;
			}
			....
		}

	- It is used, To initialize static variables or perform any setup that is needed at the class level (before 
	  any objects are created).
	- Useful for complex initialization of static variables, especially if the initialization requires multiple 
	  lines of code or logic that cannot be done in a simple assignment.
	- If there are multiple static blocks in a class, they will execute in the order in which they appear 
	  in the code.
	- A static block can also handle exceptions. If an exception is thrown within a static block, it can be 
	  caught and handled, preventing the class from failing to load.


	// lets see the default values of static variables

class Example
{
	static int x;		// we not decl. as private,it is default, and accessible using 
	static double y;	// .operator directly. And we want to access directly for checking purpose.
	static boolean z;
	// ... some another members
}
class DemoStatic 
{
	public static void main(String[] args) 
	{
		System.out.println("value of x: "+Example.x);
		System.out.println("value of y: "+Example.y);
		System.out.println("value of z: "+Example.z);
	}
}

O/P:
value of x: 0
value of y: 0.0
value of z: false


	// class with static initilizer

class Example
{
	static int x;		// we not decl. as private coz want to access directly
	static double y;	// for checking purpose
	static boolean z;
	static
	{
		z=true;
		x=5;
		y=x*x/3.0;
		System.out.println("\n In Static Block");
	}
	// ... some another members
}
class DemoStatic 
{
	public static void main(String[] args) 
	{
		System.out.println("value of x: "+Example.x);
		System.out.println("value of y: "+Example.y);
		System.out.println("value of z: "+Example.z);
	}
}


	// A class with multiple static Blocks

class Example
{
	static int x;		// we not decl. as private coz want to access directly
	static double y;	// for checking purpose
	static boolean z;
	static
	{
		z=true;
		System.out.println("\n In Static Block-1");
	}	
	static
	{
		x=5;
		System.out.println("\n In Static Block-2");
	}	
	static
	{
		y=x*x/3.0;
		System.out.println("\n In Static Block-3");
	}
	// ... some another members
}
class DemoStatic 
{
	public static void main(String[] args) 
	{
		System.out.println("value of x: "+Example.x);
		System.out.println("value of y: "+Example.y);
		System.out.println("value of z: "+Example.z);
	}
}
O/P:
 In Static Block-1

 In Static Block-2

 In Static Block-3
value of x: 5
value of y: 8.333333333333334
value of z: true



	// static block with try-catch (handling exception in static block)

class Example
{
	static int x;
	static int t;		// we not decl. as private coz want to access directly
	static double y;	// for checking purpose
	static boolean z;
	static
	{
		z=true;
		t=2;  // try with t=0
		System.out.println("\n In Static Block-1");
	}	
	static
	{
		try
		{
			x=23/t;
		}
		catch (Exception e)
		{
			System.out.println("\n Unable to init x, so init to default value");
		}
		System.out.println("\n In Static Block-2");
	}	
	static
	{
		y=x*5.7/x;
		System.out.println("\n In Static Block-3");
	}
	// ... some another members
}
class DemoStatic 
{
	public static void main(String[] args) 
	{
		System.out.println("value of x: "+Example.x);
		System.out.println("value of y: "+Example.y);
		System.out.println("value of z: "+Example.z);
	}
}

//---------------

	// Using static nested class

	In Java, a static class typically refers to a nested static class. It is a class defined within another class 
	but declared with the static keyword. Static classes are a way to define inner classes that don't depend on an
	instance of the outer class, which allows them to behave differently from regular inner classes.

	Key Points About Static Classes
	- It must be in a scope of enclosing class(Outer), Must not be decl. within constructor or method of outer class.
	- A static class in Java is always a static nested class, which is a class that is defined within another class, 
	  but with the static keyword. It is an inner class but without a reference to an instance of the outer class.
	- A static nested class does not have access to the instance variables or instance methods of the outer class. 
	  It can only directly access the static members of the outer class.
	- Unlike regular inner classes, which require an instance of the outer class to be created, a static nested 
	  class can be instantiated independently, without needing an instance of the enclosing (outer) class.
	- whenever you want to use inner class, It must be written in fully qualified manner, while creating object 
	  and allocating memory for it.

class Outer
{
	private int x;
	static class Inner
	{
		private int y;
		public void setData()
		{
			y=200;
		}
		public void showData()
		{
			System.out.println("y="+y);
		}
	}
	public void in()
	{
		x=100;
	}
	public void out()
	{
		System.out.println("x="+x);
	}
}
class DemoStaticInnerClass 
{
	public static void main(String[] args) 
	{
		Outer ob1=new Outer();
		ob1.in();
		ob1.out();

		Outer.Inner ob2 = new Outer.Inner();
		ob2.setData();
		ob2.showData();
	}
}

o/p:
x=100
y=200


	// Accessing static member of Inner and Outer class

class Outer
{
	static int var_out;
	private int x;
	static class Inner
	{
		static int var_in;
		private int y;
		public void setData()
		{
			y=200;
		}
		public void showData()
		{
			System.out.println("y="+y);
			System.out.println("var_out="+var_out); // Inner method able to access static members of outer class
		}
	}
	public void in()
	{
		x=100;
	}
	public void out()
	{
		System.out.println("x="+x);
		// System.out.println("var_in="+var_in); // Error: we cant access the static member of inner class from outer method
	}
}
class DemoStaticInnerClass 
{
	public static void main(String[] args) 
	{
		Outer ob1=new Outer();
		ob1.in();
		ob1.out();

		Outer.Inner ob2 = new Outer.Inner();
		ob2.setData();
		ob2.showData();
	}
}

o/P:
x=100
y=200
var_out=0
var_in=0
	       Static nested classes are often used when you want to logically group a class inside another class, but it 
	        does not need access to the outer class instance.

//---------------

	// Using Static import
	
	In Java, static import is a feature that allows you to access static members (fields and methods) of a 
	class without needing to qualify them with the class name. This can make the code more concise and 
	readable, especially when you use multiple static members from a class frequently. 
	Static import is introduced in Java 5 (with the release of J2SE 5.0).

	syntax:
	 - 1. Importing Specific Static Members: import static packageName.ClassName.staticMember;
	 - 2. Importing All Static Members: import static packageName.ClassName.*;


// we have to write program to calculate the area of circle(pi*r*r)
/*
// in simple way
class ExampleStaticImport
{
	public static void main(String[] args) 
	{
		double r=4;
		double area=3.142*r*r;
		System.out.println("Area of Circle: "+area);
	}
}

//----------------------------

// Using java.lang.Math class

class ExampleStaticImport
{
	public static void main(String[] args) 
	{
		double r=4;
		double area=Math.PI*Math.pow(r,2);
		System.out.println("Area of Circle: "+area);
	}
}


//----------------------------

// Using static import(pow() only)

import static java.lang.Math.pow;
class ExampleStaticImport
{
	public static void main(String[] args) 
	{
		double r=4;
		double area=Math.PI*pow(r,2);
		System.out.println("Area of Circle: "+area);
	}
}

*/
//----------------------------

// Using static import-Importing all static members
import static java.lang.Math.*;
class ExampleStaticImport
{
	public static void main(String[] args) 
	{
		double r=4;
		double area=PI*pow(r,2);
		System.out.println("Area of Circle: "+area);
	}
}


	In above examples:

	- Without static import: You need to fully qualify Math.pow(2, 3).
	- With static import: You can simply use pow(2, 3) directly, making the code cleaner.

	Drawbacks of Static Import:

	- Ambiguity: Static import can lead to ambiguity when multiple static members with the same name are 
	  imported from different classes.
	- Reduced Clarity: it become difficult to determine which static members belong to which class in case 
	  multiple static imports.


 -------------------------------
   
     Questions:


    1. What is the static keyword in Java?
            The static keyword in Java is used to indicate that a member (variable, method, block, or nested class)
             belongs to the class rather than to instances of the class. It allows shared access to a single
            instance of the member across all objects of the class.


    2. What can be declared as static in Java?
          Static Variables: Class-level variables shared by all objects.As a result,
		static data members have the same value across all instances of the class.

          Static Methods: Methods that can be called without creating an instance of the class.
          Static Blocks: Blocks of code executed when the class is loaded.
         Static Nested Classes: Nested classes that do not require an instance of the enclosing class.


   3.What is the difference between a static variable and an instance variable?
        1.Static Variable:
            i>   Belongs to the class.
            ii>  Shared across all objects of the class.
            iii> Memory is allocated once, at class loading.

      2. Instance Variable:
            i>  Belongs to an individual object.
            ii> Each object has its own copy.
            ii> Memory is allocated when the object is created.

   4. Why can't we use this or super in a static context?
         this refers to the current instance of a class, and super refers to the parent class's instance.     
         Since static members belong to the class and not to any specific instance, this and super are
        not applicable in a static context.


    5.Can we override a static method in Java?
           No, static methods cannot be overridden because they belong to the class, not the instance. 
         However, you can declare a static method with the same name in a subclass, but this is called method hiding, not overriding.

 
    6. What happens if we access a static variable before it is initialized?
            Static variables are initialized to their default values (e.g., 0 for integers, null for objects, etc.) 
            when the class is loaded. You can access them even if you haven't explicitly initialized them.
 
    7. Can a constructor be declared static?
           No, a constructor cannot be declared static because it is always associated with an instance of the class,
           and the purpose of the static keyword is to associate a member with the class itself.


   8. What happens if a static variable is declared final?
             A static variable declared as final becomes a constant. It must be initialized at the time of
             declaration or within a static block, and its value cannot be changed after initialization.

                            e.g: static final int CONST = 10; 
                                 System.out.println(CONST); // Output: 10


    9. What is the difference between static import and regular import in Java?
         Static Import: Allows access to static members (fields or methods) of a class without qualifying them with the class name.
         Regular Import: Imports an entire class or package.

         import static java.lang.Math.*;  // Static import

         class Test {
                  public static void main(String[] args) {
                  System.out.println(sqrt(16));  // No need to use Math.sqrt()
                  }
             }

   10. If you declare a static variable inside a method, what will happen?
           A static variable cannot be declared inside a method because static variables belong to the class, 
            not to a specific method or instance. Attempting to declare one inside a method will result in a compilation error.

   11. Can a static method access non-static members?
           No, a static method cannot directly access non-static members because static methods do not have access
          to the instance (this) of the class. However, they can access non-static members via an instance of the class.


class Example {
    int instanceVariable = 42;  // Non-static variable
    static int staticVariable = 99;  // Static variable

    void instanceMethod() {  // Non-static method
        System.out.println("Inside instance method");
    }

    static void staticMethod() {  // Static method
        // Direct access to non-static members is NOT allowed
        // System.out.println(instanceVariable);  // Compilation Error
        
        // Accessing non-static members via an instance
        Example obj = new Example();
        System.out.println("Accessing instanceVariable via object: " + obj.instanceVariable);
        obj.instanceMethod();  // Calling instance method via object
    }

    public static void main(String[] args) {
        staticMethod();  // Calling static method
    }
}

o/p: Accessing instanceVariable via object: 42
     Inside instance method


//----------------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------------

	// Inner(Nested) classes in Java: 

	In Java, an inner class is a class defined within another class. Inner classes are primarily used to logically 
	group classes that will only be used in one place, increasing encapsulation and improving code readability.

	Types of Inner Classes in Java:
	- Nested Inner Class (Non-static Inner Class)
	- Static Nested Class
	- Method-Local Inner Class
	- Anonymous Inner Class

	// Nested Inner Class (Non-static Inner Class):  A non-static inner class is associated with an instance 
	   of the outer class and can access its members (including private members).
	

A non-static inner class is defined inside the Outer class.
It has access to all members of the Outer class, including private variables (x and y) and methods (show()).

class Outer 
{
	private int x=100;
	private static int y=100;
	void show()
	{
		System.out.println("Inside Outer Class");
	}
    	class Inner 
	{
        	void display() 
		{
			show();
            		System.out.println("Inside Non-static Inner Class");
            		System.out.println("x= "+x);
            		System.out.println("y= "+y);
        	}
   	}
}
class DemoInner
{
	public static void main(String []args)
	{
		Outer out = new Outer();
		out.show();

		Outer.Inner in = out.new Inner();       //This creates an object of the Inner class. Since the Inner class is non-static, 
                                                        it must be instantiated with respect to an object of the Outer class (out in this case).
		in.display();
	}
}

O/P:
Inside Outer Class
Inside Outer Class
Inside Non-static Inner Class
x= 100
y= 100


	// Note
	- If you want to create the object of inner class, first you need to create the object of outer class.
	  and using instance(object) of outer class, we need to use inner class.
	- Inner class having access to outer class member(methods and variables) directly, but 
	  vice-versa not possible.


//--------------------------------------------------

	// - Static Nested Class: A static nested class is associated with the outer class itself rather than an 
	     instance. It cannot directly access instance variables or methods of the outer class.

class Outer 
{
	private static int y=100;
    	static class Inner 
	{
        	void display() 
		{
            		System.out.println("Inside Non-static Inner Class");
            		System.out.println("y= "+y);
        	}
    	}
}
class DemoInner
{
	public static void main(String []args)
	{
		Outer.Inner in = new Outer.Inner();
		in.display();
	}
}

O/P:
Inside Non-static Inner Class
y= 100


	// Note
	- If you want to create the object of static inner class, you don't need object of outer class.
	  only outer class name is sufficient to access inner static-nested class.
	- Static inner class having access to only static members of outer class.
	- Non-static methods and instance variables of outer class can not be accessed directly.

//----------------

	// - Method-Local Inner Class: A method-local inner class is defined within a method and is only 
	     accessible within that method.

class Outer 
{
	void outerMethod() 
	{
        	class MethodInner 
		{
            		void display() 
			{
                		System.out.println("Inside Method-Local Inner Class");
            		}
        	}
        	MethodInner inner = new MethodInner();
        	inner.display();
    	}
	void anotherMethod()
	{
		MethodInner ob = new MethodInner(); // will generate error, coz member decl. 
	}					    // in a scope can be accessible with in only.
}

//----------------------

	// anonymous inner class: An anonymous inner class is a class without a name, typically 
				  used to override methods of an interface or superclass.


class Sample
{
	public void sayHi() {
		System.out.println("Hi From Sample");
	}
	public void sayHello() {
		System.out.println("Hello From Sample");
	}
	
}

class Test extends Sample {

	public void sayHello() {
		System.out.println("Hello From Test");
	}
}

class MainClassAIC
{
	public static void main(String []args) {

		Sample ob1 = new Sample();
		ob1.sayHi();
		ob1.sayHello();

		System.out.println("\n ---------------------------");

		Test ob2 = new Test();
		ob2.sayHi();
		ob2.sayHello();

		System.out.println("\n ---------------------------");

		Sample ob3 = new Sample() {
			int z=100;
			public void sayHello() {
				System.out.println("Hello From No-Name");
			}
		};
		ob3.sayHi();
		ob3.sayHello();
	}
}

o/p: 

Hi From Sample
Hello From Sample

 ---------------------------
Hi From Sample
Hello From Test

 ---------------------------
Hi From Sample
Hello From No-Name


//--------------------------------------------------------------------------------------------------------------
//--------------------------------------------------------------------------------------------------------------

	
	 // Using this keyword: 



		In Java, the this keyword is a reference to the current object within a class. It is 
		commonly used in methods, constructors, and inner classes to distinguish between instance 
		variables and parameters or to call other constructors or methods within the same class.



            1> Refers to the Current Object: The this keyword always refers to the current instance of the class.
            2> Cannot Be Used in Static Context: Static methods or variables do not belong to any specific object, 
                                                so this cannot be used in static methods or blocks.
            3> Cannot Be Assigned: The this reference is immutable; it always refers to the current object.


		Here are some common uses

	 1. Returning the Current Object: 'this' always refers to invoking object(object
	    on which method is called). Some times we need to return it from method defined within same class
	    in that case 'this' used as shown below..!!


import java.util.Scanner;
class Person
{
	private int id;
	private String name;
	private int age;
	private double salary;
	public void setData()
	{
		Scanner sc = new Scanner(System.in);

		System.out.println("Enter the Name: ");
		name = sc.nextLine();

		System.out.println("Enter the ID: ");
		id = sc.nextInt();

		System.out.println("Enter the Age: ");
		age = sc.nextInt();

		System.out.println("Enter the Salary: ");
		salary = sc.nextDouble();
	}
	public void showData()
	{
		System.out.print("\n ID: "+id+"\t Name: "+name+"\t Age: "+age+"\t Salary: "+salary);
	}
	public Person findElder(Person x)
	{
		if(x.age>age)
			return x;
		else 
			return this;
	}
}
class ThisExample 
{
	public static void main(String[] args) 
	{
		Person p1 = new Person();
		p1.setData();

		Person p2 = new Person();
		p2.setData();

		System.out.println("\n Person List");
		p1.showData();
		p2.showData();

		Person t = p1.findElder(p2);		
		System.out.println("\n Elder Person ");
		t.showData();
	}
}
Enter the Name:
sai
Enter the ID:
11
Enter the Age:
56
Enter the Salary:
32333
Enter the Name:
ram
Enter the ID:
22
Enter the Age:
34
Enter the Salary:
42323

 Person List

 ID: 11  Name: sai       Age: 56         Salary: 32333.0
 ID: 22  Name: ram       Age: 34         Salary: 42323.0
 Elder Person

 ID: 11  Name: sai       Age: 56 

//------------------------------------------------------------------



	 2. Referring to Instance Variables: When method or constructor parameters have the same name as instance 
	 variables, this helps differentiate between the two.

import java.util.Scanner;
class Person
{
	private int id;
	private String name;
	private int age;
	private double salary;
	public Person()
	{
		id = -1;
		name = "NA";
		this.age = -1;
		this.salary = -1.0;
	}
	public Person(int id, String name, int age, double salary)
	{
		this.id = id;
		this.name = name;
		this.age = age;
		this.salary = salary;
	}
	public void setData()
	{
		Scanner sc = new Scanner(System.in);

		System.out.println("\n Enter the Name: ");
		name = sc.nextLine();

		System.out.println("Enter the ID: ");
		id = sc.nextInt();

		System.out.println("Enter the Age: ");
		age = sc.nextInt();

		System.out.println("Enter the Salary: ");
		salary = sc.nextDouble();
	}
	public void setData(int id, String name, int age, double salary)
	{
		this.id = id;
		this.name = name;
		this.age = age;
		this.salary = salary;
	}
	public void showData()
	{
		System.out.print("\n\n ID: "+id+"\t Name: "+name+"\t Age: "+age+"\t Salary: "+salary);
	}
}
class ThisExample
{
	public static void main(String[] args) 
	{
		Person p1 = new Person();
		p1.showData();

		p1.setData();

		Person p2 = new Person();
		p2.setData(11,"Abhay",23,12.34);

		System.out.println("\n Person List");
		p1.showData();
		p2.showData();
	}
}


 ID: -1  Name: NA        Age: -1         Salary: -1.0
 Enter the Name:
ram
Enter the ID:
11
Enter the Age:
34
Enter the Salary:
233333

 Person List


 ID: 11  Name: ram       Age: 34         Salary: 233333.0

 ID: 11  Name: Abhay     Age: 23         Salary: 12.34

//------------------------------------------------------------------------


	3. Calling Another Constructor (Constructor Chaining): The this keyword can be used to call 
	   another constructor within the same class.

import java.util.Scanner;
class Person
{
	private int id;
	private String name;
	private int age;
	private double salary;
	public Person()
	{
		this(-1,"NA",-1,-1.0); // constructor chaining
	}
	public Person(int id, String name)
	{
		this(id,name,-1,-1.0); // constructor chaining
	}

	public Person(int id, String name, int age, double salary)
	{
		this.id = id;
		this.name = name;
		this.age = age;
		this.salary = salary;
	}
	
	public void setData(int id, String name, int age, double salary)
	{
		this.id = id;
		this.name = name;
		this.age = age;
		this.salary = salary;
	}

	public void showData()
	{
		System.out.print("\n\n ID: "+id+"\t Name: "+name+"\t Age: "+age+"\t Salary: "+salary);
	}
}
class ThisExample
{
	public static void main(String[] args) 
	{
		Person p1 = new Person();

		Person p2 = new Person(11,"Abhay");

		Person p3 = new Person();
		p3.setData(131,"Anand",43,52.34);

		System.out.println("\n Person List");
		p1.showData();
		p2.showData();
		p3.showData();
	}
}


Person List


 ID: -1  Name: NA        Age: -1         Salary: -1.0

 ID: 11  Name: Abhay     Age: -1         Salary: -1.0

 ID: 131         Name: Anand     Age: 43         Salary: 52.34

//----------------------------------------------------------------------------------


	4. Calling Current Class Methods: this can be used to explicitly call methods of the current object.

import java.util.Scanner;
class Person
{
	private int id;
	private String name;
	private int age;
	private double salary;
	public Person()
	{
		this(-1,"NA",-1,-1.0); // constructor chaining
	}
	public Person(int id, String name)
	{
		this(id,name,-1,-1.0); // constructor chaining
	}

	public Person(int id, String name, int age, double salary)
	{
		this.id = id;
		this.name = name;
		this.age = age;
		this.salary = salary;
	}
	
	public void setData(int id, String name, int age, double salary)
	{
		this.id = id;
		this.name = name;
		this.age = age;
		this.salary = salary;
	}

	public void showData()
	{
		System.out.print("\n\n ID: "+id+"\t Name: "+name+"\t Age: "+age+"\t Salary: "+salary);
		System.out.print(" - Status: "+this.isWorking(this.salary));
	}
	private String isWorking(double sal)
	{
		if(sal>0)
			return "Working";
		else
			return "Not Working";
	}
}
class ThisExample
{
	public static void main(String[] args) 
	{
		Person p1 = new Person();

		Person p2 = new Person(11,"Abhay");

		Person p3 = new Person();
		p3.setData(131,"Anand",43,52.34);

		System.out.println("\n Person List");
		p1.showData();
		p2.showData();
		p3.showData();
	}
}


 Person List


 ID: -1  Name: NA        Age: -1         Salary: -1.0 - Status: Not Working

 ID: 11  Name: Abhay     Age: -1         Salary: -1.0 - Status: Not Working

 ID: 131         Name: Anand     Age: 43         Salary: 52.34 - Status: Working



//-----------------------------------------------------------------------------------------------------------------

	// 5. Passing the Current Object as a Parameter: The this keyword can be passed as an argument to 
	      methods or constructors.

import java.util.Scanner;
class Person
{
	private int id;
	private String name;
	private int age;
	private double salary;
	public Person()
	{
		this(-1,"NA",-1,-1.0); 
	}
	public Person(int id, String name)
	{
		this(id,name,-1,-1.0); 
	}

	public Person(int id, String name, int age, double salary)
	{
		this.id = id;
		this.name = name;
		this.age = age;
		this.salary = salary;
	}
	
	public void setData(int id, String name, int age, double salary)
	{
		this.id = id;
		this.name = name;
		this.age = age;
		this.salary = salary;
	}

	public void showData()
	{
		if(isWorking(this)) // display if working
			System.out.print("\n\n ID: "+id+"\t Name: "+name+"\t Age: "+age+"\t Salary: "+salary);
	}
	private boolean isWorking(Person p)
	{
		if(p.salary>0)
			return true;
		else
			return false;
	}
}
class ThisExample
{
	public static void main(String[] args) 
	{
		Person p1 = new Person();

		Person p2 = new Person(11,"Abhay");

		Person p3 = new Person();
		p3.setData(131,"Anand",43,52.34);

		System.out.println("\n Person List");
		p1.showData();
		p2.showData();
		p3.showData();
	}
}


 Person List


 ID: 131         Name: Anand     Age: 43         Salary: 52.34P


------------------------------------------------------------------------

   Question on this Keyword?

        1. What are the common uses of the this keyword in Java?
               Referring to the current object's fields when there is a name conflict with local variables.
               Invoking the current object's method.
               Calling one constructor from another constructor in the same class (this()).
               Passing the current object as an argument to a method or constructor.
               Returning the current object.


     2. How does the this keyword resolve name conflicts between instance variables and local variables?
                  If a method or constructor parameter has the same name as an instance variable, the this keyword is
                  used to differentiate the instance variable from the local variable.

       e.g. 
                      class Example {
                            int value;

                           Example(int value) {
                                this.value = value; // Resolving conflict
                         }
                       }


    3. Can you return this from a method?
            Yes, you can return this from a method. This is often used in method chaining.

             class Example {
    Example display() {
        System.out.println("Method called");
        return this;
    }
}


    4. How is the this keyword used in method chaining?
                 this is returned from methods to allow multiple method calls on the same object in a single statement.
          
            class Example {
    Example method1() {
        System.out.println("Method 1");
        return this;
    }

    Example method2() {
        System.out.println("Method 2");
        return this;
    }
}

public class Main {
    public static void main(String[] args) {
        Example example = new Example();
        example.method1().method2(); // Method chaining
    }
}
 o/p:
Method 1
Method 2


       5.  Can the this keyword be used in a static nested class?
                  No, this cannot be used in a static nested class because it is not associated with an instance of the enclosing class.


      6. Explain a real-world example where this is useful.
                Consider a class Employee where the constructor has parameters with the same name as instance variables.
                 Using this ensures proper initialization:

 class Employee {
    String name;
    int id;

    Employee(String name, int id) {
        this.name = name; // Refers to instance variable
        this.id = id;     // Refers to instance variable
    }
}

 
        7. If this is used in a setter method like setValue(int value) and is returned, how would method chaining work?
                   Method chaining allows multiple setter calls in a single line
class Person {
    String name;
    int age;

    Person setName(String name) {
        this.name = name;
        return this; // Return current object
    }

    Person setAge(int age) {
        this.age = age;
        return this; // Return current object
    }
}

public static void main(String[] args) {
    Person person = new Person();
    person.setName("Alice").setAge(30); // Method chaining
}



  
       8. Why does the this keyword need to be the first statement when calling another constructor?
                  Constructor chaining ensures that the initialization process is controlled and avoids partial initialization. 
                 Allowing this() later in the constructor could cause inconsistent or undefined behavior.


     9. Can this be used to refer to an overridden method in the current class?
                Yes, you can use this.methodName() to call a method in the current class, even if it overrides a method in the parent class.



//=====================================================================================================================

	
		// Forming the Class Relationship -  Inheritance and Association


		    Inheritance 				   Association

			IS-A					      HAS-A	

			person				  Engine		Music Player		
			  |				    |			   |		 
		---------------------			    |______________________|	
		|	 |	    |			Strong bonding 	|  weak bonding
	    Trainer   Student    Driver			 Composition     Car  Aggregation

				  		 
				CPP Code just for example

	class person						class Engine
	{							{
	};							};
	class Trainer : public person				class MusicPlayer
	{							{
	};							};
	class Student : public person				class Car
	{							{
	};								Engine ob1;
	class Driver: public person					MusicPlayer ob2;
	{							};
	};

                     | |					  | |
		      V					     	   V
  		Inheritance				 	Association




	- Inheritance: Inheritance is a mechanism where one class (called the child class or subclass) derives 
	  properties and behavior (fields and methods) from another class (called the parent class or superclass). 
	  It promotes code reusability and establishes a relationship like "is-a."

	-  Association: Association is a relationship between two classes that establishes a connection.

	Types of Association:
	 - Aggregation: A weak association where one object can exist independently of the other.(music player in car)
	 - Composition: A strong association where one object cannot exist independently of the other.(engine in car)

	// Inheritance

            /// Inheritance: It is act of defining the new class using the pre-defined classes.
                             It will provide the the next level of reusability.

    consider the example, in normal case,

    class employee              class student           class Teacher           class Driver
    {                           {                       {                       {
        char name[50];              char name[50];         char name[50];           char name[50];
        int age;                    int age;                int age;                int age;
        -----------;                -----------;            -----------;            -----------;
        -----------;                -----------;            -----------;            -----------;
        -----------;                -----------;            -----------;            -----------;
        -----------;                -----------;            -----------;            -----------;
    };                          };                      };                      };



    some elements are there in each class, and every class having code related to IO of those
    member, which is code repetition and can be avoided using the class inheritance as


    /// syntax of inheritance

    class <base/super/parent_class>
    {
        ........;
    };
    class <derived/sub/child_class> extends <base_class_nm>
    {
        --------;
        --------;
    };

        e.g.

        class person
        {
            char name[50];
            int age;
            --------------;
            --------------;
            --------------;
        };


class employee extends person  class student extends person  class Teacher extends person  class Driver extends person
{                               {                            {                              {
    -----------;                      -----------;                   -----------;                 -----------;
    -----------;                      -----------;                   -----------;                  -----------;
    -----------;                      -----------;                   -----------;                  -----------;
};                              };                            };                           };


///--------------------------------------------------------------------------------------------

///--------------------------------------------------------------------------------------------

        /// Types of Inheritance: In C++ we have seen following inheritances


            single          Multi-level          hierarchical        Multiple         Hybrid
          Inheritance       Inheritance           Inheritance       Inheritance     Inheritance

             [   ] A            [     ]  A             [ ] A           A       B       [ ]A                  A
               |                   |                    |              [ ]     [ ]      |                   [ ]
               |                [     ]  B        --------------        |_______|      [ ] B                 |
               V                   |              |            |             |          |         D     -------------
             [   ]  B           [     ]  C       [ ]B         [ ]c          [ ]        [ ] C     [ ]    |           |
                                                  |            |             C          |         |    [ ] B       [ ] C
                                              ---------      ---------                 [ ] -------|     |___________|
                                              |        |     |   |    |                 Z                     |
                                             [ ]      [ ]   [ ] [ ]  [ ]                                     [ ]
                                              D        E     F   G    H                                       D

    - single Inheritance:   One to one relationship, two layers
    - Multi-level Inheritance: one to one relationship, more than two layers
    - hierarchical Inheritance: One to many relationship
    - Multiple Inheritance: many to one relationship
    - Hybrid Inheritance: combinations of any two or more inheritance

	In Java, There are only three inheritances i.e. 

	- single Inheritance
	- multilevel Inheritance 
	- hierarchical Inheritance.

	*Note: multiple and Hybrid inheritances are not present in java.
	

	- Single inheritance: 
	  Single inheritance in Java is a concept where a class inherits from one and only one parent (or superclass). 
	  It allows a child class to acquire the properties and methods of a single parent class, promoting code
	  reusability and a hierarchical relationship.

// Parent class
class Animal {
    void eat() {
        System.out.println("This animal eats food.");
    }
}

// Child class
class Dog extends Animal {
    void bark() {
        System.out.println("The dog barks.");
    }
}

// Child class
class Human extends Animal {
    void speak() {
        System.out.println("The human speaks.");
    }
}

// Main class
public class MainSingleInh {
    public static void main(String[] args) {
        Dog dob = new Dog();
        dob.eat(); // Inherited from the Animal class
        dob.bark(); // Defined in the Dog class

        Human hob = new Human();
        hob.eat(); // Inherited from the Animal class
        hob.speak(); // Defined in the Dog class
    }
}

This animal eats food.
The dog barks.
This animal eats food.
The human speaks.

//------------------------------


	// Accessing members of base class with different visibility.

class Base
{
	private int x=11;
	protected int y=22;
	int z=33;    // default visibility
	public int t=44;
	// and some methods
}
class Derived extends Base
{
	public void display()
	{
		// System.out.println("\n x="+x);
		System.out.println("\n y="+y);
		System.out.println("\n z="+z);
		System.out.println("\n t="+t);
	}
}

class MainAccessSingle
{
	public static void main(String []args)
	{
		Derived ob = new Derived();
		ob.display();

		// System.out.println("\n x="+ob.x);
		System.out.println("\n y="+ob.y);
		System.out.println("\n z="+ob.z);
		System.out.println("\n t="+ob.t);
	}
}


------------ On Compile ----------------
MainAccessSingle.java:13: error: x has private access in Base
                System.out.println("\n x="+x);
                                           ^
1 error
Press any key to continue . . .

 -> which means that only private members are not inheritable.

 // After commenting above and accessing using . opertator

MainAccessSingle.java:27: error: x has private access in Base
                System.out.println("\n x="+ob.x);
                                             ^
1 error
Press any key to continue . . .

 -> which means that only private member not inheritable using . operator directly.

	// Note:
		- The extends keyword is used to establish the inheritance relationship.
		- The child class can access all non-private members (fields and methods) of the parent class.


//----------------------------------------------

	// Overloading and Overriding in the single inheritance.

	- Overloading:
	  Overloading occurs when two or more methods in the same class (or in a child class) have the same 
	  name but different parameter lists (number, type, or order of parameters). It is an example of 
	  compile-time polymorphism.

	- Key Points of Overloading:
		- Happens within the same class.
		- Methods must have the same name but different parameter lists.
		- Return type may or may not be different.
		- Resolved at compile time.


class Calculator {
    // Method 1: Adding two numbers
    int add(int a, int b) {
        return a + b;
    }

    // Method 2: Adding three numbers (overloading)
    int add(int a, int b, int c) {
        return a + b + c;
    }
}

public class MainOverloading {
    public static void main(String[] args) {
        Calculator calc = new Calculator();
        System.out.println(calc.add(5, 10)); // Calls the first add method
        System.out.println(calc.add(5, 10, 15)); // Calls the second add method
    }
}


//---------------------------------------------------------

	- Overriding:

	  Overriding occurs when a child class provides its own implementation of a method that is already 
	  defined in the parent class. It is an example of runtime polymorphism.

	- Key Points of Overriding:
		 - Happens between parent and child classes.
		 - Method signature (name, parameters, and return type) must be exactly the same.
		 - Resolved at runtime (dynamic method dispatch).
		 - The access modifier of the overriding method must be the same or more permissive 
		   than the method in the parent class.

class Animal {
    void sound() {
        System.out.println("Some generic animal sound.");
    }
}

class Dog extends Animal {
    // Overriding the sound method of the parent class
    void sound() {
        System.out.println("The dog barks.");
    }
}

public class MainOverriding {
    public static void main(String[] args) {
        Animal myAnimal = new Animal();
        myAnimal.sound(); // Calls the parent class method

        Dog myDog = new Dog();
        myDog.sound(); // Calls the overridden method in the child class
    }
}


	// Accessing the Overridden methods 

	In Java, when a method is overridden, the subclass version is called by default. However, if you want to 
	access the overridden method from the parent class in the subclass, you can use the super keyword. 
	This is useful when you want to extend the behavior of the parent class's method rather than 
	completely replacing

class Animal {
    void sound() {
        System.out.println("Some generic animal sound.");
    }
}

class Dog extends Animal {
    // Overriding the sound method of the parent class
    void sound() {
		super.sound();
        System.out.println("The dog barks.");
    }
}

public class MainOverriding {
    public static void main(String[] args) {

        Animal myAnimal = new Animal();
        myAnimal.sound(); // Calls the parent class method

	System.out.println("\n ---------------------- ");

        Dog myDog = new Dog();
        myDog.sound(); // Calls the overridden method in the child class
    }
}

Some generic animal sound.

 ----------------------

Some generic animal sound.
The dog barks.


//------------------------------------------------------------------------------------------

	// Defining the constructors in inheritance

	In Java, When we write the constructors in base and child class, 
	- if we create the base class object, only base class constructor will be executed.
	- if we create an object of child class, then first base class constructor and then child
	  class constructor will be executed. again it confirms that memory is allocated for both 
	  child and base classes.
	- By default default constructors of both classes are executed.
	- If we invoke the parameterized constructor of child class, then at start it will invoke the 
	  default constructor of base class and then parameterized constructor of child.

	So we need to use super keyword to invoke the parameterized constructor of base class.


package com.archer.inhex;
class Person {

	//	fields
	private int uid;
	private String name;

	//	Constructors
	public Person() {
		uid = 0;
		name = "No Name";
	}

	public Person(int uid, String name) {
		super();
		this.uid = uid;
		this.name = name;
	}
	
	// setter and getter methods
	public int getUid() {
		return uid;
	}
	public void setUid(int uid) {
		this.uid = uid;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
}

class Student extends Person {
	// fields
	private int rno;
	private double per;
	
	// Constructors
	public Student() {
		rno = 0;
		per = 0.0;
	}
	
	public Student(int uid, String name, int rno, double per) {
		super(uid, name); // calls the para. constructor of base(super) class
		this.rno = rno;
		this.per = per;
	}
	
	public Student(int rno, double per) {
		this.rno = rno;
		this.per = per;
	}

	// setter and getter methods
	public int getRno() {
		return rno;
	}
	public void setRno(int rno) {
		this.rno = rno;
	}
	public double getPer() {
		return per;
	}
	public void setPer(double per) {
		this.per = per;
	}
}
public class MainClassSingleInh {

	public static void main(String[] args) {
		
		// Creating Object Using Setter and Getter methods
		Student s1 = new Student();
		s1.setName("Amol");
		s1.setUid(12345);
		s1.setRno(12);
		s1.setPer(78.45);
		System.out.println("Name: "+s1.getName()+"\t UID: "+s1.getUid()+"\t RNO: "+s1.getRno()+"\t Marks: "+s1.getPer()+"%");

		System.out.println("\n -------------------------------------------- ");
		
		// Creating the Object using the default Constructor
		Student s2 = new Student();
		System.out.println("Name: "+s2.getName()+"\t UID: "+s2.getUid()+"\t RNO: "+s2.getRno()+"\t Marks: "+s2.getPer()+"%");

		System.out.println("\n -------------------------------------------- ");
				
		// Creating the Object using the default Constructor
		Student s3 = new Student(15, 98.23); 
		// here the parameterized constructor of child class Student is invoked, and automatically it will invoke the default constructor of base class.
		System.out.println("Name: "+s3.getName()+"\t UID: "+s3.getUid()+"\t RNO: "+s3.getRno()+"\t Marks: "+s3.getPer()+"%");
		
		System.out.println("\n -------------------------------------------- ");
		
		// to invoke the base class we need to pass the arguments first.
		Student s4 = new Student(495867,"Uday",15,98.23); 
		System.out.println("Name: "+s4.getName()+"\t UID: "+s4.getUid()+"\t RNO: "+s4.getRno()+"\t Marks: "+s4.getPer()+"%");
		
	}

}
---------------------------------------------------------------------

     Questions on Inheritance and Association


      1.1  What is the extends keyword in Java?
              The extends keyword is used to inherit a class.

      1.2 What are the advantages of inheritance?

       1> Code reusability: 
         -Inheritance enables you to reuse the code written in a parent class, reducing duplication and improving maintainability.
         -A child class can automatically access all non-private properties and methods of the parent class without rewriting them.
         -By creating generic parent classes, you can define common behavior or attributes for related classes,
          which are then reused by subclasses.

      2> Easy maintenance and scalability:
          - If changes are required in common behavior or properties, you can make updates in the parent class, 
               and all subclasses automatically inherit those changes.
          - As the system grows, you can add more subclasses to extend the functionality without modifying the existing code.


      3> Enables method overriding for polymorphism:
          - As the system grows, you can add more subclasses to extend the functionality without modifying the existing code. 
          - Subclasses can provide a specific implementation of a method already defined in the parent class, 
               allowing different behaviors for different types of objects using the same method call.
         - This is particularly useful in dynamic systems where the exact behavior of an object depends on its runtime type.



      1. Why does Java not support multiple inheritance with classes?
                Java does not support multiple inheritance with classes to avoid the Diamond Problem, where ambiguity 
                 arises if two parent classes have methods with the same name.
   
     2. What is the super keyword in inheritance?
             The super keyword is used to refer to the parent class's members (variables, methods, or constructors) from the child class.


    3. What happens if a constructor is not explicitly defined in a subclass?
              If no constructor is defined, the Java compiler inserts a default constructor that implicitly calls 
             the parent's no-argument constructor.


    4. What is the difference between method overloading and method overriding in Java?
            Overloading: Same method name but different parameters in the same class.
            Overriding: Redefining a parent class method in the child class with the same signature.


    5. What is the use of the final keyword in inheritance?
          final with a class: Prevents inheritance of the class.
          final with a method: Prevents method overriding.
          final with a variable: Prevents the reassignment of the variable.

 
    6. What is the purpose of the instanceof operator in inheritance?
            The instanceof operator checks whether an object is an instance of a specific class or a subclass of that class.


     7. Can a subclass inherit private members of the superclass?
          - No, private members are not accessible directly in the subclass. However, they can be accessed through 
                public or protected methods in the parent class.
          - To access private members, the parent class can provide public or protected getter/setter methods
                 or any other public/protected method.
          - These methods allow controlled access to private members.



     8. What is the difference between interface inheritance and class inheritance?
              Class inheritance: Uses the extends keyword, inherits implementation and members.
             Interface inheritance: Uses the implements keyword, and a class must implement all abstract methods of the interface.


//------------------------------------------------------------------------------------------------------------
	
        // Using the 'super' Keyword

	The super keyword in Java is a powerful tool used within a subclass to directly refer to its immediate parent 
	class. It is primarily used to access parent class members (constructors, methods, or fields) that are overridden 
	or hidden by the subclass. 
         - The super keyword refers to the immediate parent class object.
         - It is used to access the parent class's methods, constructors, or variables.


    q. What are the main uses of the super keyword in Java?

           1> Using super to Call Overridden Parent Class Methods in child class.

           2> Using super to Access Overridden Parent Class Fields in child class.

           3> Call the parent class constructor.

     

	1. Using super to Call Overridden Parent Class Methods in child class.
	   When a subclass overrides a method from the parent class, the super keyword can be used to call the original 
	   method from the parent class. This is particularly useful when you want to reuse the parent class's logic 
	   while extending or modifying its behavior in the subclass.

	2. Using super to Access Overridden Parent Class Fields in child class.
	   If a subclass declares a field with the same name as a field in the parent class, the subclass's field hides 
	   the parent class's field. You can use super to access the hidden field in the parent class.

class Parent {
    String name = "Parent";
}

class Child extends Parent {
    String name = "Child";

    void printNames() {
        System.out.println("Name in Child: " + name);
        System.out.println("Name in Parent: " + super.name);
    }
}

public class MainSuper {
    public static void main(String[] args) {
        Child child = new Child();
        child.printNames();
    }
}
Name in Child: Child
Name in Parent: Parent


	3. Using super to Call Parent Class Constructors
	   You can use super() to call the parent class's constructor. This is often done to initialize the parent 
	   class fields with parameters passed via child class constructor.


	Rules and Notes:
	 - First Statement in Constructor: When used in a constructor, super() must be the first statement.
	   If you don't explicitly call super(), Java inserts a default super() call (to the no-argument constructor 
	   of the parent).

	- Only Immediate Parent: super always refers to the immediate parent class. It cannot access methods, fields, 
	  or constructors of ancestors beyond the immediate parent.

	- Access Modifiers: super respects Java's access control rules (e.g., private members of the parent class cannot 
	  be accessed using super).

	- No super in Static Contexts: super cannot be used in static methods or blocks because it depends on an instance.

//--------------------

	Are the constructors inheritable?

	No, constructors are not inheritable in Java. This is because constructors are not part of an object's
	instance or class; instead, they are special methods used for initializing an object when it is created. 
	Each class in Java must define its own constructors, even if it is a subclass.

	Can we override the constructor?

	No, constructors cannot be overridden in Java. This is because constructors are not inherited by subclasses, 
	which is a prerequisite for overriding a method. However, constructors can be overloaded within the same class.

---------------------------------------------------------------

   questions on Super Keyword in java.

   1.  What happens if the super() constructor is not explicitly written in a child class constructor?
             The Java compiler automatically inserts a call to the no-argument constructor of the parent class.
             If the parent class does not have a no-argument constructor, a compile-time error occurs.

  class Parent {
    Parent(String message) {
        System.out.println("Parent's parameterized constructor: " + message);
    }
}

class Child extends Parent {
    Child() {
        System.out.println("Child's constructor called.");
    }
}

public class Main {
    public static void main(String[] args) {
        Child child = new Child();      // Compile-time error!  because no default constructor
    }
}

       1.1 What happens if super() is used in a constructor and the parent class has no no-argument constructor?
                 If the parent class does not have a no-argument constructor, you must explicitly call a parameterized 
                 constructor of the parent class using super(arguments); otherwise, a compile-time error occurs.

   class Parent {
    Parent(String message) {
        System.out.println("Parent's parameterized constructor: " + message);
    }
}

class Child extends Parent {
    Child() {
        super("Hello from Child"); // Explicit call to Parent's parameterized constructor
        System.out.println("Child's constructor called.");
    }
}

public class Main {
    public static void main(String[] args) {
        Child child = new Child();
    }
}

o/p:
Parent's parameterized constructor: Hello from Child
Child's constructor called.





           2. What is the difference between this and super in Java?
                  1> this refers to the current object,  1> while super refers to the immediate parent class object.
                  2> this can call the current class's methods or constructors, 2>while super is used to call 
                    parent class methods or constructors.


        
       3. Can you use super in static methods? Why or why not?
             No, super cannot be used in static methods because super refers to an instance of the parent class, 
              and static methods are not associated with any instance.


    4. . How does super help in method overriding?
               In method overriding, the super keyword allows access to the overridden method in the parent class, 
              enabling both the parent and child implementations to be used.

  class Parent {
    void display() {
        System.out.println("Parent display");
    }
}

class Child extends Parent {
    @Override
    void display() {
        System.out.println("Child display");
        super.display(); // Access parent method
    }
}

   5.  What is the role of super in multiple inheritance via interfaces?
            When multiple interfaces have the same default method, you can use InterfaceName.super.methodName() 
              to specify which interface's method to call.



     6. What is the difference between super.methodName() and this.methodName()?
             super.methodName() calls the method in the parent class, even if it is overridden in the child class.
             this.methodName() calls the method in the current class, which may override the parent class method.



//-----------------------------------------------------------------------------------------------------------------------

	// Using Final Keyword:

	In Java, the final keyword is a modifier that can be applied to variables, methods, and classes. 
	It serves different purposes depending on where it is used.


	1. Final Variables: A variable declared as final cannot have its value reassigned after it has 
			    been initialized. It makes the variable constant.

	Rules for Final Variables:

	- If the variable is a primitive type, its value cannot be changed after initialization.
	- If the variable is a reference type (like an object or array), the reference cannot be 
	  changed, but the object's state(like values of fields) can be modified.


	public class FinalVariableExample {
    		final int CONSTANT = 100;  // Initialized during declaration
    		final int anotherConstant;
    
		FinalVariableExample() {
        		anotherConstant = 200;  // Initialized in the constructor
    	}

    public static void main(String[] args) {
       
	FinalVariableExample example = new FinalVariableExample();
        System.out.println(example.CONSTANT);
        System.out.println(example.anotherConstant);

        // example.CONSTANT = 300; // Error: Cannot assign a value to a final variable
		// example.anotherConstant = 400; // Error: Cannot assign a value to a final variable
    }
}

	Note: 
	     - Once you initilize, Value of final variable can not be altered, Even using constructor, 
	       when it is assigned already.
	     - Constructor allows to initilize, only when it is not assined in decleration.

//---------------------------

class Demo
{
	private int x;
	public Demo() {
		x=10;
	}
	public Demo(int t) {
		x=t;
	}
	public void setx() {
		x=1000;
	}
	public void show() {
		System.out.println("x="+x);
	}
}
class FinalVariableExample1 
{
	public static void main(String[] args) 
	{
		final Demo ob1 = new Demo(100);
		Demo ob2 = new Demo(200);
		
		ob1.show();
		ob2.show();

		//ob1=ob2;	// error: cannot assign a value to final variable ob1
		// the reference cannot be changed coz ob1 is final

		ob1.setx(); // evenif ob1 is final as we are not changing the reference, it will allow
			    // to change the values of fields.
		ob1.show();
	}
}

---------------------

	2. Final Methods: A method declared as final cannot be overridden by subclasses. This is useful 
			when you want to prevent a specific behavior from being modified in child classes.


class Base {
	final public void message() {
		System.out.println("In the Base Class");
	}
}
class Child extends Base {
	public void message() { // error: message() in Child cannot override message() in Base overridden method is final
		System.out.println("In the Child Class");
	}
}
class FinalMethodExample
{
	public static void main(String[] args) 
	{
		Child ob = new Child();
		ob.message();
	}
}

//------------------------------------------

	3. Final Classes: A class declared as final cannot be extended. This is useful for creating immutable 
			  classes or when you want to prevent inheritance.

final class FinalClass {
    void display() {
        System.out.println("This is a final class.");
    }
}

// class SubClass extends FinalClass { 
//     // Error: Cannot inherit from final class
// }

public class FinalClassExample {
    public static void main(String[] args) {
        FinalClass obj = new FinalClass();
        obj.display();
    }
}

//----------------------------------------


4. Final Parameters:
When a parameter is declared as final in a method, it means that 
the value of the parameter cannot be changed within the method.


class Demo
{
	private int x;
	public void in(final int t)
	{
		t=78; // error: final parameter t may not be assigned
		x=t;
	}
	public void show()
	{
		System.out.println("\n x="+x);
	}
}
class DemoFinalParameter
{
	public static void main(String []args)
	{
		Demo ob=new Demo();
		ob.in(100);
		ob.show();
	}
}

Output (Error on Compie)

DemoFinalParameter.java:114: error: final parameter t may not be assigned
                t=78;
                ^
1 error
Press any key to continue . . .

//------------------------------------------

	// Passing the mutable and immutable objects 

	- When we pass the refence of an object which is mutable. then it will allows to modify the contents
	  of actual location, it will keep doing same, even if the are decl. as final while collecting as a
	  a formal arguments, coz in that case reference modification will not attempted.

	- Even though the reference is fixed, the object's internal state (its fields or elements) can still be 
	  modified, provided the object itself is mutable (not declared final for fields or does not contain 
	  immutable fields).

	- When we pass the refence of an object which is immutable, and you try to change the original locations,
	  then as the original location is immutable, the newly assigned data stored in the memory and the formal
	  arguments start referring to that new location.(Implicitly reference modification is attempted) 

	- To avoid such reference modification in case of immutable object the final keyword is used.

	- The object's state, such as fields or array elements, can still be modified as long as the object is mutable.

class DemoRefPass 
{
	public static void fun(String s3, String s4)
	{
		s3="good day";
		s4="bye bye";
	}
	public static void main(String[] args) 
	{
		String s1="Hi";
		String s2="Hello";
		System.out.println("Before Call: s1 - "+s1+"\t s2 - "+s2);
		fun(s1,s2);
		System.out.println("After Call: s1 - "+s1+"\t s2 - "+s2);
	}
}

Before Call: s1 - Hi     s2 - Hello
After Call: s1 - Hi      s2 - Hello

 It will gives like output same as that of(or like) "By Value", due to String Object is immutable.

	// To avoid it, use final

class DemoRefPassImmutable
{
	public static void fun(final String s3, final String s4)
	{
		s3="good day";
		s4="bye bye";
	}
	public static void main(String[] args) 
	{
		String s1="Hi";
		String s2="Hello";
		System.out.println("Before Call: s1 - "+s1+"\t s2 - "+s2);
		fun(s1,s2);
		System.out.println("After Call: s1 - "+s1+"\t s2 - "+s2);
	}
}

 //------- on compile ----------

DemoRefPassImmutable.java:5: error: final parameter s3 may not be assigned
                s3="good day";
                ^
DemoRefPassImmutable.java:6: error: final parameter s4 may not be assigned
                s4="bye bye";
                ^
2 errors
Press any key to continue . . .

//-----------------------------------------

	// Passing mutable object

class Num
{
	private int x;
	public void setX( int x) {
		this.x = x;
	}
	public int getX() {
		return x;
	}
}
class DemoRefPassMutable
{
	public static void fun(final Num ob3, final Num ob4)  // absence of final will gives same output
	{
		ob3.setX(1000);
		ob4.setX(2000);
	}
	public static void main(String[] args) 
	{
		Num ob1 = new Num();
		Num ob2 = new Num();
		ob1.setX(10);
		ob2.setX(20);
		System.out.println("Before Call: ob1 - "+ob1.getX()+"\t ob2 - "+ob2.getX());
		fun(ob1,ob2);
		System.out.println("Before Call: ob1 - "+ob1.getX()+"\t ob2 - "+ob2.getX());
	}
}


Before Call: ob1 - 10    ob2 - 20
Before Call: ob1 - 1000  ob2 - 2000

//-------------------------

	// Note to Remember

	- Private members are not inheritable.

class Sample
{
	private int x;
	public float y;
	double z;
	protected char ch;
}
class Test extends Sample
{
	public Test()
	{
		x=100; // error: x has private access in Sample
		y=3.4F;
		z=45.23;
		ch='w';
	}
}
class DemoTestAccess
{
	public static void main(String[] args) 
	{
		Test ob = new Test();
	}
}

--------------------------------------------------------------------------

      Interview questions on Final Keyword in java

     1.  What happens if a final variable is not initialized? 
              A final variable must be initialized at the time of declaration or in the constructor (for instance variables).


      2. Can a final variable be static?
               Yes, a final variable can be static. It is commonly used for defining constants.

                    class Example {
                          static final double PI = 3.14159;
                      }


       3.  What is the difference between final, finally, and finalize?

             final: -A keyword used to declare constants, prevent inheritance, or method overriding.
                    -A keyword used to restrict variables, methods, and classes.

             finally: A block in exception handling that executes regardless of whether an exception is thrown / occurs
                       
             finalize(): - A method called by the garbage collector before an object is destroyed (deprecated in modern Java).
                         - A method in the Object class used for garbage collection, allowing an object to clean up resources 
                           before being reclaimed by the JVM.


       4. Can a final variable be assigned a value later?
                  Yes, if it is a non-static instance variable, it can be assigned a value in the constructor.

                    class Example {
                           final int value;

                    Example(int value) {
                         this.value = value; // Initialized here
                                 }
                           }

      5. Can a final method be overloaded?
             Yes, overloading is allowed because it depends on method signatures (parameters), not inheritance.

 class Example {
    final void display() {
        System.out.println("Final method");
    }

    void display(int x) {
        System.out.println("Overloaded method");
    }
}


    6.  Can a final class have a constructor?
              Yes, a final class can have constructors, but it cannot be extended.


   6.1 Can we declare a constructor as final?
          No, constructors cannot be declared as final because they are never inherited, and final is used
          to restrict inheritance or overriding.



   7.  What is the behavior of a final reference variable?
             A final reference variable cannot point to another object after initialization, but the object it points to can be modified.
                      
final StringBuilder sb = new StringBuilder("Hello");
sb.append(" World"); // Allowed
sb = new StringBuilder("New"); // Compile-time error


    8. How is immutability achieved using the final keyword?
             By declaring a class final and making all its fields private final, you can ensure that the object's
             state cannot be modified after initialization.


   9. Can you make an abstract method final?
              No, because an abstract method must be overridden in a subclass, and a final method cannot be overridden.


   9.1 What happens if you declare an interface method as final?
          It is not allowed. By default, interface methods are abstract and cannot have the final modifier because 
          they must be overridden in implementing classes.


   10.What happens if a final field is not initialized?
             A compile-time error occurs if a final field is not initialized during declaration or in the constructor.


   11. What is the difference between final and static final?
            -A final variable belongs to an instance of the class and must be initialized individually for each object.
            - A static final variable is a constant shared across all instances of the class.


//---------------------------------------------------------------------------------------------------------------------


- Multilevel Inheritance:

		[ ] Person		in() and out()	
		 |				 
		 |				 
	  	[ ] Student		input() and output()
		 |
		 |
		[ ] Sport		set() and show()

import java.util.Scanner;
class Person
{
	private String nm="";
	private int age;
	public void in()
	{
		Scanner sc=new Scanner(System.in);
		System.out.println("\n Enter the name of person: ");
		nm=sc.nextLine();

		System.out.println("\n Enter the age of person: ");
		age=sc.nextInt();
	}
	public void out()
	{
		System.out.println("\n Name: "+nm+"\t age: "+age);
	}
}
class Student extends Person
{
	private int rno;
	private double per;
	protected void input()
	{
		//in();
		Scanner sc=new Scanner(System.in);
		System.out.println("\n Enter the rno of Student: ");
		rno=sc.nextInt();

		System.out.println("\n Enter the percentage of Student: ");
		per=sc.nextDouble();
	}
	public void output()
	{
		//out();
		System.out.println("\n RNO: "+rno+"\t Percentage: "+per);
	}
}
class Sport extends Student
{
	private int points;
	void set()
	{
		//in();
		//input();
		Scanner sc=new Scanner(System.in);
		System.out.println("\n Enter the grade points of Student: ");
		points=sc.nextInt();
	}
	public void show()
	{
		out();
		output();
		System.out.println("\n Points: "+points);
	}
}
class MainStudentMultilevel
{
	public static void main(String []args)
	{
		Sport s=new Sport();

		s.in();
		s.input();
		s.set();

		s.show();	
	}
}


 Enter the name of person:
ram

 Enter the age of person:
12

 Enter the rno of Student:
34

 Enter the percentage of Student:
89

 Enter the grade points of Student:
9

 Name: ram       age: 12

 RNO: 34         Percentage: 89.0

 Points: 9

//-------------------------------------------------------------------------------------------------

	/// Using the constructors in inheritance

class Base
{
	private int a;
	public Base()
	{
		System.out.println("\n In Base default");
		a=10;
	}
	public Base(int x)
	{
		System.out.println("\n In Base para");
		a=x;
	}
	public void showBase()
	{
		System.out.println("\n a="+a);
	}
}
class ImdBase extends Base
{
	private int b;
	public ImdBase()
	{
		System.out.println("\n In ImdBase default");
		b=20;
	}
	public ImdBase(int x, int y)
	{
		super(x);
		System.out.println("\n In ImdBase para");
		b=y;
	}
	public void showImdBase()
	{
		showBase();
		System.out.println("\n b="+b);
	}
}
class Derived extends ImdBase 
{
	private int c;
	public Derived()
	{
		System.out.println("\n In Derived default");
		c=30;
	}
	public Derived(int x, int y, int z)
	{
		super(x,y);
		System.out.println("\n In Derived para");
		c=z;
	}
	public void showDerived()
	{
		showImdBase();
		System.out.println("\n c="+c);
	}
}

class MainPassParamInh
{
	public static void main(String []args)
	{
		Derived ob1=new Derived();
		ob1.showDerived();

		Derived ob2=new Derived(100,200,300);
		ob2.showDerived();
	}
}



 In Base default

 In ImdBase default

 In Derived default

 a=10

 b=20

 c=30

 In Base para

 In ImdBase para

 In Derived para

 a=100

 b=200

 c=300
//---------------------------------------------------------------------------------------------------

	// initializer blocks

	In Java, initializer blocks are used to initialize instance variables or perform some setup operations when an 
	object of the class is created. These blocks are executed as part of the object creation process, and they can 
	be either instance initializer blocks or static initializer blocks, depending on their purpose.

	- Types:
		1. Instance Initializer Blocks
		2. Static Initializer Blocks


	// using Instance Initializer Blocks

		- Definition: Instance initializer blocks are enclosed in curly braces {} but are not part 
		  of any method.

		- Purpose: They are used to perform instance-level initialization that is common across all 
		 	   constructors of the class.

		- Execution: Runs before the constructor and after the memory for the object is allocated.

		- Order: Executed in the order they appear in the class definition, and they run after the 
			 superclass constructor and before the subclass constructor.


	// Example 

class Example {
    int x;

    {
        // Instance initializer block
        x = 10;
        System.out.println("Instance initializer block executed");
    }

    Example() {
        System.out.println("Constructor executed");
    }

    public static void main(String[] args) {
        Example obj = new Example();
        }
}

    Output:
        // Instance initializer block executed
        // Constructor executed


//-----------------------------

	// instace of multile init. blocks sequence in maintained while execution

class Example {
    int x;
    {
        // Instance initializer block
        x = 20;
        System.out.println("Instance initializer block executed-2");
    }

    {
        // Instance initializer block
        x = 10;
        System.out.println("Instance initializer block executed-1");
    }
    Example() {
        System.out.println("Constructor executed");
    }

    public static void main(String[] args) {
        Example obj = new Example();
       
    }
}

o/p:
Instance initializer block executed-2
Instance initializer block executed-1
Constructor executed
Press any key to continue . . .
//--------------------------

	/// Using the constructors and initializer blocks in inheritance

	When we use the constructor and initializer block within the class in any inheritance, the execution of 
	initblock-constructor starts from base and move towards child.

class Base
{
	private int a;
	{
		System.out.println("\n In Instance initializer block - Base");
	}
	public Base()
	{
		System.out.println("\n In Base default");
		a=10;
	}
	public Base(int x)
	{
		System.out.println("\n In Base para");
		a=x;
	}
	public void showBase()
	{
		System.out.println("\n a="+a);
	}
}
class ImdBase extends Base
{
	private int b;
	{
		System.out.println("\n In Instance init. block - ImdBase");
	}
	public ImdBase()
	{
		System.out.println("\n In ImdBase default");
		b=20;
	}
	public ImdBase(int x, int y)
	{
		super(x);
		System.out.println("\n In ImdBase para");
		b=y;
	}
	public void showImdBase()
	{
		showBase();
		System.out.println("\n b="+b);
	}
}
class Derived extends ImdBase 
{
	private int c;
	{
		System.out.println("\n In Instance init. block - Derived");
	}
	public Derived()
	{
		System.out.println("\n In Derived default");
		c=30;
	}
	public Derived(int x, int y, int z)
	{
		super(x,y);
		System.out.println("\n In Derived para");
		c=z;
	}
	public void showDerived()
	{
		showImdBase();
		System.out.println("\n c="+c);
	}
}

class MainPassParamInh
{
	public static void main(String []args)
	{
		Derived ob1=new Derived();
		ob1.showDerived();

		Derived ob2=new Derived(100,200,300);
		ob2.showDerived();
	}
}


 In Instance init. block - ImdBase

 In ImdBase default

 In Instance init. block - Derived

 In Derived default

 a=10

 b=20

 c=30

 In Instance initializer block - Base

 In Base para

 In Instance init. block - ImdBase

 In ImdBase para

 In Instance init. block - Derived

 In Derived para

 a=100

 b=200

 c=300

//------------------------------

// what is difference between constructor and initializer block?

	In Java, constructors and initializer blocks are mechanisms used to initialize objects, but they have different 
	purposes, syntax, and use cases. Here’s a detailed comparison:

	Constructor
	- A special method with the same name as the class.
	- Invoked explicitly when an object is created using new.
	- Can be overloaded (multiple constructors with different parameter lists).
	- Executes after all initializer blocks (if present).
	- Used for object-specific initialization.
	- Cannot be static.
        - Can accept parameters.
        - Constructors can call the parent class constructor using super().

	Initializer Block
	- A block of code within braces {} that runs automatically when an object is created.
	- Executes before the constructor.
	- Cannot be overloaded; there is only one initializer block per class (though multiple blocks can exist and execute in order).
	- Used for common initialization logic shared across all constructors.
	- Can have a static initializer block, which executes once when the class is loaded.
        - Cannot take parameters.
        - Initializer blocks do not directly call the parent class's initializer blocks or constructors.

       

Static Initializer Block Example

A static initializer block is executed only once, when the class is loaded into memory.

  class Example {

    static {
        System.out.println("Static initializer block executed.");
    }

    {
        System.out.println("Instance initializer block executed.");
    }

    Example() {
        System.out.println("Constructor executed.");
    }

    public static void main(String[] args) {
        System.out.println("Main method starts.");
        Example obj1 = new Example();
        Example obj2 = new Example();
    }
}

Static initializer block executed.
Main method starts.
Instance initializer block executed.
Constructor executed.
Instance initializer block executed.
Constructor executed.

--------------------------------------------------------



  -Example to Compare Constructor and Initializer Block

class Example {

    int value;

    // Initializer block
    {
        System.out.println("Initializer block executed.");
        value = 10; // Common initialization
    }

    // Constructor
    Example() {
        System.out.println("Constructor executed.");
    }

    Example(int val) {
        System.out.println("Constructor with parameter executed.");
        value = val; // Overrides the initializer block's value
    }

    public static void main(String[] args) {
        System.out.println("Creating first object:");
        Example obj1 = new Example();

        System.out.println("\nCreating second object:");
        Example obj2 = new Example(20);
    }
}

Creating first object:
Initializer block executed.
Constructor executed.

Creating second object:
Initializer block executed.
Constructor with parameter executed.

------------------------------------------------------

   Questions 
  
     1.  What is the difference between a static block and a static method?
                A static block is executed automatically when the class is loaded, while a static method is executed explicitly by calling it.


    2. What happens if you use return in an initializer block?
               Using return in an initializer block causes a compile-time error because initializer blocks cannot return values.



   3.  Can a final variable be initialized in an instance initializer block?
              Yes, a final instance variable can be initialized in an initializer block if it is not already initialized.


class Example {
    final int value;

    {
        value = 10; // Initialized in the instance initializer block
    }
}


  4. What is the execution order of static and instance initializer blocks?
            - Static initializer blocks are executed first, when the class is loaded.
            - Instance initializer blocks are executed after the parent class constructor and before the child class constructor.


     Execution Flow:
         1> When an object is created, the parent class constructor is invoked first.
         2> After the parent class constructor completes, the instance initializer block in the child class executes.
         3> Finally, the child class constructor body is executed.



 class Parent {
    Parent() {
        System.out.println("Parent class constructor");
    }
}

class Child extends Parent {
    {
        System.out.println("Child class instance initializer block");
    }

    Child() {
        System.out.println("Child class constructor");
    }
}

public class Main {
    public static void main(String[] args) {
        new Child();
    }
}


o/p:

Parent class constructor
Child class instance initializer block
Child class constructor


//---------------------------------------------------------------------------------------------------

//---------------------------------------------------------------------------------------------------

	// Hierarchical Inheritance

			[ ] Person
	 		 |
	 ________________|_______________________________
	 |			|			|
	[ ] student           [   ] Employee           [   ] Driver
	 |			|                        |
	 |			|                  ---------------   
	[ ] sport          -------------------     |             |
	 |                 |         |        |   [ ] Utility   [ ] Heavy 
	 |               [  ]       [  ]     [ ]
	[ ] Result      Worker    Director    CEO

class Person {}

  class Student extends Person {}
     class Sport extends Student{}
        class Result extends Sport{}

  class Employee extends Person {}
     class Worker extends Employee{}
     class Director extends Employee{}
     class CEO extends Employee{}

  class Driver extends Person {}
     class Utility extends Driver{}
     class Heavy extends Driver{}

class MainHierarchicalExample
{
	public static void main(String []args)
	{
		Ceo ob1=new Ceo();
		boolean b= ob1 instanceof Ceo;
		System.out.println(b);

		b=ob1 instanceof Employee;
		System.out.println(b);

		b=ob1 instanceof Person;
		System.out.println(b);

		System.out.println("\n ---------------------- ");

		Result ob2=new Result();
		b=ob2 instanceof Result;
		System.out.println(b);

		b=ob2 instanceof Person;
		System.out.println(b);
	}
}

//-----------------------------------------------------------------------

	// Multiple and Hybrid inheritances - Absent in Java

	// Why multiple and Hybrid inheritances not present in Java?

	We have two more inheritances multiple and Hybrid, these inheritances are present in C++
	but as both create the Ambiguous condition, so both are eliminated from Java.

	NOTE TAHT TO GAIN GOOD PART OF THESE INHERITANCES JAVA INTRODUCED THE INTERFACE.

	Lets see, how the ambiguous condition is created by the both
	
	// Multiple Inheritance:


		     student		     sport
	     get()    [  ]	   	     [  ]  in()
	     put()     |	               |   put()
                       |_______________________|
                               |
                               |
                              [ ]
                             Result

                        get()       in()
                        put()       put()	
			     input()
			     output()

	when we create the object of Result class and call put() method.
	
	Result rob;
	...
	rob.put(); // creates ambiguous condition coz there are two copies of put(). 
		   // one from student and another from sport


	lets consider another class relationship

	// Hybrid Inheritance:

                    in()  Student
		    out()  [ ]               ---|
                            |                   |
                   _________|______________     | -----------> // Hierarchical Inheritnce
          in()    |	                  |out()|
	  out()   |           setdata()   |in() |
	 Set()   Exam        showdata() sport   |
	 Show()  [  ]	     	         [  ] ---
	           |	                   |    |
                   |_______________________|    | ----------> // Multiple Inheritance
                            |                   |
 			  [   ]             ----
	    in()   out()  Result  in()       out()
	   Set()   Show()         setdata()  showdata()


	Ambiguous condition is created when we make a call to in() and out() using object of Result class.


	So to eliminate these Ambiguous condition, Java don't have multiple and Hybrid inheritances.
	Note another fact that java does not needs a virtual keyword to create virtual base class.

///===================================================================================================================


	// Polymorphism in Java: It refers one name many forms. there are two
				 different types as discussed below.
	
		the word polymorphism forms as shown

		- Poly: 	many or more
		- morphism: 	forms or copies



                Polymorphism
                      |
            -----------------------
            |                     |
         Runtime /               Compile-time/
     dynamic binding /          static binding/
     dynamic polymorphism /     static polymorphism /
     late binding              early binding
            |                       |
         Overriding             Overloading
                                   - Method Overloading

	* Operator Overloading not present in Java

	We have seen, the method overloading and Constructor overloading these
	are the examples of static/compile time polymorphism.

 Lets implements Runtime Polymorphism Step by Step

	1. Suppose we want to calculate the area() of different shapes
	   i.e.
		 Rect			Triangle 		Circle
		 [   ] 			[   ]			[   ]
	   
		we can define the methods as 

		findArea()	       showArea()		calcArea()

	   Now create an object of class that you want and call respective method.

		Rect ob1;		Triangle ob2;		Circle ob3;
		ob1.findArea();		ob2.showArea();		ob3.calcArea();

	2. Now, quite modification in the program, and that is, still we want to calculate 
	   the area() of any one shape, but which? --> It will be decided at Runtime.(Dynamic Poly)

		- We need one pointer, coz there is dynamic memory allocation. Here in java pointer 
		  is absent, so it is solved by reference variable.

		- Important question is that, reference of which type?  Rect, Triangle or Circle.

		- reference of any one, able to refer only location of same type. we need a reference
		  variable which is able to refer any one of the above.

		- We know that, a reference variable of base class able to refer the object of its any child.

		- Lets create a common base class for all the three classes.

     					     Shape
					     [   ]
					       |
					       |
			-------------------------------------------------
			|			|			|	
		      Rect		     Triangle 		     Circle
		      [   ] 		       [   ]		      [   ]

		  findArea()	           showArea()		   calcArea()

		Now, lets implement the above hierarchy,

class Shape
{
}
class Rect extends Shape
{
	public void findArea()
	{
		System.out.println("In Rect area()");
	}
}
class Triangle extends Shape
{
	public void showArea()
	{
		System.out.println("In Triangle area()");
	}
}
class Circle extends Shape
{
	public void calcArea()
	{
		System.out.println("In Circle area()");
	}
}

class DemoRuntimePoly1
{
	public static void main(String []args)
	{
		// rather than creating the complex architecture to decide the which shape,
		// lets go for the possiblities.

		Shape ref;

		ref = new ..... ; // which object? it is decided at runtime.
		ref.xxxxarea(); 

		// we are unable to call the method coz every class having a method with different name
		// to calculate the area. solution to this problem is there must be a method in all classes
		// having a same name to calculate the area.
	}
}

//-----------------------------------------------
3. lets rewrite


					     Shape
					     [   ] 
					       |
					       |
			-------------------------------------------------
			|			|			|	
		      Rect		     Triangle 		     Circle
		      [   ] 		       [   ]		      [   ]

		      area()	              area()		       area()


	- As we have defined multiple methods in different classes, it comes under the polymorphism.
	  i.e. one name many forms

	- here which method will receive a call is dependent on the option selected by the user at runtime.

	- means from multiple copies, one method for execution will be selected at runtime, therefore it is
	  called as runtime polymorphism / dynamic polymorphism.

		Now, lets implement the above hierarchy,

class Shape
{
}
class Rect extends Shape
{
	public void area()
	{
		System.out.println("In Rect area()");
	}
}
class Triangle extends Shape
{
	public void area()
	{
		System.out.println("In Triangle area()");
	}
}
class Circle extends Shape
{
	public void area()
	{
		System.out.println("In Circle area()");
	}
}

class DemoRuntimePoly2
{
	public static void main(String []args)
	{
		// rather than creating the complex architecture to decide the which shape,
		// lets go for the possiblities.

		Shape ref;

		ref=new Rect(); 
		ref.area(); 

		// OR

		ref=new Circle(); 
		ref.area(); 

		// OR

		ref=new Triangle(); 
		ref.area(); 
	}
}
//--------- on Compile --------

DemoRuntimePoly2.java:36: error: cannot find symbol
                ref.area();
                   ^
  symbol:   method area()
  location: variable ref of type Shape
DemoRuntimePoly2.java:41: error: cannot find symbol
                ref.area();
                   ^
  symbol:   method area()
  location: variable ref of type Shape
DemoRuntimePoly2.java:46: error: cannot find symbol
                ref.area();
                   ^
  symbol:   method area()
  location: variable ref of type Shape
3 errors
Press any key to continue . . .

	
//-------------------------------------------------------

	4. Will face some errors, they are due to

		- Shape ref; means reference is of Shape type, so interpreter searching the method in Shape class.

		- lets provide the method area() in Shape.

					     Shape
					     [   ]  public void area(){}
					       |
					       |
			-------------------------------------------------
			|			|			|	
		      Rect		     Triangle 		     Circle
		      [   ] 		       [   ]		      [   ]

		      area()	              area()		       area()


class Shape
{
	public void area()
	{
		System.out.println("In Shape area()");
	}
}
class Rect extends Shape
{
	public void area()
	{
		System.out.println("In Rect area()");
	}
}
class Triangle extends Shape
{
	public void area()
	{
		System.out.println("In Triangle area()");
	}
}
class Circle extends Shape
{
	public void area()
	{
		System.out.println("In Circle area()");
	}
}

class DemoRuntimePoly3
{
	public static void main(String []args)
	{
		// rather than creating the complex architecture to decide the which shape,
		// lets go for the possiblities.

		Shape ref;

		ref=new Rect(); 
		ref.area(); 

		// OR

		ref=new Circle(); 
		ref.area(); 

		// OR

		ref=new Triangle(); 
		ref.area(); 
	}
}

------------- Output on Run ---------------------

In Rect area()
In Circle area()
In Triangle area()
Press any key to continue . . .


//-----------------------------------------------------------------------------------------------------------------------

	5. Note Carefully,

	- If we try same implementation in C++, then in above example we will get the output after execution of area()
	 from Shape class. and to execute the child class methods we need to decl. area() from Shape class as a Virtual.

	- this change in the behaviour, known as "Dynamic Method Dispatch"

	Dynamic Dispatch: When a method is called on an object, Java determines at runtime which version of the method 
	to execute. This is called dynamic dispatch. If the object is of the subclass type, the overridden method in 
	the subclass will be invoked.

	- As the method selection is done correctly without using virtual keyword, java eliminates the virtual keyword.
//---------------------------------------------------------------------------------------------------------------------

---------------- My Notes on Dynamic Dispatch --------------------

Dynamic Method Dispatch (also known as Runtime Polymorphism) in Java is a mechanism by which a call to an overridden method is resolved at runtime, rather than compile time. This allows Java to achieve runtime polymorphism.

class Parent {
    void display() {
        System.out.println("Display method in Parent class");
    }
}

class Child extends Parent {
    @Override
    void display() {
        System.out.println("Display method in Child class");
    }
}

public class Main {
    public static void main(String[] args) {

        // Reference of Parent type, but object of Child
        Parent obj = new Child();

        // Method call resolved at runtime
        obj.display();
    }
}

o/p :: Display method in Child class

Explanation:
Reference Type: obj is of type Parent.
Object Type: obj refers to an instance of the Child class.
Method Execution: The display() method in the Child class is executed because the actual object type (Child) is resolved at runtime.

How It Works:

Compile Time:
The compiler only checks if the method exists in the reference type (Parent in the above example).

Runtime:
The JVM determines the actual object type and calls the method from the appropriate class.

//---------------------------------------------------------------------------------------------------------------------

	6. Now we want to keep the above architecture as it is and functional, To keep it functional every child of 
	   Shape class must override the area() method.

	   Then how to make it compulsory? 
	   (In C++, it is done with defining pure virtual function using virtual keyword, but virtual keyword absent in java)

	   Here, the abstract keyword is provided.



					     Shape
					     [   ]  public abstract void area();
					       |
					       |
			-------------------------------------------------========================
			|			|			|			|
		      Rect		     Triangle 		     Circle		    Parabola
		      [   ] 		       [   ]		      [   ]		      [   ]	

		      area()	              area()		       area()		     area()		



class Shape
{
	public void area()
	{
		System.out.println("In Shape area()");
	}
}
class Rect extends Shape
{
	public void area()
	{
		System.out.println("In Rect area()");
	}
}
class Triangle extends Shape
{
	public void area()
	{
		System.out.println("In Triangle area()");
	}
}
class Circle extends Shape
{
	public void area()
	{
		System.out.println("In Circle area()");
	}
}
class Parabola extends Shape
{
	public void findarea()
	{
		System.out.println("In Parabola area()");
	}
}
class DemoRuntimePoly4
{
	public static void main(String []args)
	{
		// rather than creating the complex architecture to decide the which shape,
		// lets go for the possiblities.

		Shape ref;

		ref=new Rect(); 
		ref.area(); 

		// OR

		ref=new Circle(); 
		ref.area(); 

		// OR

		ref=new Triangle(); 
		ref.area(); 

		// OR

		ref=new Parabola (); 
		ref.area(); 
	}
}

---------- Output on Run --------------
In Rect area()
In Circle area()
In Triangle area()
In Shape area()
Press any key to continue . . .

//---------------------------------------------------------------------------------------------------

	Means it is not compulsory to define the area() method within class Parabola. Now lets define the 
	base class(Shape) method as abstract.

class Shape
{
	public abstract void area();
}
class Rect extends Shape
{
	public void area()
	{
		System.out.println("In Rect area()");
	}
}
class Triangle extends Shape
{
	public void area()
	{
		System.out.println("In Triangle area()");
	}
}
class Circle extends Shape
{
	public void area()
	{
		System.out.println("In Circle area()");
	}
}
class Parabola extends Shape
{
	public void findarea()
	{
		System.out.println("In Circle area()");
	}
}
class DemoRuntimePoly4
{
	public static void main(String []args)
	{
		// rather than creating the complex architecture to decide the which shape,
		// lets go for the possiblities.

		Shape ref;

		ref=new Rect(); 
		ref.area(); 

		// OR

		ref=new Circle(); 
		ref.area(); 

		// OR

		ref=new Triangle(); 
		ref.area(); 

		// OR

		ref=new Parabola (); 
		ref.area(); 
	}
}

---------------- Output on compile --------------------------

DemoRuntimePoly4.java:1: error: Shape is not abstract and does not override abstract method area() in Shape
class Shape
^
1 error
Press any key to continue . . .

//---------------------------------------------------------------------------------------------------------------------


	7. Note that when a class contains one or more abstract methods, the class must be declared as abstract.
	   and we are unable to create the object of abstract class. but it is possible to create its reference.
	   Abstract class can act as the base in class hierarchy.


abstract class Shape
{
	public abstract void area();
}
class Rect extends Shape
{
	public void area()
	{
		System.out.println("In Rect area()");
	}
}
class Triangle extends Shape
{
	public void area()
	{
		System.out.println("In Triangle area()");
	}
}
class Circle extends Shape
{
	public void area()
	{
		System.out.println("In Circle area()");
	}
}
class Parabola extends Shape
{
	public void findarea()
	{
		System.out.println("In Circle area()");
	}
}
class DemoRuntimePoly4
{
	public static void main(String []args)
	{
		// rather than creating the complex architecture to decide the which shape,
		// lets go for the possiblities.

		Shape ref;

		ref=new Rect(); 
		ref.area(); 

		// OR

		ref=new Circle(); 
		ref.area(); 

		// OR

		ref=new Triangle(); 
		ref.area(); 

		// OR

		ref=new Parabola (); 
		ref.area(); 
	}
}

//------------------------ output on compile -----------------------------

DemoRuntimePoly4.java:26: error: Parabola is not abstract and does not override abstract method area() in Shape
class Parabola extends Shape
^
1 error
Press any key to continue . . .

	Now this error due to, as class Parabola does not have definition of area(), it contains inherited abstract
	copy of area() method.

 if we declare  class Parabola as abstract, the we will get an error as

DemoRuntimePoly4.java:57: error: Parabola is abstract; cannot be instantiated
                ref=new Parabola ();
                    ^
1 error
Press any key to continue . . .

//---------------------------------------------------------------------------------------------------------------------

//---------------------------------------------------------------------------------------------------------------------

	8. Note that abstract method don't have body


abstract class Shape
{
	abstract public void area()
	{
		System.out.println("In Shape area()");
	}
}
class Rect extends Shape
{
	public void area()
	{
		System.out.println("In Rect area()");
	}
}
class Triangle extends Shape
{
	public void area()
	{
		System.out.println("In Triangle area()");
	}
}
class Circle extends Shape
{
	public void area()
	{
		System.out.println("In Circle area()");
	}
}
class Parabola extends Shape
{
	public void findarea()
	{
		System.out.println("In Parabola findarea()");
	}
	public void area()
	{
		System.out.println("In Parabola area()");
	}
}
class DemoRuntimePoly4
{
	public static void main(String []args)
	{
		// rather than creating the complex architecture to decide the which shape,
		// lets go for the possiblities.

		Shape ref;

		ref=new Rect(); 
		ref.area(); 

		// OR

		ref=new Circle(); 
		ref.area(); 

		// OR

		ref=new Triangle(); 
		ref.area(); 

		// OR

		ref=new Parabola (); 
		ref.area(); 
	}
}

//----------------- On Compile ---------------------

DemoRuntimePoly4.java:4: error: abstract methods cannot have a body
        abstract public void area()
                             ^
1 error
Press any key to continue . . .

//---------------------------------------------------------------------------------------------------------------------

9. MEANS FINALY WE NEED TO DEFINE(OVERRIDE) THE area() METHOD IN CLASS Parabola.
	   i.e. NOW IT BECOME COMPULSORY, IF YOU WANT TO CREATE AN OBJECT OF CLASS Parabola.


abstract class Shape
{
	public abstract void area();
}
class Rect extends Shape
{
	public void area()
	{
		System.out.println("In Rect area()");
	}
}
class Triangle extends Shape
{
	public void area()
	{
		System.out.println("In Triangle area()");
	}
}
class Circle extends Shape
{
	public void area()
	{
		System.out.println("In Circle area()");
	}
}
class Parabola extends Shape
{
	public void area()
	{
		System.out.println("In Parabola area()");
	}
}
class DemoRuntimePoly5
{
	public static void main(String []args)
	{
		// rather than creating the complex architecture to decide the which shape,
		// lets go for the possiblities.

		Shape ref;

		ref=new Rect(); 
		ref.area(); 

		// OR

		ref=new Circle(); 
		ref.area(); 

		// OR

		ref=new Triangle(); 
		ref.area(); 

		// OR

		ref=new Parabola (); 
		ref.area(); 
	}
}

//--------------- output on compile -------------------
In Rect area()
In Circle area()
In Triangle area()
In Parabola area()
Press any key to continue . . .

//--------------------------------------------------------------------------------------------------------------


   Question o Polymorphism

   1. polymorphism in java real time example
          A person can have different characteristics at the same time. Like a man at the same time is a father, a husband, 
            and an employee. So the same person possesses different behaviors in different situations. This is called polymorphism.
    
     1.Banking System
         Different types of bank accounts (Savings, Current, Fixed Deposit) have a method getInterestRate() that behaves differently
          based on the account type.

    2. Payment System
            Different payment methods (Credit Card, Debit Card, Net Banking) have a method pay() that behaves differently.

    3. Vehicle System
          In a vehicle hierarchy, different types of vehicles (Car, Bike, Truck) may implement the move() method differently.

class Vehicle {
    void move() {
        System.out.println("Vehicle is moving");
    }
}

class Car extends Vehicle {
    @Override
    void move() {
        System.out.println("Car is moving");
    }
}

class Bike extends Vehicle {
    @Override
    void move() {
        System.out.println("Bike is moving");
    }
}

public class Main {
    public static void main(String[] args) {
        Vehicle vehicle; // Parent class reference

        vehicle = new Car();
        vehicle.move(); // Calls Car's move()

        vehicle = new Bike();
        vehicle.move(); // Calls Bike's move()
    }
}

o/p: Car is moving
Bike is moving



          2. What is the difference between compile-time and run-time polymorphism?
                 -  Compile-time Polymorphism: Resolved during compile-time (e.g., method overloading).
                 -  Run-time Polymorphism: Resolved during run-time (e.g., method overriding).

// Compile-time polymorphism
class Example {
    void display(int x) { System.out.println("Integer: " + x); }
    void display(String s) { System.out.println("String: " + s); }
}


// Run-time polymorphism
class Parent {
    void show() { System.out.println("Parent class"); }
}
class Child extends Parent {
    void show() { System.out.println("Child class"); }
}



        3.  What are the rules for method overriding?

            - The method in the subclass must have the same name, return type, and parameters as the method in the parent class.
            - The overriding method cannot reduce the visibility (e.g., from public to protected).
            - The overriding method can throw fewer or no checked exceptions but not more than the parent method.

            - No, a private method cannot be overridden because it is not visible to the child class. It is class-specific.



     3.1 Why is method overloading called compile-time polymorphism?
                 Method overloading is resolved at compile-time because the compiler determines which method to call based on 
                the method signature (name and parameter list). The method resolution does not depend on the runtime type of the object.


    3.2 Why is method overriding called runtime polymorphism?
               Method overriding is resolved at runtime because the JVM determines which method to invoke based on the actual
               type of the object (not the reference type) during execution.



      4. Can you override static methods?
             No, static methods cannot be overridden. They are class-level methods and do not depend on object instances.

 class Parent {
    static void display() { System.out.println("Parent static method"); }
}
class Child extends Parent {
    static void display() { System.out.println("Child static method"); }
}

public class Main {
    public static void main(String[] args) {
        Parent obj = new Child();
        obj.display(); 
    }
}

// Outputs: "Parent static method"


    5. Can constructors be overloaded?
           Yes, constructors can be overloaded by defining multiple constructors with different parameter lists.




    6.  What happens if both parent and child classes have static methods with the same name?
           - This is called method hiding. The method called depends on the class type of the reference, not the object.

 class Parent {
    static void display() { System.out.println("Parent static method"); }
}
class Child extends Parent {
    static void display() { System.out.println("Child static method"); }
}

public class Main {
    public static void main(String[] args) {
        Parent obj = new Child();
        obj.display();                       
    }
}
    // Outputs "Parent static method"



      7. Can polymorphism be achieved without inheritance?
             - Compile-time polymorphism can be achieved without inheritance (e.g., method overloading).
             - Runtime polymorphism requires inheritance because overriding a method depends on the relationship between the parent and child classes.



     8. What is the role of @Override annotation in polymorphism?
          - The @Override annotation is used to indicate that a method is being overridden.
          -  It helps the compiler catch errors by ensuring the method signature exactly matches the parent class's method.
          - If the annotation is used and there is no matching method in the parent class, the compiler will throw an error.

   
   
     9. What happens if a parent reference is assigned a child object and a method is called?
               If the method is overridden in the child class, the child class method is executed (runtime polymorphism).
                 If the method is not overridden, the parent class method is executed.



-----------------------------------------------------------------------------------------------


	// Some facts about the abstract keyword

	/// Using abstract keyword

	 The Keyword abstract used to declare Abstract Class and Abstract Methods

	=> Abstract Class: 

	In Java, an abstract class is a class that cannot be instantiated on its own and is meant to be subclassed by other classes.
        It serves as a blueprint for other classes, providing common functionality and structure. 
	Abstract classes can have both abstract and concrete methods.

	Here are key characteristics of abstract classes in Java:

 	- It is declared as an abstract using abstract keyword.

		abstract class Demo
		{
			.......
		}

  	- Abstract class have at least one abstract method, and child class must override the all abstract methods of 
	  base otherwise we need to declare the child class as abstract, and remember that we are not allowed to 
	  create the object of an abstract class. 

		abstract class Demo
		{
			abstract void show();
			.......
		}

  	- Abstract classes can also have regular (concrete) methods with a complete implementation

		abstract class Demo
		{
			abstract void show();
			public void display()
			{
			}
			.......
		}

  	- Abstract classes can have constructors, and they are called when a subclass object is created.

  	- Abstract classes can be used as a base class for other classes. Subclasses extend the abstract class 
	  and provide concrete implementations for the abstract methods.

  	- Abstract classes can have instance variables just like regular classes.


	abstract class Demo
	{
		private int x=10;
		public Demo()
		{
			System.out.println("\n In the Demo Class Constructor");
		}
		public void out()	
		{
			System.out.println("\n In out() method - x is "+x);
		}
		abstract void show();
	}
	class Test extends Demo
	{
		int y;
		public Test()
		{
			y=100;
			System.out.println("\n In child Test class Constructor");
		}
		public void show()
		{
			System.out.println("\n Hi from show() Test and y="+y);
		}
	}
	class DemoAbstractExample 
	{
		public static void main(String[] args) 
		{
			Test ob=new Test();
			ob.show();
			ob.out();
		}
	}

o/p:

 In the Demo Class Constructor

 In child Test class Constructor

 Hi from show() Test and y=100

 In out() method - x is 10

 	- The inner class can be declared abstract by declaring it local.
  	- A static method can be part of an abstract class.
  	- constructor can be part of an abstract class.
  	- When the final keyword is used, the abstract keyword cannot be used.
  	- Abstract methods cannot be declared private.
  	- Abstract methods cannot be declared static.
  	- An abstract keyword cannot be used with variables or constructors.

//========================================= Additional =============================================================

can abstract class contains inner class?

Yes, an abstract class in Java can contain an inner class. There are no restrictions that prevent an abstract class from having inner classes, whether they are regular (non-static) inner classes, static nested classes, or local/anonymous classes.




The inner class can serve as a helper or utility class for the outer abstract class.

Types of Inner Classes in Abstract Classes

1. Non-Static Inner Class

A non-static inner class is associated with an instance of the outer abstract class. It can access the instance variables and methods of the outer class, even if the class is abstract.


abstract class OuterAbstractClass {

    abstract void outerMethod();

    // Non-static inner class
    class InnerClass {
        void innerMethod() {
            System.out.println("Inner class method called");
        }
    }
}

class ConcreteClass extends OuterAbstractClass
 {
    void outerMethod()
     {
        System.out.println("Outer method implemented");
    }

    public static void main(String[] args) {
        ConcreteClass outer = new ConcreteClass();
        InnerClass inner = outer.new InnerClass(); // Create an instance of the non-static inner class using the outer class instance
        outer.outerMethod();
        inner.innerMethod();
    }
}
o/p: 
Outer method implemented
Inner class method called

------------------------------------------------------------------------------------

2. Static Nested Class

A static nested class is a static member of the abstract class. It does not depend on an instance of the outer class and can only access the static members of the outer class.

abstract class OuterAbstractClass {

    static void staticOuterMethod() {
        System.out.println("Static method of outer abstract class");
    }

    // Static nested class
    static class StaticNestedClass {
        void nestedMethod() {
            System.out.println("Static nested class method called");
        }
    }
}

public class Main {
    public static void main(String[] args) {
        OuterAbstractClass.StaticNestedClass nested = new OuterAbstractClass.StaticNestedClass();
        nested.nestedMethod();
        OuterAbstractClass.staticOuterMethod();
    }
}
 
o/p:
Static nested class method called
Static method of outer abstract class
------------------------------------------------------------------------------------

3. Local Inner Class
A local inner class is defined within a method of the abstract class. It can access the local variables of the method (if they are effectively final) and the members of the abstract class.

abstract class OuterAbstractClass {    <---  2. abstract class
    abstract void outerMethod(); 

    void methodWithLocalClass() {     <---  1. A local inner class is defined within Method of the 
        // Local inner class
        class LocalInnerClass {
            void localInnerMethod() {
                System.out.println("Local inner class method called");
            }
        }

        LocalInnerClass localInner = new LocalInnerClass();
        localInner.localInnerMethod();
    }
}

class ConcreteClass extends OuterAbstractClass {
    void outerMethod() {
        System.out.println("Outer method implemented");
    }

    public static void main(String[] args) {
        ConcreteClass obj = new ConcreteClass();
        obj.methodWithLocalClass();
    }
}
o/p:
Local inner class method called

------------------------------------------------------------------------------------

4. Anonymous Inner Class
An abstract class can also have an anonymous inner class. This is often used to provide an implementation for the abstract methods of the abstract class or its parent.


abstract class OuterAbstractClass {
    abstract void abstractMethod();

    void createAnonymousClass() {
        OuterAbstractClass anonymous = new OuterAbstractClass() {     <--- Anonymous Inner Class

            @Override
            void abstractMethod() {
                System.out.println("Abstract method implemented in anonymous inner class");
            }
        };

        anonymous.abstractMethod();
    }
}

public class Main {
    public static void main(String[] args) {
        OuterAbstractClass obj = new OuterAbstractClass() {
            @Override
            void abstractMethod() {
                System.out.println("Anonymous class implementation of abstract method");
            }
        };
        obj.abstractMethod();
    }
}
o/p:
Anonymous class implementation of abstract method

//===================================================================================================
//----------------------------------------------------------------------------------------------------

	 => Abstract method:

	In Java, an abstract method is a method that is declared without an implementation in an abstract class. An 
	abstract class is a class that cannot be instantiated on its own and may contain abstract methods, which are 
	meant to be implemented by concrete (non-abstract) subclasses. Abstract methods serve as a blueprint for 
	concrete classes to provide their own implementation.

	Here are the key points about abstract methods in Java:

  	- The abstract method declared as abstract using abstract keyword and it don't have body.

		i.e. abstract void display();

  	- When any method declared as abstract, the containing class must be declared as abstract.
	i.e.
		abstract class Test
		{
			abstract void display();
			....
		}
 
	- Subclasses that extend an abstract class must provide implementations for all the abstract methods declared 
	  in the superclass, otherwise you have to declare that class as abstract.

		abstract class Test
		{
			abstract void display();
			....
		}

		class Demo extends Test
		{
			.....
			public void display()
			{
				.....
			}
			....
		}

  	- Abstract methods provide a way to define a common interface for a group of related classes, ensuring that 
	  each concrete subclass provides its own implementation. This promotes code reusability and helps in 
	  creating a consistent interface for different classes.

 	key points about abstract classes and abstract methods in Java:
	
	Abstract Class:
	
	- An abstract class is a class that cannot be instantiated directly. It serves as a blueprint 
   	  for other classes to inherit from.
 	- Abstract classes may contain both abstract and concrete methods.
 	- Abstract classes are declared using the abstract keyword.
 	- Abstract classes can have constructors, fields, and regular methods, just like normal classes.
 	- Abstract classes can have access modifiers like public, protected, and private.
	  if class is
		public: To make the abstract class accessible to all classes.
		protected: To restrict access to the same package or subclasses.
		private: For use in nested abstract classes, fully encapsulating it within the enclosing class.
		Default (no modifier): To limit access to the package.

	Abstract Method:

 	- An abstract method is a method declared without an implementation (i.e., without a method body).
 	- Abstract methods are declared using the abstract keyword and must be contained within an abstract class.
 	- Abstract methods are meant to be implemented by subclasses. Subclasses must provide a concrete 
   	  implementation for all abstract methods unless they are also abstract classes.
 	- Subclasses that extend an abstract class with abstract methods must either provide concrete implementations 
   	  for all abstract methods or be declared as abstract themselves.

//---------------------------------------------------------------------------------------------------

	// Actual implementation of above example

abstract class Shape 
{
    // Abstract method declaration
    public abstract double area();

    // Concrete method
    public void display() 
	{
        System.out.println("This is a shape.");
    }
}

class Circle extends Shape
{
    private double radius;

    public Circle(double radius) 
    {
        this.radius = radius;
    }

    // Implementing the abstract method
    @Override
    public double area() 
    {
        return Math.PI * radius * radius;
    }
}

class Rectangle extends Shape 
{
    private double length;
    private double width;

    public Rectangle(double length, double width) 
    {
        this.length = length;
        this.width = width;
    }

    // Implementing the abstract method
    @Override
    public double area() 
    {
        return length * width;
    }
}

public class Main 
{
    public static void main(String[] args) 
    {
        Circle circle = new Circle(5);
        System.out.println("Area of circle: " + circle.area());

        Rectangle rectangle = new Rectangle(4, 6);
        System.out.println("Area of rectangle: " + rectangle.area());
    }
}

o/p:
Area of circle: 78.53981633974483
Area of rectangle: 24.0

-----------------------------------------------------------------

            Questions on Abstract Keyword

       1. Can an abstract method be static, final, or private?
             No, abstract methods cannot be:
                 static: Static methods belong to the class and cannot be overridden.
                 final: Final methods cannot be overridden, which contradicts the purpose of abstract methods.
                 private: Private methods are not visible to subclasses and therefore cannot be overridden.


  
       2. What happens if a class does not implement all abstract methods from its abstract parent class?
              If a subclass does not implement all abstract methods of its parent abstract class, it must also be declared abstract.



      3. Can a class be declared abstract without having any abstract methods?
              Yes, a class can be declared abstract even if it does not have any abstract methods. 
                 This is done to restrict the instantiation of the class.

abstract class Vehicle {
    void run() {
        System.out.println("Vehicle is running.");
    }
}


     4.  Can an abstract class have a main() method?
                Yes, an abstract class can have a main() method. The main() method can be used to test the
                  functionality of the abstract class or its subclasses.

             abstract class Test {
    public static void main(String[] args) {
        System.out.println("Abstract class with main method.");
    }
}


    5. Can a class be both abstract and final? Why or why not?
             No, a class cannot be both abstract and final because final means it cannot be extended, while abstract requires extension for implementation.


   6. Can an abstract class contain static methods?
           Yes, an abstract class can have static methods. These methods belong to the class and can be called without creating an instance.

abstract class Utility {
    static void printMessage() {
        System.out.println("This is a static method in an abstract class.");
    }
}


  7. How do abstract classes support polymorphism?
          Abstract classes allow polymorphism by enabling method overriding. Subclasses of an abstract class can 
          define specific behavior for abstract methods, allowing dynamic method dispatch.


  8. Can a method in an abstract class be both abstract and synchronized?
             No, methods in abstract classes cannot be both abstract and synchronized because abstract methods 
            do not have a body, and synchronization requires implementation.



   9. What is the difference between an abstract class and an interface?

     Abstract Class:
            1. Keyword: abstract
            2. Methods:	Can have both abstract and concrete methods.
            3. Fields:	 Can have instance variables.
            4. Inheritance : Can extend one abstract class, Supports single inheritance.
            5. Constructor : Can have constructors.
            6.Access Modifiers:	Can have any access modifier for methods.
           

    interface:
          1.Keyword:  interface
          2.Methods:  Methods are abstract by default (Java 7) and can have default and static methods (Java 8+).
          3.Fields:  Fields are public, static, and final by default.
          4.Inheritance : Can implement multiple interfaces, Supports multiple inheritance.
          5.Constructor : Cannot have constructors
          6.Access Modifiers: Methods are public by default.


//--------------------------------------------------------------------------------------------------------------------
//--------------------------------------------------------------------------------------------------------------------

	// Interface in Java

	An interface in Java is a reference type that defines a contract or a set of abstract methods that a 
	class must implement. 

	It acts as a blueprint for classes. Unlike a class, an interface can contain only:

	- Abstract methods (methods without a body; method declarations)(implicitly public and abstract).
	- Constant fields (implicitly public static final).
	- Static methods (with a body, introduced in Java 8).
	- Default methods (with a body, introduced in Java 8).
	- private and private static methods (with a body, introduced in Java 9).
	- Cannot have constructors, meaning interfaces cannot be instantiated.
	- A class can implement multiple interfaces, enabling multiple inheritance in Java.

	


	Decl. Syntax;

	interface <interface_name>	e.g.
	{					interface Demo
		<fields>;			{
		<methods>;				int DATA=100;
	};						void method1();
							static void method2(){
								System.out.println("In Static method of interface");
							}
							default void method3() {
							      System.out.println("In default implementation of method in interface");
							}
						}


	- Typically, interfaces are declared with public access modifiers to allow usage across different packages.
	- Follow naming conventions: Capitalize the first letter and use camel case (e.g., Animal, Drawable).
	- Fields in an interface are always public static final, even if you don't explicitly write it.
	- Abstract Methods: Declared without a body, they must be implemented by any class that implements the interface.
	- Default Methods: Have a method body and can provide a default implementation.
	- Static Methods: Belong to the interface and can be called without an instance.


	// A Class Implements an Interface

	A class that implements an interface must provide concrete implementations for all of its abstract methods 
	unless the class itself is abstract.

interface Demo
{
	void show();
}
class Sample implements Demo
{
	public void show() { // must be public
		System.out.println("In Show implementation - Sample");
	}
	public void display() {
		System.out.println("In display - sample");
	}
}
class ClassImplInterface 
{
	public static void main(String[] args) 
	{
		System.out.println("Main Starts");
		Sample ob = new Sample();
		ob.show();
		ob.display();
	}
}

o/p:

Main Starts
In Show implementation - Sample
In display - sample
//--------------------------------------------------------------------------

	// A class Extends class and implements an interface

	- To extend the class, extends keyword must be used.
	- To implement, implements keyword must be used

interface Demo
{
	void show();
}
class Test
{
	public void view() {
		System.out.println("In view - Test");
	}
}
class Sample extends Test implements Demo
{
	public void show() { // must be public
		System.out.println("In Show implementation - Sample");
	}
	public void display() {
		System.out.println("In display - sample");
	}
}
class ClassImplInterface 
{
	public static void main(String[] args) 
	{
		System.out.println("Main Starts");
		Sample ob = new Sample();
		ob.show();
		ob.display();
		ob.view();
	}
}

o/p:
Main Starts
In Show implementation - Sample
In display - sample
In view - Test

//--------------------------------------------------------------------------

	// A class extends class and implements an interface multiple interfaces

interface Demo
{
	void show();
}
interface Example
{
	void present();
}
class Test
{
	public void view() {
		System.out.println("In view - Test");
	}
}
class Sample extends Test implements Demo, Example
{
	public void show() { // must be public
		System.out.println("In Show implementation - Sample");
	}
	public void display() {
		System.out.println("In display - sample");
	}
	public void present() {
		System.out.println("In present - sample");
	}
}
class ClassImplInterface 
{
	public static void main(String[] args) 
	{
		System.out.println("Main Starts");
		Sample ob = new Sample();
		ob.show();
		ob.display();
		ob.view();
		ob.present();
	}
}

o/p:

Main Starts
In Show implementation - Sample
In display - sample
In view - Test
In present - sample

//-------------------------------------------------------------------------------

	// Note that As one class extends the another class, One interface also extends another interface.
	// and A class implements one or more interfaces.

interface Example
{
	void present();
}
interface Demo extends Example
{
	void show();
}
class Test
{
	public void view() {
		System.out.println("In view - Test");
	}
}
class Sample extends Test implements Demo
{
	public void show() { // must be public
		System.out.println("In Show implementation - Sample");
	}
	public void display() {
		System.out.println("In display - sample");
	}
	public void present() {
		System.out.println("In present - sample");
	}
}
class ClassImplInterface 
{
	public static void main(String[] args) 
	{
		System.out.println("Main Starts");
		Sample ob = new Sample();
		ob.show();
		ob.display();
		ob.view();
		ob.present();
	}
}

//-------------------------------------------------------------------------------------------

	// Knowing the facts when reference of base interface refers to object of child class.

	when a reference of a base interface refers to an object of a child class, it demonstrates the concept of 
	polymorphism. This is a fundamental object-oriented programming principle that allows a single interface 
	reference to be associated with different implementations dynamically (at runtime).

	In Such case we able to call only implemented methods from child.(methods present in same interface)

interface Demo 
{
	void show();
}

class Sample implements Demo
{
	public void show() {
		System.out.println("In Show implementation - Sample");
	}
	public void display() {
		System.out.println("In display - sample");
	}
}
class ClassImplInterface 
{
	public static void main(String[] args) 
	{
		Sample ob = new Sample();
		ob.show();
		ob.display();

		// -- Create the reference of interface(base) to refer object of class(child)

		Demo ref = new Sample();
		ref.show();
		ref.display();
		
	}
}

//----------- On Compile ------------
ClassImplInterface.java:28: error: cannot find symbol
                ref.display();
                   ^
  symbol:   method display()
  location: variable ref of type Demo
1 error
Press any key to continue . . .

//---------------------------------------------------------------------------------------------------------------------

	/// Knowing the details about the members of interface

	// Interface fields

	fields in an interface behave differently from fields in a class. Interface fields are used to define 
	constants that are shared across all implementing classes. They are fundamentally different because they 
	are implicitly public, static, and final, regardless of how they are declared.

	 - public: Accessible everywhere.
	 - static: Belong to the interface, not to any instance of the implementing class.
	 - final: Cannot be modified once initialized (constant)


interface Constants {
    int MAX_VALUE=100;  // Implicitly public, static, and final
	// initialization is compulsory even if you want to keep it zero.
}

class Example implements Constants {
    void printConstant() {
        System.out.println(MAX_VALUE); // Accessing the constant
    }
}

class InterfaceFieldsExample
{
	public static void main(String []args) {
		Example ob = new Example();
		ob.printConstant();
		System.out.println(Constants.MAX_VALUE);
		System.out.println(ob.MAX_VALUE);		
	}
}
o/p:
100
100
100

	Note: 
	 - must init the interface fields, coz they are implicitly final, (even if they are static)
	 - As it is public and static by default, it can accessed using <interface_name>.<field_name>
	 - You can access it with in implementing class directly coz it is public in interface so it is inherited.
	 - using object of implementing class you can access it directly as <obj_nm>.<field_name>, coz it os public.


	// Advantages of Interface Fields

	 - Interface fields provide a mechanism to define constants that are globally accessible throughout 
	   the application.
	 - All implementing classes share the same constant values, reducing redundancy.
	 - Fields can be accessed directly via the interface name, making them convenient to use in different 
	   parts of the application.

	//  Limitations of Interface Fields
	 
	- Fields are final, meaning their values cannot be changed once initialized. This limits their use to 
	  constant values only.
	- Since fields are static, they are not associated with any instance of a class. They cannot hold 
	  instance-specific data.
	- Using an interface solely to define constants is often considered poor design because interfaces are 
	  intended to define behavior, not data. A better alternative is to use an enum or a utility class.


	// Alternatives to Interface Fields

	 - In Java, Enum can serve as an alternative to using fields in interfaces for defining a fixed set of 
	   constants. While interface fields are traditionally used for this purpose, using Enum is often a better 
	   and more robust approach. Enums are preferred when you need to define a set of constants with type safety.

	 - Constants can also be defined in a utility class with a private constructor to prevent instantiation.

	 - For more advanced and immutable constant configurations, you can use Java record(Java 14+).

	   record is a special type of class designed to represent immutable data. It is a concise way to define 
	   a class whose main purpose is to carry data, similar to Data Transfer Objects (DTOs) or value objects.

//-------------------------------------------

	// Methods within interface

	// Public and Abstract Methods (Pre-Java 8 and Onward)
	
	Abstract methods are the core of interfaces. They define behavior that any implementing class must provide.

	Characteristics:

	- Declared without a body.
	- Must be implemented by any concrete (non-abstract) class that implements the interface.
	- Implicitly public and abstract (you can omit these modifiers).

	Purpose: Abstract methods enforce a contract, ensuring that all implementing classes share a common behavior.

	interface Animal {
    		void eat();    // Abstract method
    		void sleep();  // Abstract method
	}

	class Dog implements Animal {

    		public void eat() {
        		System.out.println("Dog is eating");
    		}

    		public void sleep() {
        		System.out.println("Dog is sleeping");
    		}
	}
	class DemoFAIM
	{
		public static void main(String []args) {

			Dog ob = new Dog();
			ob.eat();
			ob.sleep();
		}
	}


///-------------------------------------

	// Implementing runtime polymorphism using interface

interface Shape
{
	 void area();
}
class Rect implements Shape
{
	public void area()
	{
		System.out.println("In Rect area()");
	}
}
class Triangle implements Shape
{
	public void area()
	{
		System.out.println("In Triangle area()");
	}
}
class Circle implements Shape
{
	public void area()
	{
		System.out.println("In Circle area()");
	}
}

class DemoRuntimePolyusingInterface
{
	public static void main(String []args)
	{
		Shape ref;

		ref=new Rect(); 
		ref.area(); 

		// OR

		ref=new Circle(); 
		ref.area(); 

		// OR

		ref=new Triangle(); 
		ref.area(); 

	}
}

/---------------------------------------------------------------------------------------------------------------------

	// Default Methods in Interface

	Default methods in Java interfaces were introduced in Java 8 to provide method implementations in interfaces. 
	Before Java 8, interfaces could only contain abstract methods, but default methods offer a way to add 
	functionality to interfaces without breaking the existing classes that implement them.

	- Default methods allow you to define a method body (implementation) in the interface itself.
	- Default methods enable adding new methods to existing interfaces without forcing the classes that 
	  implement them to modify their code.
	- Implementing classes can override default methods if a specific implementation is needed.
	- Default methods must always be public (implicit in interfaces). They cannot be private, protected, or static.
	- If a class implements multiple interfaces with the same default method name, the class must explicitly 
	  resolve the conflict.


interface MyInterface
{
	void show();
	default void displayMessage() {
		System.out.println("This is Default Message");
	}
}
class MyClass implements MyInterface
{
	public void show() {
		System.out.println("In MyClass show()");
	}
	public void display() {
		System.out.println("In MyClass display()");
	}
}
class YourClass implements MyInterface
{
	public void show() {
		System.out.println("In YourClass show()");
	}
	public void displayMessage() {
		System.out.println("This is Custom Message");
	}
}
class DemoDefaultInterfaceMethod 
{
	public static void main(String[] args) 
	{
		MyClass ob = new MyClass();
		ob.show();
		ob.display();
		ob.displayMessage();
	
		System.out.println("\n ------------------------------------------");

		YourClass ob1 = new YourClass();
		ob1.show();
		ob1.displayMessage();
	}
}

o/p:
In MyClass show()
In MyClass display()
This is Default Message

 ------------------------------------------
In YourClass show()
This is Custom Message


//---------------------------------------------------
	
	// Multiple interface implementation having default method with same name

	If a class implements multiple interfaces with the same default method, the class must explicitly 
	resolve the conflict.

interface MyInterface
{
	void show();
	default void displayMessage() {
		System.out.println("This is Default Message - MyInterface");
	}
}
interface YourInterface
{
	void display();
	default void displayMessage() {
		System.out.println("This is Default Message - YourInterface");
	}
}
class CommanClass implements MyInterface, YourInterface
{
	public void show() {
		System.out.println("In CommanClass show()");
	}
	public void display() {
		System.out.println("In CommanClass display()");
	}
	public void displayMessage() {
		YourInterface.super.displayMessage();
		MyInterface.super.displayMessage();
	}
}

class DefaultMethodConfilct
{
	public static void main(String[] args) 
	{
		CommanClass ob = new CommanClass();
		ob.show();
		ob.display();
		ob.displayMessage();
		ob.displayMessage();

	}
}

In CommanClass show()
In CommanClass display()
This is Default Message - YourInterface
This is Default Message - MyInterface
This is Default Message - YourInterface
This is Default Message - MyInterface

	// Error in case of conflict
	//  error: types MyInterface and YourInterface are incompatible;
	// class CommanClass inherits unrelated defaults for displayMessage() from types MyInterface and YourInterface

	Note: you cannot directly call A.super.greet() or B.super.greet() from the main method. 
	The super keyword is used to access a parent interface's or class's method from within the child 
	class that implements or extends it.

//------------------------------------------------------------------------

	// A class extends class and implements interface where class having show() method and interface
	// having default implementation of show() - Both acts as base of CommonClass class.

	--> In such case, no ambiguous condition, compiler gives priority to copy of show() via class.

class MyClass
{
	void show(){}
	public void displayMessage() {
		System.out.println("This is Default Message - Myclass");
	}
}
interface YourInterface
{
	void display();
	default void displayMessage() {
		System.out.println("This is Default Message - YourInterface");
	}
}
class CommonClass extends MyClass implements YourInterface 
{
	public void show() {
		System.out.println("In CommanClass show()");
	}
	public void display() {
		System.out.println("In CommanClass display()");
	}
}

class DefaultMethodConfilct
{
	public static void main(String[] args) 
	{
		CommonClass ob = new CommonClass();
		ob.show();
		ob.display();
		ob.displayMessage();
	}
}

In CommanClass show()
In CommanClass display()
This is Default Message - Myclass
//-------------------------------------------------------------------------------

	// In case of class extends class and implements interface where a base having implementation of method,
	// and same method present in base interface(public and abstract), in such case, method implementation in
	// child is optional, and in such case, it will takes inherited copy of method from class as an implementation.


class MyClass
{
	void show(){}
	public void displayMessage() {
		System.out.println("This is Default Message - Myclass");
	}
}
interface YourInterface
{
	void display();
	void displayMessage();
}
class CommonClass extends MyClass implements YourInterface 
{
	public void show() {
		System.out.println("In CommanClass show()");
	}
	public void display() {
		System.out.println("In CommanClass display()");
	}
}

class DefaultMethodConfilct
{
	public static void main(String[] args) 
	{
		CommonClass ob = new CommonClass();
		ob.show();
		ob.display();
		ob.displayMessage();
	}
}
o/p:
In CommanClass show()
In CommanClass display()
This is Default Message - Myclass

//---------------------------------------------------------------------------------------------------------

	// Static methods in interfaces

	Static methods in interfaces were introduced in Java 8. Unlike instance methods or default methods, 
	static methods belong to the interface itself and are not inherited by implementing classes. They serve 
	utility-like functionality, similar to static methods in classes, but are specific to the interface.


	Characteristics of Static Methods in Interfaces

	- Static methods are part of the interface itself, not the implementing class.
	- They are called using the interface name, not the implementing class name or an object.
	- Implementing classes do not inherit static methods from the interface.
	- They cannot be overridden by the implementing classes.
	- Provide utility or helper methods related to the interface.
	- Avoid creating a separate utility class to hold such methods.
	- Static methods in interfaces are always public by default.
	- They cannot have any other access modifier (private, protected, or package-private).

interface MathOperations {

    static int add(int a, int b) {
        return a + b;
    }

    static int multiply(int a, int b) {
        return a * b;
    }
}

public class StaticMethodsInInterface {
    public static void main(String[] args) {

        // Calling static methods using the interface name
        System.out.println("Addition: " + MathOperations.add(5, 3));    // Output: 8
        System.out.println("Multiplication: " + MathOperations.multiply(5, 3)); // Output: 15
    }
}


	Static Methods vs Default Methods:
	-----------------------------------

	- Static methods belong to the interface and cannot be called on objects.
	- Default methods are instance methods and can be called on objects of the implementing class.

//---------------------------------------------------------------------------------------------------------

	// Private Methods in Interfaces (Java 9)

	Private methods in interfaces, introduced in Java 9, are designed to provide shared, reusable logic 
	within the interface. These methods are accessible only within the interface itself and are not 
	visible to implementing classes or other interfaces.
	
	- This avoids code duplication in default and static methods.
	- Private methods can only be called by default or static methods within the same interface.
	- They are not inherited by implementing classes.
	- Private methods in interfaces must have a body (implementation). They cannot be abstract.
	- Private methods can have two forms:
		- Instance-level private methods: Can be called from default method only.
		- Static private methods: Declared with static and invoked by static methods and default methods.


interface Greeting {
    // Default method using a private instance method
    default void sayHello() {
        System.out.println("Default sayHello method:");
        log("Hello from default method");
		logStatic("Hi from default method");
    }

    // Static method using a private static method
    static void sayHi() {
        System.out.println("Static sayHi method:");
        logStatic("Hi from static method");
		// log("Hello from default method"); // error: non-static method log(String) cannot be referenced from a static context
    }

    // Private instance method
    private void log(String message) {
        System.out.println("Logging: " + message);
    }

    // Private static method
    private static void logStatic(String message) {
        System.out.println("Logging (static): " + message);
    }
}

public class PrivateStaticMethods {
    public static void main(String[] args) {
        Greeting obj = new Greeting() {}; // Anonymous implementation of Greeting

        // Call the default method
        obj.sayHello();

        // Call the static method
        Greeting.sayHi();
    }
}

Default sayHello method:
Logging: Hello from default method
Logging (static): Hi from default method
Static sayHi method:
Logging (static): Hi from static method


//-----------------------------------------------------------------------------------------------
//======================================================================================================

	// Write a program to peform the stack by implementing given StackFormat interface.

interface StackFormat {
	void push(int);
	int pop();
}

//--------------
import java.util.Scanner;
interface StackFormat {
	void push(int t);
	int pop();
}
class MyStack implements StackFormat
{
	int []data = null;
	int top;

	public MyStack() {

		top=-1;
		data = new int[10];
	}

	public void push( int t) {

		top++;
		if(top>=data.length) {
			top--;
			System.out.println("Stack is Full");
		}
		else {
			data[top]=t;
			System.out.println("\n Data Insertation Sucessful...!!");
		}
	}

	public int pop() {

		if(top<0) {
			System.out.println("Stack is empty");
			return -1;
		}
		else
			return data[top--];
	}
}
class StackByInterface
{
	public static void main(String []args)
	{
		StackFormat stack = new MyStack();
		Scanner sc = new Scanner(System.in);
		int no, opt;
		while(true) {		
			System.out.println("\n ========== Menu ==========");
			System.out.println("\n 1.Push \n 2.Pop \n 3.Stop");
			System.out.println("\n Select your option: ");
			opt=sc.nextInt();
			switch(opt) {
				case 1:
					System.out.println("Enter any Number: ");
					no=sc.nextInt();
					stack.push(no);
					break;
				case 2:
					no=stack.pop();
					if(no!=-1)
						System.out.println("Poped No: "+no);
					break;
				default:
					System.out.println("\n Incorrect option: ");
			}
		}
	}
}

//----------------------------------------------------------------------------------------------------

	// Types of interfaces in java: 

	 - Basic Interface:
	 - Marker Interface:
	 - Functional Interface:


	1. Basic Interface: The Interface we have seen till Now.

//-----------------------------

	2. Marker Interface / Empty Interface / Tag Interface

	A Marker Interface is a special type of interface in Java that does not contain any methods 
	or fields. It is also known as a Tag Interface because its primary purpose is to act as a 
	tag or a marker to indicate a specific property or capability of a class implementing it.

	Marker interfaces convey metadata to the JVM or frameworks about a class's ability to perform
	specific actions (e.g., serialization, cloning, or remote access).
	  
	Frameworks or libraries can check at runtime if a class implements a marker interface and 
	apply specific logic accordingly.	

	Examples of Marker Interfaces in Java:

	1. Serializable: Classes implementing this interface can be serialized (converted into a byte 
	  stream) and deserialized.

	(Serialization: The process of converting a Java object into a byte stream so that it can be 
	 saved to a file, transmitted over a network, or stored in a database.)

	 (Deserialization: The process of converting a byte stream back into a Java object.)

	e.g.

	import java.io.Serializable;

	class Person implements Serializable {
   	 	private String name;
    		private int age;

    		// Constructor, getters, setters
	}

	2.Cloneable: Classes implementing this interface indicate that their objects can be cloned 
	  using the clone() method.
	 
	  (Object Cloning in Java is the process of creating an exact copy (or duplicate) of an object. 
	  This is typically done using the clone() method provided by the Object class.)


	class Person implements Cloneable {
    		private String name;

    		/// .....
	}

	3. Remote: Marks a class as capable of being invoked remotely in a Remote Method Invocation 
	   (RMI) application.

	 (Remote Method Invocation (RMI) is a Java API that allows an object on one Java Virtual Machine 
	  to invoke methods of an object on another JVM, typically over a network.)
	
	import java.rmi.Remote;
	public interface MyRemote extends Remote {
    		String sayHello() throws java.rmi.RemoteException;
	}

//--------------------------------------------------------------------------------------------

	- Functional Interface:

	A Functional Interface is an interface that contains exactly one abstract method. It can 
	have multiple default or static methods, but only one abstract method defines its primary 
	functionality. Functional interfaces enable the use of lambda expressions and method 
	references, making Java functional programming-friendly.(Anonymous class)

	Functional interfaces were introduced in Java 8, along with the java.util.function package, 
	which provides many built-in functional interfaces.

        Example:
              The Runnable interface.


	// Consider Simple program

interface Calculator {
    int calculate(int a, int b);
}
class Example implements Calculator
{
	public int calculate(int a, int b) {
		return a + b;
	}
}

public class DemoFunctionalInterface {
    public static void main(String[] args) {

        Calculator add = new Example();

        System.out.println("Sum: " + add.calculate(5, 4)); 
    }
}

//----------------

	//  program using anonomous inner class (can also be written normally)

interface Calculator {
    int calculate(int a, int b);
}

public class DemoFunctionalInterface {
    public static void main(String[] args) {
        // Traditional implementation using anonymous class
        Calculator add = new Calculator() {

            public int calculate(int a, int b) {
                return a + b;
            }
        };

        System.out.println("Sum: " + add.calculate(5, 4)); 
    }
}

	// same programming Using the functional interface

interface Calculator {
    int calculate(int a, int b);
}

public class DemoFunctionalInterface {
    public static void main(String[] args) {
        // Using lambda expression
        Calculator add = (a, b) -> a + b;
        System.out.println("Sum: " + add.calculate(50, 40)); 
    }
}

//----------------------------------------------------------------------------------------

//----------------------------------------------------------------------------------------

	// Nested Interface 

	A nested interface is an interface that is declared inside another class, interface, or even 
	within another nested interface. Nested interfaces are primarily used for logically grouping 
	interfaces or to provide restricted access within a containing class or interface. They can 
	be declared as either static or non-static.

	class Outer {
    		interface NestedInterface {
        		void display();
    		}
	}

	or

	interface ParentInterface {
    		// Nested interface
    		interface ChildInterface {
        		void show();
    		}
	}


-----------------------------------------------------------------------------


  	// Difference Between Class and Interface

                     class                                                            

           Definition:           A blueprint to create objects containing fields and methods.
           Keyword:	         class	
           Inheritance:	         A class can extend one superclass only.
           Access Modifiers:	Can use any access modifiers (private, protected, public)
           Fields (Variables):	Can have instance and static variables.
           Methods: 	        Can have both concrete (implemented) and abstract (unimplemented) methods.
           Constructors:	Can have constructors to initialize objects.
           Object:              Creation Can create objects using the new keyword.
           Multiple Inheritance: Not supported (only single inheritance through extends).
           Static Methods:       Can have static methods.	
           Default Methods:	Not allowed.
           Abstract Methods:	Optional, can have both abstract and concrete methods.
           Polymorphism:	Achieved through method overriding.



             Interface

            Definition:           A reference type that defines a contract for classes to implement.
            Keyword:	          interface
            Inheritance:          An interface can be implemented by multiple classes and extend multiple interfaces.
            Access Modifiers:      Methods are public by default. Fields are public static final by default.
            Fields (Variables):    Can only have public static final constants.
            Methods:              Java 8+ allows default, static, and abstract methods. All methods are abstract by default (pre-Java 8).
            Constructors:         Cannot have constructors.
            Object:               Cannot instantiate interfaces directly.
            Multiple Inheritance:  Supported through multiple interface implementations.
            Static Methods:        Can also have static methods (from Java 8).
            Default Methods:       Allowed from Java 8 using default keyword.
            Abstract Methods:      All methods are abstract by default (Java 7 and earlier).
            Polymorphism:         Achieved through interface implementation.






	// Difference between abstract class and Interface.

             abstract class:
          
          Definition:	 A class that can have both abstract and concrete methods.
          Inheritance:	 Can extend one abstract class only.
          Methods:	 Can have abstract, concrete (default or fully defined) methods.
          Fields (Variables):	Can have instance variables (both static and non-static).
          Access Modifiers (Methods):	Methods can have any access modifier (private, protected, public).
          Constructors: 	Can have constructors to initialize fields.
          Multiple Inheritance:	Not supported (single inheritance only).


          Interface:

           Definition:    A reference type that defines a contract for classes to implement.
           Inheritance:   Can implement multiple interfaces.
           Methods:       Can have abstract, default, and static methods (from Java 8).
           Fields (Variables): Only public static final constants allowed.
          Access Modifiers (Methods): Methods are public by default.
          Constructors:    Cannot have constructors.
          Multiple Inheritance: Supported by implementing multiple interfaces.





               1. What is the default access modifier of methods in an interface?
                     The methods in an interface are public abstract by default

      
              2. Can an interface have instance variables?
                     No, interfaces can only have public static final constants (i.e., variables must be constants).


              3. Can an interface extend another interface?
                   Yes, an interface can extend one or more interfaces using the extends keyword.

              4. What are default methods in interfaces (introduced in Java 8)?
                        Default methods allow interfaces to have concrete methods with a default implementation.


               5. What are static methods in interfaces (introduced in Java 8)?
                      Static methods in interfaces are class-level methods that cannot be overridden.




       // Basic Questions
          1. What is an interface in Java?
                   An interface in Java is a reference type that acts as a contract for classes. It contains abstract methods
                 (unimplemented) and constants (public static final variables). From Java 8, interfaces can also have default and static methods.



        2. Why do we use interfaces?
           1. Achieve Abstraction: Interfaces allow defining what a class should do, not how it does it.
           2. Multiple Inheritance: Classes can implement multiple interfaces, overcoming Java's limitation of single inheritance.
           3. Decoupling: Promotes loosely coupled design by defining shared behavior.
           4. Polymorphism: Enables treating objects uniformly through a common interface reference.


 
        3. Can an interface have method implementations?
              Yes, since Java 8, interfaces can have the following types of method implementations:
              Default Methods: Have concrete implementations using the default keyword.
               Static Methods: Can be called without an instance

   interface Calculator {
    default int add(int a, int b) {
        return a + b;
    }

    static void show() {
        System.out.println("Static method in interface");
    }
}

class SimpleCalculator implements Calculator {}

public class Main {
    public static void main(String[] args) {
        Calculator calculator = new SimpleCalculator();
        System.out.println("Sum: " + calculator.add(5, 3));
        Calculator.show();  // Calling static method
    }
}


    Intermediate Questions

      1. Can we declare variables in an interface?
             Yes, but they must be implicitly or explicitly public static final. Interface variables are constants and cannot be changed.

 interface Config {
    int MAX_USERS = 100; // Equivalent to public static final int MAX_USERS
}

     2.  What happens if two interfaces have methods with the same signature?
             If two interfaces have methods with the same signature, the implementing class needs to provide only one implementation.

 interface A {
    void display();
}

interface B {
    void display();
}

class C implements A, B {
    @Override
    public void display() {
        System.out.println("Single implementation for both interfaces");
    }
}

      3. How are multiple inheritance issues resolved in Java interfaces?
               Multiple inheritance issues are resolved by requiring the class to explicitly override conflicting default methods.


interface A {
    default void show() {
        System.out.println("Default method in A");
    }
}

interface B {
    default void show() {
        System.out.println("Default method in B");
    }
}

class C implements A, B {
    @Override
    public void show() {
        A.super.show();  // Explicit resolution
    }
}
        4.  How can you use default methods to add functionality to existing interfaces without breaking their implementations?
               Default methods allow adding new functionality to interfaces without forcing all implementing classes to provide an implementation.


       5. What are the limitations of interfaces in Java?
             Cannot have instance variables (only constants).
             Cannot have constructors.
             Cannot maintain state.
             Prior to Java 8, interfaces could only have abstract methods.



     6. What is the difference between static and default methods in interfaces?

      Feature	               Default Methods	                          Static Methods
      Keyword	                default           	                    static
      Inheritance	        Inherited by implementing class	            Not inherited
      Purpose	                Extend existing interfaces	            Utility methods
      Call Method	        Via object reference	                    Directly using interface name



    7. What happens if a class implements two interfaces with default methods having the same signature?
               The implementing class must override the conflicting default methods.


     interface A {
    default void display() {
        System.out.println("Default from A");
    }
}

interface B {
    default void display() {
        System.out.println("Default from B");
    }
}

class C implements A, B {
    @Override
    public void display() {
        System.out.println("Conflict resolved in C");
    }
}


     8. Can a class inherit a default method from an interface but override it with an abstract method?
           No, you cannot override a default method with an abstract method. You must provide a concrete implementation.


      9.  What is the difference between extends and implements in the context of interfaces?

       extends :      An interface can extend one or more interfaces
       implements :   A class implements one or more interfaces


---------------------------------------------------------------------------------------



    1. Why are marker interfaces used in Java?
               They are used as a way to convey metadata to the JVM or tools, enabling certain behaviors (like serialization).



   2. How does the JVM process marker interfaces?
          The JVM or other frameworks check for the presence of marker interfaces using the instanceof operator to perform special logic.



    3.  What is the role of the @FunctionalInterface annotation?
              The @FunctionalInterface annotation ensures that the interface adheres to the contract of a functional interface 
              by enforcing exactly one abstract method.

  
    4. What are some built-in functional interfaces in Java?
           Predicate
           Consumer
           Supplier
           Function


    5. Can a functional interface have default or static methods?
           Yes, functional interfaces can have default or static methods as long as they have only one abstract method.


   
   6. What are the differences between Marker and Functional Interfaces?
          Marker Interface: No methods; used for signaling.
          Functional Interface: Must have exactly one abstract method.


   7. Why were functional interfaces introduced in Java 8?
           Functional interfaces were introduced to support lambda expressions, making code more concise and functional-style programming easier.


   8.  Can a single interface be both a functional and marker interface?
             No, marker interfaces do not have any methods, whereas functional interfaces must have exactly one abstract method.


    9.  Give a real-world use case of marker and functional interfaces.
             1. Marker Interface Use Case:
                    Ensuring an object can be serialized using the Serializable marker interface.
             2. Functional Interface Use Case:
                    Processing a list using Consumer<T> with lambda expressions.


//======================================================================================================================

//======================================================================================================================


	// Packages in java


	A package in Java is a namespace that organizes a group of related classes and interfaces. It is essentially 
	a mechanism to bundle multiple classes, interfaces, and sub-packages together into a single unit. Packages 
	act as containers for classes and help avoid naming conflicts by providing a structured hierarchy. 
	
	For example, java.util is a package that contains utility classes like Scanner, ArrayList, HashMap, etc.

	- Packages can be classified into two categories:

		- Built-in Packages: These are pre-defined packages provided by Java (e.g., java.util, java.io).
		- User-defined Packages: These are custom packages created by developers to organize their code.


	Importance/Advantages of Packages in Java: Packages are critical to Java development for the following reasons:

	- Organization: They help in organizing classes and interfaces logically, making the codebase easier to 
	  understand and manage.
	- Reusability: Classes in a package can be reused across different projects or modules 
		       without reimplementation.
	- Avoiding Naming Conflicts: Packages prevent name clashes by providing unique namespaces for classes.
	- Access Control: Packages support access modifiers like protected and package-private (default), 
			  enabling fine-grained control over visibility.
	- Modularity: By grouping related classes and interfaces, packages promote modularity, making it easier 
		      to maintain and scale applications.


//-------------------------------------------------------------------------------------------------------------

	Types of Packages: 

	- Built-in Packages 

	Built-in packages in Java are pre-defined packages provided by the Java Development Kit (JDK) to simplify 
	development. These packages contain classes, interfaces, and methods that solve common programming tasks 
	like string manipulation, data structure handling, file I/O, networking, database connectivity, etc.


	Most Commonly Used Built-in Packages
	 Below is a list of commonly used built-in packages along with some of their popular classes and methods:

	1. java.lang (Automatically Imported): Contains classes fundamental to Java programming.

	Common Classes:
	 - String: Represents a sequence of characters.
		- Methods: length(), charAt(), substring(), equals()

	- Math: Provides mathematical operations.
		- Methods: abs(), sqrt(), pow(), random()

	- System: Provides system-related utilities.
		- Methods: currentTimeMillis(), gc(), exit()

	- Object: The root class of all Java classes.
		- Methods: toString(), equals(), hashCode(), clone()

	2. java.util: Provides utility classes like collections framework, date-time utilities, and more.

	Common Classes:
	- ArrayList: A resizable array implementation.
		- Methods: add(), get(), size(), remove()

	- HashMap: A key-value mapping data structure.
		- Methods: put(), get(), containsKey(), remove()

	- Date: Represents date and time.
		- Methods: getTime(), toString()

	- Random: Generates random numbers.
		- Methods: nextInt(), nextDouble()

	- Scanner: Represents the standard input stream		
		- Methods: nextInt(), nextDouble()


	3. java.io: Provides classes for input and output operations.

	Common Classes:
	- File: Represents a file or directory.
		- Methods: exists(), createNewFile(), delete(), length()

	- BufferedReader: Reads text from an input stream.
		- Methods: readLine(), close()

	- FileWriter: Writes text to files.
		- Methods: write(), flush(), close()


	4. java.net: Supports networking operations like URL processing and socket programming.

	Common Classes:
	- URL: Represents a Uniform Resource Locator.
		- Methods: openConnection(), getHost(), getPath()

	- Socket: Represents a client-side socket.
		- Methods: connect(), close()

	- HttpURLConnection: Handles HTTP connections.
		- Methods: connect(), getResponseCode()

	5. java.sql: Provides classes for database connectivity and SQL operations.

	Common Classes:
	- Connection: Represents a connection to a database.
		- Methods: createStatement(), close()

	- Statement: Executes SQL queries.
		- Methods: executeQuery(), executeUpdate()

	- ResultSet: Holds data returned by a query.
		- Methods: next(), getString(), close()

	6. java.time: Introduced in Java 8 for date and time operations.
	
	Common Classes:
	- LocalDate: Represents a date without time.
		- Methods: now(), plusDays(), getYear()

	- LocalTime: Represents a time without a date.
		- Methods: now(), plusHours(), getMinute()

	- LocalDateTime: Combines date and time.
		- Methods: now(), plusDays(), toLocalDate()



//---------------------------------------------------------------------------------------

  // Some examples using classes from built-in packages

	// Using java.lang.String

	public class StringExample {
    public static void main(String[] args) {
        // Create a String
        String greeting = "Hello, World!";

        // Find the length of the String
        System.out.println("Length: " + greeting.length());

        // Access a character at a specific index
        System.out.println("Character at index 7: " + greeting.charAt(7));

        // Convert the String to uppercase
        System.out.println("Uppercase: " + greeting.toUpperCase());

        // Check if the String contains a substring
        System.out.println("Contains 'World': " + greeting.contains("World"));

        // Replace a substring
        String newGreeting = greeting.replace("World", "Java");
        System.out.println("Replaced String: " + newGreeting);

        // Extract a substring
        String sub = greeting.substring(7, 12);
        System.out.println("Substring: " + sub);

        // Check if two strings are equal
        String anotherGreeting = "Hello, World!";
        System.out.println("Strings are equal: " + greeting.equals(anotherGreeting));
    }
}

//-------------------------------------------------------------------------

	// Using java.lang.Math class

public class MathExample {
    public static void main(String[] args) {
        // Find the maximum of two numbers
        int a = 10, b = 20;
        System.out.println("Maximum of " + a + " and " + b + ": " + Math.max(a, b));

        // Calculate the square root of a number
        double number = 25.0;
        System.out.println("Square root of " + number + ": " + Math.sqrt(number));

        // Generate a random number between 0 and 1
        double random = Math.random();
        System.out.println("Random number (0 to 1): " + random);

        // Raise a number to a power
        double base = 2, exponent = 3;
        System.out.println(base + " raised to the power of " + exponent + ": " + Math.pow(base, exponent));

        // Find the absolute value of a number
        int negativeNumber = -15;
        System.out.println("Absolute value of " + negativeNumber + ": " + Math.abs(negativeNumber));

        // Round a number to the nearest integer
        double decimalNumber = 4.6;
        System.out.println("Rounded value of " + decimalNumber + ": " + Math.round(decimalNumber));
    }
}

//-----------------------------------------------------------------------------------

	// Using java.util.Date Class

import java.util.Date;

public class DateExample {
    public static void main(String[] args) {
        // Create a Date object to represent the current date and time
        Date currentDate = new Date();
        System.out.println("Current Date and Time: " + currentDate);
    }
}

//-----------------------------------------------------------------------------------

	// Using java.time Classes

import java.time.*;
import java.time.format.DateTimeFormatter;

public class TimeExample {
    public static void main(String[] args) {
        // Get the current date
        LocalDate currentDate = LocalDate.now();
        System.out.println("Current Date: " + currentDate);

        // Get the current time
        LocalTime currentTime = LocalTime.now();
        System.out.println("Current Time: " + currentTime);

        // Get the current date and time
        LocalDateTime currentDateTime = LocalDateTime.now();
        System.out.println("Current Date and Time: " + currentDateTime);

        // Format the date and time
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("dd-MM-yyyy HH:mm:ss");
        String formattedDateTime = currentDateTime.format(formatter);
        System.out.println("Formatted Date and Time: " + formattedDateTime);

        // Add days to the current date
        LocalDate futureDate = currentDate.plusDays(10);
        System.out.println("Date After 10 Days: " + futureDate);

        // Subtract hours from the current time
        LocalTime pastTime = currentTime.minusHours(5);
        System.out.println("Time 5 Hours Ago: " + pastTime);
    }
}

//====================================================================================================================

//====================================================================================================================

	- User-defined packages: 

	In Java, user-defined packages are packages that are created by the programmer to group related classes, 
	interfaces, and sub-packages. Packages help in organizing the classes logically, making the program more 
	manageable, readable, and modular.

	To create a user-defined package, you use the package keyword followed by the package name at the beginning 
	of the Java source file.

	Steps to Create a User-Defined Package

	- Define the Package: The first step is to define the package at the top of your Java file using 
	  the package keyword.

	- Compile the Package: Compile the Java file to create a .class file for the class within the package.

	- Import the Package: To use the classes in the user-defined package in another program, import the 
	  package using the import statement. Use set classpath command to define from where the package should
	  be taken. 
		  e.g. 
			Y:\javapackageproject\mainapp>set classpath=.*;y:\javapackageproject;

	 (The class path is valid till curression of command prompt, if you want to set it permantently then
	  use Environment variable.)

//--------------------------------------------------------------------------------------

	// Accessing different member from same class with different visibility

	i.e.

						private		default		protected	public
	//==============================================================================================
 	 same class				Yes		Yes		Yes		Yes

class Member
{
	private int x;
	protected int y;
	int z; // default (package-private)
	public int t;
	public Member() {
		x=10;
		y=20;
		z=30;
		t=40;
	}
	public void display() {
		System.out.println("\n x="+x+"\t y="+y+"\t z="+z+"\t t="+t);
	}
}

class DemoSameClassMembers
{
	public static void main(String []args)
	{
		Member ob =new Member();
		ob.display();
	}
}

 The final conclusion is that, you can access any member(private, default, protected, public) with in same class.

//-------------------------------------------------------------------------------------------------------------------

	
	// Accessing different member from same class(non-subclass) in same package with different visibility

	i.e.
					private		default		protected	public
	//==============================================================================================

  same package non-subclass		No		Yes		Yes		Yes


	using same example in different style

class Member
{
	private int x;
	protected int y;
	int z; // default (package-private)
	public int t;
	public Member() {
		x=10;
		y=20;
		z=30;
		t=40;
	}
	public void display() {
		System.out.println("\n x="+x+"\t y="+y+"\t z="+z+"\t t="+t);
	}
}

class DemoSameClassMembers
{
	public static void main(String []args)
	{
		Member ob =new Member();
		ob.display();

		//System.out.println("\n x="+ob.x); //error: x has private access in Member
		System.out.println("\n y="+ob.y+"\t z="+ob.z+"\t t="+ob.t);
	}
}


//---------------------------------

	another way: classes written in different files but in same package(folder)

// Package: c:\documents\....\demopack\Member.java
class Member
{
	private int x;
	protected int y;
	int z; // default (package-private)
	public int t;
	public Member() {
		x=10;
		y=20;
		z=30;
		t=40;
	}
	public void display() {
		System.out.println("\n x="+x+"\t y="+y+"\t z="+z+"\t t="+t);
	}
}


// Package: c:\documents\....\demopack\MainClass.java
class MainClass
{
	public static void main(String []args)
	{
		Member ob =new Member();
		ob.display();

		// System.out.println("\n x="+ob.x); //error: x has private access in Member
		System.out.println("\n y="+ob.y+"\t z="+ob.z+"\t t="+ob.t);
	}
}


	The final conclusion after analyzing the output of both, is that, you can access only member(default, 
	protected, and public) outside of package with directly using . operator, private member not accessed
	in a same package from different class.

//-----------------------------------------------------------------------------------------------------

	// Accessing different member from same class(subclass) in same package with different visibility

	In this case, there is no chane in the behaviour of private member, it is accessible with the
	class only, where it is defined.


					private		default		protected	public
//==============================================================================================

  same package subclass		         No		Yes		Yes		Yes

  same package non-subclass		No		Yes		Yes		Yes

// Package: c:\documents\....\demopack\Member.java
class Member
{
	private int x;
	protected int y;
	int z; // default (package-private)
	public int t;
	public Member() {
		x=10;
		y=20;
		z=30;
		t=40;
	}
	public void display() {
		System.out.println("\n x="+x+"\t y="+y+"\t z="+z+"\t t="+t);
	}
}


// Package: c:\documents\....\demopack\MainClass.java
class MainClass extends Member
{
	public static void main(String []args)
	{
		Member ob =new Member();
		ob.display();

		// System.out.println("\n x="+ob.x); //error: x has private access in Member
		System.out.println("\n y="+ob.y+"\t z="+ob.z+"\t t="+ob.t);
	}
}

//--------------------------------------------------------------------------------------------------------------

	// Accessing different member from class(subclass) in different package with different visibility

					private		default		protected	public
//==============================================================================================

  Different package subclass		No		No		Yes		Yes

package dp;
// loction Y:\different\dp\Member.java
public class Member
{
	private int x;
	protected int y;
	int z; // default (package-private)
	public int t;
	public Member() {
		x=10;
		y=20;
		z=30;
		t=40;
	}
	public void display() {
		System.out.println("\n x="+x+"\t y="+y+"\t z="+z+"\t t="+t);
	}
}

import dp.Member;
// Location: y:\main\mp\MainClass.java
class Test extends Member
{
	public void showTest() {
		System.out.println("\n x="+x); //error: x has private access in Member
		System.out.println("\n y="+y);
		System.out.println("\n z="+z); //error: z is not public in Member; cannot be accessed from outside package
		System.out.println("\n t="+t);
	}
}
class MainClass 
{
	public static void main(String []args)
	{
		Member ob = new Member();
		ob.display();

		Test ob1 = new Test();
		ob1.showTest();

	}
}


//---------------- output on Compile ----------------

Y:\main\mp>javac MainClass.java
MainClass.java:7: error: x has private access in Member
                System.out.println("\n x="+x); //error: x has private access in Member
                                           ^
MainClass.java:9: error: z is not public in Member; cannot be accessed from outside package
                System.out.println("\n z="+z);
                                           ^
// In absence of public visibility of class Member(means in default visibility), class Member/ Member constructor / 
   display method of member, not accessible. Means default member not visible outside of Package.

// Which indicates that in case of different packages and subclass, only public and protected members are accessible.

//--------------------------------------------------------------------------------------------------------------------

	// Accessing different member from class(Non-subclass) in different package with different visibility
	
					private		default		protected	public
//==============================================================================================

  Different package non-subclass	No		No		No		Yes	

package dp;
// loction Y:\different\dp\Member.java
public class Member
{
	private int x;
	protected int y;
	int z; // default (package-private)
	public int t;
	public Member() {
		x=10;
		y=20;
		z=30;
		t=40;
	}
	public void display() {
		System.out.println("\n x="+x+"\t y="+y+"\t z="+z+"\t t="+t);
	}
}

import dp.Member;
// Location: y:\main\mp\MainClass.java

class MainClass 
{
	public static void main(String []args)
	{
		Member ob = new Member();
		ob.display();

		System.out.println("\n x="+ob.x); //error: x has private access in Member
		System.out.println("\n y="+ob.y); // error: y has protected access in Member
		System.out.println("\n z="+ob.z); // error: z is not public in Member; cannot be accessed from outside package
		System.out.println("\n t="+ob.t);
	
	}
}

//------------ on compile ----------


Y:\main\mp>javac MainClass.java
MainClass.java:12: error: x has private access in Member
                System.out.println("\n x="+ob.x);
                                             ^
MainClass.java:13: error: y has protected access in Member
                System.out.println("\n y="+ob.y);
                                             ^
MainClass.java:14: error: z is not public in Member; cannot be accessed from outside package
                System.out.println("\n z="+ob.z);
                                             ^
3 errors


 // Which indicates that, in class non sub-class from different package, only public member is accessible
//  private. protected and default are not accessible.


//----------------------------------------------------------------------------------------------------------

	// Accessibility Table for Different Visibility Modifiers

//==============================================================================================
					private		default		protected	public
//==============================================================================================
  same class				Yes		Yes		Yes		Yes

  same package subclass		        No		Yes		Yes		Yes

  same package non-subclass		No		Yes		Yes		Yes

  Different package subclass		No		No		Yes		Yes

  Different package non-subclass	No		No		No		Yes					

//==============================================================================================


	Why and When to Create Custom Packages in Java

	Creating custom packages in Java helps in organizing and managing large applications or libraries by 
	logically grouping related classes, interfaces, and sub-packages. It offers various benefits that improve 
	code maintainability, reusability, and readability.
	
	Here are the key reasons and scenarios when you should consider creating custom packages:

	1. Code Organization and Readability
	2. Avoiding Class Name Conflicts
	3. Code Reusability
	4. Access Control and Encapsulation
	5. Logical Grouping of Related Classes
	6. Dependency Management
	7. Scalability
	8. Separation of Concerns


	When to Create Custom Packages?

	- For Large Projects:
	- When Reusing Code:
	- When Working in Teams:
	- When Developing Libraries:
	- When You Need Access Control:

	Conclusion
	Creating custom packages in Java is a fundamental practice for code organization, maintainability, modularity, 
	and reusability. Packages help in avoiding conflicts, enhancing security, and managing code in large 
	applications. It's crucial to create custom packages when the project becomes complex, and logical grouping 
	of classes, interfaces, and sub-packages becomes necessary.


	Package Naming Conventions in Java

	In Java, package naming conventions are important for maintaining consistency, readability, and manageability 
	of code. Naming packages properly helps avoid conflicts, improves clarity, and ensures that the code is easily 
	navigable by other developers.

	Here are the general guidelines and best practices for naming packages in Java:

	1. Use Lowercase Letters

	Example:
		Correct: com.myapp.utilities
		Incorrect: com.MyApp.Utilities

	2. Use Reverse Domain Name Notation

	- If your company's domain is mycompany.com, you would start your package names with com.mycompany.

	3. Organize by Functionality or Modules

	Example:
	- com.myapp.model for classes representing data and business logic (e.g., User, Product).
	- com.myapp.controller for classes that handle the logic of the application (e.g., UserController, 
	  ProductController).
	- com.myapp.ui for user interface classes (e.g., LoginWindow, MainScreen).

	4. Avoid Using Reserved Keywords

	Example:
		Incorrect: com.myapp.int
		Correct: com.myapp.utils

	5. Use Meaningful and Descriptive Names

	Example:
	 - com.myapp.payment for payment-related classes.
	 - com.myapp.authentication for classes related to user authentication.
	 - com.myapp.logging for logging-related classes.

	6. Use Hyphens or Underscores Sparingly

	 Example:
		Correct: com.myapp.paymentprocessing
		Incorrect: com.myapp.payment-processing

	7. Limit Package Depth

	Recommended: Limit package depth to 3-4 levels.
		Example: com.myapp.services.payment
		Too deep: com.myapp.services.payment.gateway.processing

	8. Use Singular or Plural Naming Based on Context

	Example:
	 - Singular: com.myapp.customer for a package related to a customer entity.
	 - Plural: com.myapp.customers for a package managing a group of customers.

	9. Avoid Using Java Library Package Names

	Example:
		- Correct: com.myapp.mylibrary
		- Incorrect: java.myapp or org.myapp


	Introduction to Java Modules
	
	In Java, modules are a way to organize and manage large codebases, introduced in Java 9 with the Java 
	Platform Module System (JPMS). They provide a higher level of encapsulation, improved security, and 
	better dependency management compared to traditional Java packages.


	1. What is a Java Module?

	- A module is a collection of related packages, classes, and resources that can be compiled and deployed 
	  together. It defines which classes and resources are available to other modules and which are kept internal.

	- A module can be seen as a self-contained unit that encapsulates both the implementation (the code) and the 
	  API (the public interface) of a part of an application.

	2. Java Module Declaration:

	- A module is defined by a special file called module-info.java. This file is placed at the root of the module 
	  and declares the module's name, its dependencies, and which packages it exports or makes available 
	  to other modules.

	- This file is mandatory for a module. Without it, the code is simply a traditional Java application.

	//-----------------------------------------------------------------------------------------------------------

	Sealed Packages in Java: 

	- Sealed packages were introduced in Java 17 

	 - A sealed package is a concept that enables you to restrict the classes and interfaces that can be contained 
	   in a package, essentially limiting which packages or modules can add classes to it. This feature helps in 
	   providing more encapsulation and modularity.

	//------------------------------------------------------------------------------------------------------------------
	
	Third-party Package Management with Maven/Gradle

	In Java, managing third-party dependencies (external libraries or packages) is made easier with tools 
	like Maven and Gradle. These tools help automate the process of downloading, updating, and managing dependencies, 
	ensuring that the correct versions are used throughout the development process. Both Maven and Gradle are build 
	automation tools that support dependency management, but they operate in slightly different ways.

	1. Maven : Maven is a popular build automation tool that primarily uses an XML configuration file called pom.xml 
	   to manage dependencies, build configurations, and project details.

	2. Gradle: Gradle is a modern, flexible build automation tool that uses Groovy or Kotlin DSL for configuration. 
	   It offers more flexibility compared to Maven and is often used for both Java and non-Java projects.


         //  ------------------------------------------------------------------------------------------


        Interview Questions on Packages


        1. What is a package in Java? Why are packages used?
            A package in Java is a namespace that groups related classes, interfaces, and sub-packages.
             Purpose:
                    Organize classes and interfaces logically
                    Prevent name conflicts
                    Control access (public, protected, default)
                    Facilitate code reuse

    
       2. How do you create a package in Java?
              Use the package keyword as the first statement in the Java file.


       3. How are packages structured on the file system?
Packages are represented as directory structures on the file system. For example:
src/
 └── com/
     └── example/
         └── demo/
             └── Test.java


   4.  What are the types of packages in Java?
          Built-in packages: Provided by Java (e.g., java.util, java.io).
          User-defined packages: Created by developers.


  5.  What is the difference between import package.* and import package.ClassName?
            import package.*: Imports all classes in the package but not sub-packages.
            import package.ClassName: Imports only the specified class.


   6. What is the default package in Java?
            If no package is defined, the class belongs to the default package. Classes in the default package cannot 
             be imported explicitly in other packages.



  7. What is the java.lang package, and why doesn't it require an explicit import?
          The java.lang package provides core classes (e.g., String, Math, Object).
           It is imported by default in every Java program.


  8. Can packages be nested in Java?

         Yes, packages can have sub-packages.
         Example: package com.example.subpackage;


    9. What is the role of CLASSPATH in packages?
            The CLASSPATH environment variable specifies the locations where the Java compiler and JVM look for class files, including packages.


    10. How do you create a package-private class in Java?
             By not specifying any access modifier, the class is accessible only within the same package.
class PackagePrivateClass {
    void display() {
        System.out.println("Package-private class");
    }
}

    11. What is the difference between jar and packages?
          Package: Logical grouping of related classes.
          JAR (Java Archive): Physical storage format that contains compiled classes and metadata.
  


   12.  Can you import a class from a sub-package directly?
           Yes, but you need to use its fully qualified name unless explicitly imported.





//=======================================================================================================
//=======================================================================================================

	/// Java Errors and Exceptions: (Exception Handing in java)

	What is an Exception?

	In programming, an exception is an event that occurs during the execution of a program that disrupts its normal 
	flow. Exceptions are typically caused by runtime errors such as:

	- Invalid user input (e.g., trying to divide a number by zero)
	- File not found (e.g., attempting to open a file that doesn’t exist)
	- Network issues (e.g., failed server connection)
	- Out-of-bounds array access (e.g., trying to access an element beyond the array size)
	- In Java, exceptions are objects that represent these error conditions. They are part of the 
	  java.lang.Exception class hierarchy.


	What is Exception Handling?

	Exception handling is a mechanism in programming to handle runtime errors gracefully and 
	maintain the normal flow of a program. It involves detecting errors, taking corrective 
	action, and recovering from unexpected situations without crashing the program.

	In Java, exception handling is achieved using the following keywords:

	- try: Defines a block of code to monitor for exceptions.
	- catch: Handles the exception if one occurs in the try block.
	- finally: Contains code that executes regardless of whether an exception was thrown or not.
	- throw: Used to explicitly throw an exception.
	- throws: Declares exceptions that a method might throw.

	Advantages of Exception Handling

	- Prevents program crashes.
	- Simplifies debugging by clearly identifying the error cause.
	- Enhances code readability and maintainability.
	- Allows graceful recovery from unexpected situations.

	We Know the execution flow of java program


					     *.java
						|
						|
					     Compile
					     (javac)			=====> Errors, Checked Exception
						|
						|
					    Bytecode	
					    (*.class)
						|			
       						|			Compile	--> Error (Nornally syntax errors)	
				---------------------------------	============================================
				|		|		|	Interpretation --> Exceptions (Runtime Error)
			       JVM	       JVM	       JVM     	
  				|		|		|			 
			      Windows	      Linux	       Mac
				|		|		|
			 Native Code       Native Code    Native Code	=====> Exceptions (Unchecked Exception)
				|		|		|
			       Run	       Run             Run
				|		|		|
			     Output	     Output          Output



	In Java, there are two different places where the Errors may occured,

	Errors:  An error is the mistake in developing  program causes a unexpected output or 
		 we are unable to execute the program. 

		The error may of two types 
		 - Compile time errors:
 		 - Run time errors:

	Compile time errors: these are the syntax errors which are displayed by java compiler and therefore these are 
			     known as Compile time errors
	  e.g.	use of undeclared  variable
		bad reference to object
		missing semi comma
		misspelling of identifier and keyword
		missing/mismatching brackets in classes and methods

	Run time errors: some time the program may compile but gives error at the time of execution due to some mistakes 
			 at run time such errors are known as Run time errors.
		e.g.	divide an integer by zero.
			access an element that is out of bounds of an array.
			attempting to use a negative size for an array.


	These error are represented in form of classes in java

	- The compile time errors are generally known as errors and are represented using the class Error 
	  or any of its subclass.

	- The runtime errors are generally termed as exceptions and represented with the help of class Exception
	  or any one of its subclass.

	Both Error and Exception classes are the childs of Throwable and all are present in java.lang package.
	it hierarchy is as shown

				java.lang.Object
					|
					|
				java.lang.Throwable
					|
			------------------------------------------
			|					|
		java.lang.Error				java.lang.Exception
			├── AssertionError			├── IOException
			├── ExceptionInInitializerError		├── RuntimeException
			├── ExceptionInInitializerError		│   │    
			├── StackOverflowError			│   ├── NullPointerException
			├── OutOfMemoryError			│   ├── ArrayIndexOutOfBoundsException
			├── NoClassDefFoundError		│   ├── ClassCastException
			└── ...					│   └── ...
								├── SQLException
								├── ParseException
								├── ClassNotFoundException
								├── InterruptedException
								├── FileNotFoundException
								├── ArithmeticException
								└── ...


	What is effect of error or Exception on a program execution.

	 - If Error is in the program, we are unable to execute the code.
	 - If Exception is there in the program, the execution will be terminated abnormally. which may	
	   introduce the unexpected or random output or result. 

	Exceptions can be caught and handled by the program. When an exception occurs within a method, 
	it creates an object. This object is called the exception object. It contains information about the
	exception such as the name and description of the exception and state of the program when the 
	exception occurred.

	now focus on different types of exceptions in Java.

	Java Exception Types
	 - The exception hierarchy also has two branches: RuntimeException and IOException.

	 1. RuntimeException
		A runtime exception happens due to a programming error. They are also known as unchecked exceptions.
		These exceptions are not checked at compile-time but they are checked at run-time. 

		Some of the common runtime exceptions are:

		 - Improper use of an API - IllegalArgumentException
	 	 - Null pointer access (missing the initialization of a variable) - NullPointerException
	  	 - Out-of-bounds array access - ArrayIndexOutOfBoundsException
		 - Dividing a number by 0 - ArithmeticException

	You can think about it in this way. “If it is a runtime exception, it is your fault”.
	- The NullPointerException would not have occurred if you had checked whether the variable was initialized or not 
	  before using it.
	- An ArrayIndexOutOfBoundsException would not have occurred if you tested the array index against the array
	  bounds.

	2. IOException
		An IOException is also known as a checked exception. They are checked by the compiler at the 
		compile-time and the programmer is prompted to handle these exceptions.

		Some of the examples of checked exceptions are:

		- Trying to open a file that doesn’t exist results in FileNotFoundException
		- Trying to read past the end of a file


	Java Exception Handling - Note that handling the exception means not eliminating it.
	
	We know that exceptions abnormally terminate the execution of a program, to avoid it, it is important to handle 
	exceptions. And it will allows us to take some corrective efforts.

	There are 5 different keywords provided to handle the exceptions. and these are 
	try, catch, finally, throw, and throws.



	try			try				try
	{			{				{
 	 .........		  ..........			}	
	}			}				catch(Exception e)
	catch(Exception e)	catch(XException e)		{
	{			{				}
 	 ---------		}				finally
	}			catch(YException e)		{
				{				}
				}
				catch(Exception e)
				{
				}
		


	try 					try
	{					{
     
	}					}
	catch (ExceptionType1 Ob) 		finally
	{					{
 	 					}
	}
	catch (ExceptionType2 Ob) 
	{
    
	}
	finally
	{
	}

 	Note:
	- Try can not be used alone. It must be used with catch block or finally block or both.
	- finally is optional
	- you are allowed to use multiple catch blocks but only one finally.
	- In case of multiple catch blocks, only one will be executed at a time if there will be exception.

//-------------------------------------------------------------------------------------

	Some programs with Errors:

	Errors are serious issues that usually arise from external circumstances or system-level problems. 
	These are represented by the Error class in Java and are generally not recoverable. Errors indicate 
	problems that a program should not attempt to handle (e.g., memory issues, JVM-related problems).

	// Use of un-decl. variable, missing ; , misspelling  of keyword

class ErrorExample 
{
	public static void main(String[] args) 
	{
		int x=10;
		flaot y=10.23f;	// error: cannot find symbol, class flaot
		System.out.println("x="+x) // error: ';' expected
		System.out.println("x="+t); //error: cannot find symbol, variable t
	}
}

//--------------------------

	// Error due to incompatible types

import java.io.BufferedReader;
import java.io.InputStreamReader;
class DemoIOException
{
	public static void main(String[] args) 
	{
		int x=0;
		BufferedReader br = new BufferedReader( new InputStreamReader(System.in));
		x=br.readLine();
		System.out.println("\n x="+x);
	}
}

 ---- On Compile ---- 
 DemoIOException.java:9: error: incompatible types: String cannot be converted to int
                x=br.readLine();
                             ^
1 error
Press any key to continue . . .

//------------------------

	// OutOfMemoryError: When the Java Virtual Machine (JVM) runs out of memory.
	
	An OutOfMemoryError in Java occurs when the Java Virtual Machine (JVM) cannot allocate more 
	memory for an object because it has run out of available memory. This error is part of the 
	java.lang package and typically indicates that your application needs more memory than what 
	is allocated or that there are memory management issues like memory leaks.

	Here are the common scenarios when OutOfMemoryError might occur:

	 - Heap Space Exhaustion( java.lang.OutOfMemoryError: Java heap space )
	 - PermGen Space Exhaustion (Pre-Java 8 - java.lang.OutOfMemoryError: PermGen space)
	 - Metaspace Exhaustion (Java 8 and later - java.lang.OutOfMemoryError: Metaspace) 
	 - Direct Buffer Memory Exhaustion (java.lang.OutOfMemoryError: Direct buffer memory)
	 - GC Overhead Limit Exceeded (java.lang.OutOfMemoryError: GC overhead limit exceeded)
	 - Unable to Create Native Thread (java.lang.OutOfMemoryError: Unable to create new native thread)


import java.util.ArrayList;
public class OutOfMemoryErrorExample {
    public static void main(String[] args) {
        ArrayList<Integer> list = new ArrayList<>();
        try {
            while (true) {
                list.add(1); // Continually adding elements
            }
        } catch (OutOfMemoryError e) {
            System.out.println("Error: Out of memory!");
        }
    }
}

//-----------------------
 -- After execution, wait for some sec, you will get ---

Error: Out of memory!

//------------------------------------------------------	

	// StackOverflowError: When the call stack size exceeds due to excessive recursion.

	A StackOverflowError in Java occurs when the application’s call stack exceeds its limit. 
	The call stack is a special memory area used to store method calls, local variables, and 
	other information related to active methods in a program. When the stack runs out of space, 
	the JVM throws a java.lang.StackOverflowError.
	
	The error typically results from excessive recursion or deep method call hierarchies. 
	Here's a breakdown of common causes:
	- Infinite Recursion
	- Excessive Recursion
	- Cyclic Method Calls
	- Deep Call Chains

public class StackOverflowErrorExample {
    public static void recursiveCall() {
        recursiveCall(); // Infinite recursion
    }

    public static void main(String[] args) {
        try {
            recursiveCall();
        } catch (StackOverflowError e) {
            System.out.println("Error: Stack overflow occurred!");
        }
    }
}
--- Output ---
Error: Stack overflow occurred!
Press any key to continue . . .

//-----------------------------------------------------------------------------------

	// LinkageError: When there is a problem with loading a class or dependent libraries.


	A LinkageError in Java is an error that occurs when the JVM encounters issues during the 
	linking phase of loading, linking, and initializing classes. This error typically arises 
	when there are inconsistencies or conflicts in the class definitions that the JVM tries
	to load. 
	
	LinkageError is a subclass of Error in the java.lang package, meaning it is a serious problem 
	that usually indicates a problem with the application’s environment, such as mismatched class 
	versions or corrupted binaries.

	- Class Definition Incompatibility
	- Conflicting Class Versions
	- Missing Dependencies

	Subclasses of LinkageError
	 - ClassCircularityError
	 - ClassFormatError
	 - NoClassDefFoundError
	 - UnsatisfiedLinkError
	 - VerifyError
	 - IncompatibleClassChangeError
		- NoSuchMethodError: A method called does not exist in the class.
		- NoSuchFieldError: A field accessed does not exist in the class.
	  	- IllegalAccessError: An attempt to access a class, method, or field that



 //-------------------------------------------------------------------------------------------------------------------
 //-------------------------------------------------------------------------------------------------------------------

	Some programs with Exceptions:

	Exceptions are events that disrupt the program's normal flow but can often be recovered. 
	Exceptions are represented by the Exception class and can be handled using try-catch blocks.

	When Exceptions Occur:

	 - Checked Exceptions: Occur at compile time and must be handled 
			       (e.g., IOException, SQLException).
	
	 - Unchecked Exceptions: Occur at runtime and can optionally be handled 
				(e.g., NullPointerException, ArithmeticException).

	// NullPointerException Example: Generated when the user not allocated memory for object, and
					 calling the method using that object reference.

public class NullPointerExceptionExample {
    public static void main(String[] args) {
        String text = null; // Null reference
        System.out.println(text.length()); // Attempt to access null
    }
}
 ------ On Execution - unchecked ---------
Exception in thread "main" java.lang.NullPointerException: Cannot invoke "String.length()" because "<local1>" is null
        at NullPointerExceptionExample.main(NullPointerExceptionExample.java:4)
Press any key to continue . . .


//-----------------

	FileNotFoundException Example: interduced when using file which is not present

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class FileNotFoundExceptionExample {
    public static void main(String[] args) {
       
            File file = new File("nonexistent.txt");
            Scanner scanner = new Scanner(file); // File doesn't exist
       
    }
}
 ------ On compile - checked ---------
FileNotFoundExceptionExample.java:9: error: unreported exception FileNotFoundException; must be caught or declared to be thrown
            Scanner scanner = new Scanner(file); 

//---------------------------------

	// Arithmetic Exception: when Divide by zero

public class ArithmeticExceptionExample {
    public static void main(String[] args) {
       
            int result = 10 / 0; // Division by zero
            System.out.println("Result: "+result);
    }
}

 ------ On Execution - unchecked ---------

Exception in thread "main" java.lang.ArithmeticException: / by zero
        at ArithmeticExceptionExample.main(ArithmeticExceptionExample.java:4)
Press any key to continue . . .

//--------------------------------------------------------------------------------------------------------------
//--------------------------------------------------------------------------------------------------------------

	What is Exception Handling?

	Exception handling is a programming construct that allows you to gracefully manage runtime errors (exceptions) 
	that disrupt the normal flow of a program. It enables you to "hit," "throw," "catch," and "handle" errors 
	systematically, ensuring the program doesn't crash unexpectedly.


	Key Terms in Exception Handling

	Hit:

	This is when an exception occurs during the program's execution, i.e., an error condition is "hit" or 
	encountered. Example: Trying to divide by zero or accessing an invalid array index.

	Throw:

	When an exception is detected, it is "thrown" to signal that an error has occurred.
	This is done using the throw keyword in Java or automatically by the JVM when a runtime exception occurs.

	Catch:

	Once an exception is thrown, it is "caught" by an appropriate catch block.
	A catch block is used to handle the exception and define what actions should be taken.

	Handle:
 
	Handling means providing a way to recover or gracefully terminate the program.
	This involves executing custom code to deal with the exception (e.g., logging errors, showing user-friendly 
	messages, or retrying operations).


	Exception Handling Workflow

	- Code is executed.
	- If an error is "hit," an exception is "thrown."
	- The program looks for a corresponding catch block to "catch" the exception.
	- The exception is "handled" by the catch block or propagated further if no matching handler exists.
	- In absence of proper handler, exception object is passed towards JVM, which will terminates the program

	Summary of Keywords in Exception Handling

      Keyword			Purpose
     --------------------------------------------------------------------------------------------
	try		Encapsulates code that might throw an exception.
	throw		Explicitly generates an exception.
	catch		Defines a block to catch and handle the thrown exception.
	finally		Executes code regardless of whether an exception was thrown or caught.
	throws		Declares exceptions a method might throw.

//----------------------------------------------------------------------------------------------------

	// Handling the checked exception - IOException

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;
class DemoIOException
{
	public static void main(String[] args)  
	{
		int x=0;
		BufferedReader br = new BufferedReader( new InputStreamReader(System.in));
		System.out.println("\n enter the value of x: ");
		try
		{
			x= Integer.parseInt(br.readLine());
		}
		catch (IOException ie)
		{
		}
		System.out.println("\n x="+x);
	}
}

/*
	----------- Without try-catch -----------------
	DemoIOException.java:9: error: unreported exception IOException; must be caught or declared to be thrown
                x= Integer.parseInt(br.readLine());
                                               ^
1 error

	NOTE: It is due to "throws clause" used while defining readline method in BufferedReader class.


	--------------- With try-catch or Using throws ------------------

	
 enter the value of x:
11

 x=11
Press any key to continue . . .

*/

//----------------------------------------------------------------------------------------------------------------------

	// Lets deal with the exception object collected in catch

	The readLine() method from the java.io.BufferedReader class can throw an IOException in the following 
	scenarios:
	
	1. Input/Output Failure
	2. Stream Closed
	3. Underlying Reader Fails
	4. File Deleted or Modified
	5. Exceeding Input Size Limits

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;
class DemoIOException
{
	public static void main(String[] args)  
	{
		int x=0;
		BufferedReader br = new BufferedReader( new InputStreamReader(System.in));
		System.out.println("\n enter the value of x: ");
		try
		{	
			br.close();
			x= Integer.parseInt(br.readLine()); // generates IOException coz attempting read after stream closed.
		}
		catch (IOException ie)
		{
			System.out.println("\n Exception is generated in the program..!!"); // Custom Message
		}
		System.out.println("\n x="+x);
	}
}

//-------------------------------------------------

	// Rather than custom message there are 3 different ways of getting information about Exception.

	- printing exception object directly.
	- using getMessage() 
	- using printStackTrace()


import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;
class DemoIOException
{
	public static void main(String[] args)  
	{
		int x=0;
		BufferedReader br = new BufferedReader( new InputStreamReader(System.in));
		System.out.println("\n enter the value of x: ");
		try
		{	
			br.close();
			x= Integer.parseInt(br.readLine());
		}
		catch (IOException e)
		{
			System.out.println("\n Exception is generated in the program..!!"); // Custom Message
			System.out.println("\n ---------------------------------------------------------------\n");
			System.out.println("\n printing exception object: "+e);
			System.out.println("\n ---------------------------------------------------------------\n");
			System.out.println("\n Exception Message: "+e.getMessage());
			System.out.println("\n ---------------------------------------------------------------\n");
			System.out.println("\n Exception stack Trace: ");
			e.printStackTrace();
		}
		System.out.println("\n x="+x);
	}
}

------------------------ On execution -------------


 enter the value of x:

 Exception is generated in the program..!!

 ---------------------------------------------------------------


 printing exception object: java.io.IOException: Stream closed

 ---------------------------------------------------------------


 Exception Message: Stream closed

 ---------------------------------------------------------------


 Exception stack Trace:
java.io.IOException: Stream closed
        at java.base/java.io.BufferedReader.ensureOpen(BufferedReader.java:121)
        at java.base/java.io.BufferedReader.implReadLine(BufferedReader.java:362)
        at java.base/java.io.BufferedReader.readLine(BufferedReader.java:347)
        at java.base/java.io.BufferedReader.readLine(BufferedReader.java:436)
        at DemoIOException.main(DemoIOException.java:14)

 x=0
Press any key to continue . . .

//---------------------------------------------------------------------------------------------------------------------------

	// Using Multiple Catch statements:


	- Why multiple catch blocks: 

	Using multiple catch blocks in Java allows you to handle different types of exceptions differently. This approach
	ensures that each exception type is treated appropriately, making the code more robust and maintainable.

	Key Reasons for Using Multiple Catch Blocks
	- Different Handling for Different Exceptions
	- Improved Readability and Debugging
	- Avoid Catching Unnecessary Exceptions
	- More Specific Exception Handling
	- Extending Functionality Without Changing Existing Code

	// lets reexecute the same code without br.close(), and input char rather than int value
	
	
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;
class DemoIOException
{
	public static void main(String[] args)  
	{
		int x=0;
		BufferedReader br = new BufferedReader( new InputStreamReader(System.in));
		System.out.println("\n enter the value of x: ");
		try
		{	
			x= Integer.parseInt(br.readLine());
		}
		catch (IOException e)
		{
			System.out.println("\n Exception is generated in the program..!!"); 
		}
		System.out.println("\n x="+x);
	}
}

-------- On execution --------


 enter the value of x:
q
Exception in thread "main" java.lang.NumberFormatException: For input string: "q"
        at java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)
        at java.base/java.lang.Integer.parseInt(Integer.java:588)
        at java.base/java.lang.Integer.parseInt(Integer.java:685)
        at DemoIOException.main(DemoIOException.java:14)
Press any key to continue . . .

//---------------------------------------------------------------------------------------------------------

	 // again suppose we changed the program and now it may be capable of generating any other exception.
	//  to deal with such unexpected exception always use additional catch at end with Exception class reference
	 // coz Exception class is in the top hierarchy, and we know reference of base able to any of its child object.


import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;
class DemoIOException
{
	public static void main(String[] args)  
	{
		int x=0,y=0;
		BufferedReader br = new BufferedReader( new InputStreamReader(System.in));
		System.out.println("\n enter the value of x and y: ");
		try
		{	
			x= Integer.parseInt(br.readLine());
			y= Integer.parseInt(br.readLine());
			double z=x/y;
		}
		catch (IOException e)
		{
			System.out.println("\n Exception due to stream problem"); 
		}
		catch (NumberFormatException e)
		{
			System.out.println("\n Exception due non-numeric input"); 
		}
		catch (Exception e)
		{
			System.out.println("\n Exception: "+e.getMessage()); 
		}
		System.out.println("\n x="+x);
	}
}

//-------------------------------------------------------------------------------------------------------

	/// Using finally Block: 
	
	What is the finally Block in Java?
	The finally block in Java is an optional part of the try-catch-finally construct. It is used to define 
	a block of code that will always execute after the try block, regardless of whether an exception was 
	thrown or caught. The finally block ensures that important cleanup operations are performed.


	Key Characteristics
	- Always Executes:
	  The finally block executes whether or not an exception is thrown in the try block.
	  - If no exception is thrown, the finally block runs after the try block.
	  - If an exception is thrown and caught, the finally block runs after the catch block.

	- Cannot Be Bypassed:
	  The finally block executes even if the try or catch block contains a return, break, or continue statement. 
	  However, it can be bypassed in some extreme cases, such as:
	  - When the JVM exits (System.exit()).
	  - When a thread is terminated or killed.

	- Cleanup Operations:
	  The primary purpose of the finally block is to release resources or perform cleanup tasks, such as closing 
	  files, releasing database connections, or closing sockets.

	- Optional:
	  It is optional in try-catch


import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;
class DemoIOException
{
	public static void main(String[] args)  
	{
		int x=0,y=0;
		BufferedReader br = new BufferedReader( new InputStreamReader(System.in));
		System.out.println("\n enter the value of x and y: ");
		try
		{	
			x= Integer.parseInt(br.readLine());
			y= Integer.parseInt(br.readLine());
			double z=x/y;
		}
		catch (IOException e)
		{
			System.out.println("\n Exception due to stream problem"); 
		}
		catch (NumberFormatException e)
		{
			System.out.println("\n Exception due non-numeric input"); 
		}
		catch (Exception e)
		{
			System.out.println("\n Exception: "+e.getMessage()); 
		}
		finally 
		{
			System.out.println("\n In the finally block"); 
		}
		System.out.println("\n x="+x);
	}
}


//-----------------------------------

	// What is Try-With-Resources in Java? (When to Avoid the finally Block)

	The try-with-resources statement is a feature introduced in Java 7 that simplifies resource management.
	It ensures that resources (e.g., files, database connections, sockets) are closed automatically when 
	they are no longer needed. This eliminates the need for a finally block to explicitly close resources.

	The resources used in a try-with-resources statement must implement the AutoCloseable 
	interface (or its subtype Closeable).

	try (ResourceType resource = new ResourceType()) 
	{
    		// Code that uses the resource
	} 
	catch (ExceptionType e) 
	{
    		// Handle exceptions
	}

 // Custom program 
class Demo implements AutoCloseable 
{
	public void close() {
		System.out.println("Resource Closed");
	}
}
class DemoAC 
{
	public static void main(String[] args) 
	{
		System.out.println("start");
		try(Demo ob = new Demo())
		{
			
		}
		catch (Exception e)
		{
			System.out.println("In catch");
		}
		System.out.println("End");
	}
}

///--------------

	// As BufferedReader implements AutoCloseable can be used in Try-With-Resources as

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;

public class Main {
    public static void main(String[] args) {
        String line;
        try (BufferedReader reader = new BufferedReader(new InputStreamReader(System.in)) ) {
            System.out.println("Enter any line: ");
            line = reader.readLine();
            System.out.println(line);
        } catch (IOException e) {
            System.out.println("An error occurred: " + e.getMessage());
        }
    }
}
 
    // The BufferedReader automatically closes at the end of the try block, even if an exception occurs.

   

  // ----------------------------------

	Lets demonstrate the exact use..

class MyStream implements AutoCloseable
{
    public void close() {
        System.out.println("Stream Closed Sucessfully");
    }
}
public class Main {
    public static void main(String[] args) {
        
        try (MyStream stream = new MyStream() ) {
            
        } catch(Exception e) {
            
        }
    }
}
 
   
//--------------------------------------------------------------------------------------------------------

	// Knowing some other exceptions 

	// ArithmeticException 

import java.util.Scanner;
class Main
{
	public static void main(String []args)
	{
		int x=0,y=0;
		double ans=0.0;

		Scanner sc = new Scanner(System.in);
		System.out.println("Enter the values of x and y: ");
		try {
		    
		    x=sc.nextInt();
	    	    y=sc.nextInt();
		    ans=x/y;
		    
		} catch(ArithmeticException e) {
		    System.out.println("Exception: "+e.getMessage());
		}catch(Exception e) {
		    System.out.println("Exception: "+e);
		}

		System.out.println("ans: "+ans);
	}
}

///-----------------------------------------------------------------------------

	// ArrayIndexOutOfBoundsException


import java.util.Scanner;
class Main
{
    public static void main(String []args)
    {
        Scanner sc = new Scanner(System.in);
        // int x[]=new int[-5]; // Exception in thread "main" java.lang.NegativeArraySizeException: -5
        int x[]=new int[-5];
        System.out.println("Enter the array elements");
        for(int i=0;i<x.length;i++)
        {
            x[i]=sc.nextInt();
        }
        
        System.out.println("Enter the array elements: ");
        for(int i=0;i<x.length;i++)
        {
            System.out.println(" "+x[i]);
        }
        
      //  System.out.println("x[-2]: "+x[-2]); // Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException
        System.out.println("x[3]: "+x[3]); 
     // System.out.println("x[7]: "+x[7]);  // // Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException
    }
}
//-------------------------------------

	// NullPointerException

import java.util.Scanner;
class Main
{
    public static void main(String []args)
    {
        String str=null;
        System.out.println("\n String Length: "+str.length()); //Exception in thread "main" java.lang.NullPointerException
 
    }
}
//--------------------------------------------------------------------------------------------------------

	//  Types of Exceptions in Java and Their Reasons

	In Java, exceptions are broadly classified into checked exceptions, unchecked exceptions, and errors. 
	Here's a list of common exceptions in each category and their causes:

	- IOException: Issues with input/output operations (e.g., file not found, unable to read/write).
	- FileNotFoundException: Trying to access a file that does not exist.
	- SQLException: Issues while interacting with a database (e.g., connection failure, invalid SQL query).
	- ClassNotFoundException: Trying to load a class that is not found in the classpath.
	- InterruptedException: A thread is interrupted while it is in a sleeping or waiting state.
	- MalformedURLException: An invalid URL is provided.
	- CloneNotSupportedException: Attempting to clone an object that does not implement the Cloneable interface.

	- NullPointerException: Attempting to access an object or call a method on a null reference.
	- ArrayIndexOutOfBoundsException: Accessing an array element with an index outside its valid range.
	- ArithmeticException: Performing an illegal arithmetic operation (e.g., division by zero).
	- ClassCastException: Invalid type casting of objects.
	- IllegalArgumentException: Passing an invalid argument to a method.
	- NumberFormatException: Converting a string to a number when the string is not in a valid format (e.g., parsing "abc" as an integer).
	- StringIndexOutOfBoundsException: Accessing characters in a string with an invalid index.
	- UnsupportedOperationException: An unsupported operation is invoked on a collection or other object.


//----------------------------------------------------------------------------------------------------------

	// Nesting of Try-Catch Block

	Nesting of try-catch blocks in Java refers to placing one try-catch block inside another. This 
	approach is useful when you need to handle exceptions for different parts of the code separately.    

public class Main 
{
    public static void main(String[] args) 
    {
        try 
        {
            // Outer try block
            int[] numbers = {1, 2, 3};
            System.out.println("Outer try block starts.");

            try 
            {
                // Inner try block
                int result = 10 / 0; // This will throw ArithmeticException
                System.out.println("Result: " + result);
            } 
            catch (ArithmeticException e) 
            {
                System.out.println("Inner catch: ArithmeticException caught!");
            }

            // This code executes after inner try-catch block
            System.out.println("Accessing an array element: " + numbers[5]); // ArrayIndexOutOfBoundsException
        } 
        catch (ArrayIndexOutOfBoundsException e) 
        {
            System.out.println("Outer catch: ArrayIndexOutOfBoundsException caught!");
        }

        System.out.println("Program continues...");
    }
}
             
//---------------------------------------------------------------------------------------------
	// Try to find output


public class MainEx1
{
    public static void main(String[] args) 
    {
        try 
        {
            // Outer try block
            int[] numbers = {1, 2, 3};
            System.out.println("Outer try block starts.");

            try 
            {
                // Inner try block
                int result = 10 / 0; // This will throw ArithmeticException
                System.out.println("Result: " + result);
            } 
            catch (NullPointerException e) 
            {
                System.out.println("Inner catch: ArithmeticException caught!");
            }

            // This code executes after inner try-catch block
            System.out.println("Accessing an array element: " + numbers[5]); // ArrayIndexOutOfBoundsException
        } 
        catch (ArrayIndexOutOfBoundsException e) 
        {
            System.out.println("Outer catch: ArrayIndexOutOfBoundsException caught!");
        }            
	catch (Exception e) 
        {
                System.out.println("Exception caught!");
        }

        System.out.println("Program continues...");
    }
}

//----------------------------------------------------------------------------------------------

	// Handling Exception from the another class

	When you are calling the any one of method from a class, using its object, and suppose that
	method having the unhandled exception then that can be / must be handled while calling the method 

	- must be: for that user must know this 

class MyMath
{
	private int x;
	private int y;
	public void input() {
		x=5;
		y=0;
	}
	public void div() {
	    int z=0;
		try{ z=x/y; }catch(NullPointerException e){System.out.print("\n exception in MyMath: "+e);}
		System.out.print("\n Ans: "+z);
	}
} 

class Main
{
	public static void main(String []args)
	{
		MyMath ob = new MyMath();
		ob.input();
		
		try{ ob.div(); }catch(Exception e){System.out.print("\n exception in Main: "+e);}
	}
}


//------------------------------------------------------------------

	// Using throws keyword:

	The throws keyword in Java is used to declare exceptions that a method might throw during its 
	execution. It indicates to the caller of the method that they must handle or further propagate the 
	specified exceptions.

	- It is used in the method signature to declare one or more exceptions that might occur.
	- It is mandatory to declare checked exceptions in the throws clause if a method can throw them and 
	  does not handle them internally.
	- Checked exceptions must be either caught using a try-catch block or declared using the throws keyword.
	- Unchecked exceptions can be thrown by methods but do not need to be declared using throws. This is optional.

	In above case, you must know that the method contains the unhandled Exception, so we have to 
	it from try-catch. To inform such behaviour of method the throws keyword is used.

	so the same program can be written as..

class MyMath
{
	private int x;
	private int y;
	public void input() {
		x=5;
		y=0;
	}
	public void div() throws ArithmeticException {
	    int z=0;
		try{ z=x/y; }catch(NullPointerException e){System.out.print("\n exception in MyMath: "+e);}
		System.out.print("\n Ans: "+z);
	}
} 

class Main
{
	public static void main(String []args)
	{
		MyMath ob = new MyMath();
		ob.input();
		
		 ob.div();
		 
		//try{ ob.div(); }catch(Exception e){System.out.print("\n exception in Main: "+e);}
	}
}

	But the program continues to generate an exception, evenif throws clause is written, coz throws clause
	will not eliminates the exception, it just informs to caller, so it is responsibility of caller that
	he has to call it from try.

	 - It is not compulsory to call till the method is not throwing checked exception,

	lets see,

import java.io.IOException;
class MyMath
{
	private int x;
	private int y;
	public void input() {
		x=5;
		y=0;
	}
	public void div() throws ArithmeticException, IOException {
	    int z=0;
		try{ z=x/y; }catch(NullPointerException e){System.out.print("\n exception in MyMath: "+e);}
		System.out.print("\n Ans: "+z);
	}
} 

class Main
{
	public static void main(String []args)
	{
		MyMath ob = new MyMath();
		ob.input();
		
		// ob.div(); // error: unreported exception IOException; must be caught or declared to be thrown
		 
		//try{ ob.div(); }catch(Exception e){System.out.print("\n exception in Main: "+e);}
	}
}

//----------------------------------------------------------------------------------------------------------------

	// Using throw keyword

	The throw keyword in Java is used to explicitly throw an exception from within a method or block of 
	code. It enables developers to generate exceptions either to signal an error condition or to propagate 
	an existing exception.

	// lets write code to submit form, and continue the taking information till the age in within the
	// age window of 18 to 25. otherwise terminate the execution by displaying the message.


import java.util.Scanner;
class Form
{
	private String name;
	private int age;
	private int id;
	private double marks;
	public void input() throws ArithmeticException
	{
		Scanner sc = new Scanner(System.in);

		System.out.println("Enter the name: ");
		name=sc.nextLine();

		System.out.println("Enter the age: ");
		age=sc.nextInt();
		if(age<18 || age>25)
			throw new ArithmeticException("Age is not within age window");
		System.out.println("Enter the id: ");
		id=sc.nextInt();

		System.out.println("Enter the marks: ");
		marks=sc.nextDouble();
	}
	void display()
	{
		System.out.println("Info: Name: "+name+"\t id: "+id+"\t age: "+age+"\t marks: "+marks);
	}
}

class Main
{
	public static void main(String []args)
	{
		Form f=new Form();
		try 
		{
			f.input();
			f.display();
		} 
		catch(Exception e) 
		{
		    System.out.println("Info:"+e);
		    System.out.println("Info:"+e.getMessage());
		}
		System.out.println("End of program");
	}
}

//------------------------------

	// Which Exception class should be choosen...!!

	- if you want to check it at compile time use IOException or any its sub-class.
	- rather that that it become runtime (unchecked)

import java.util.Scanner;
import java.io.IOException;
class Form
{
	private String name;
	private int age;
	private int id;
	private double marks;
	public void input() throws IOException,ArithmeticException
	{
		Scanner sc = new Scanner(System.in);

		System.out.println("Enter the name: ");
		name=sc.nextLine();

		System.out.println("Enter the age: ");
		age=sc.nextInt();
		if(age<18 || age>25)
		{
			throw new ArithmeticException("Age is not within age window"); 
			// As it is unchecked exception, will compile sucessfully but generate the exception when age is not within age window
			
			// throw new IOException("Age is not within age window"); 
			// As it is checked exception it will asking for exception handling at the time of compilation
		}
		System.out.println("Enter the id: ");
		id=sc.nextInt();

		System.out.println("Enter the marks: ");
		marks=sc.nextDouble();
	}
	void display()
	{
		System.out.println("Info: Name: "+name+"\t id: "+id+"\t age: "+age+"\t marks: "+marks);
	}
}

class Main
{
	public static void main(String []args)
	{
		Form f=new Form();
		try 
		{
			f.input();
			f.display();
		} 
		catch(Exception e) 
		{
		    System.out.println("Info:"+e);
		}
		System.out.println("End of program");
	}
}

//--------------------------------------------------------------------------------------------------------------------

	// Classification OF Exception by Purpose

	- Built-in Exceptions
	  - Predefined exceptions provided by Java.
	  - Examples: NullPointerException, ArrayStoreException, ClassCastException.

	- User-defined Exceptions
	  - Custom exceptions created by extending the Exception or RuntimeException class.
	  - Example:

		class CustomException extends Exception {
		    public CustomException(String message) {
		        super(message);
		    }
		}

	User-defined exceptions in Java are custom exceptions that developers create to represent specific conditions 
	or errors unique to an application. These exceptions are useful when the built-in exceptions in Java are not 
	sufficient to describe an application-specific problem.

	Steps to Create and Use User-defined Exceptions

	- Define the Exception Class
	  - Extend the Exception class for checked exceptions.
	  - Extend the RuntimeException class for unchecked exceptions.
	  - Provide constructors to initialize the exception object, optionally passing error messages 
	    or other details.
	- Throw the Exception: Use the throw keyword to explicitly throw the custom exception in your code.
	- Handle the Exception: Catch the exception using a try-catch block or propagate it using the throws keyword.

import java.util.Scanner;
import java.io.IOException;

// User-defined Exception class
class AgeException extends Exception
{
	private String exmsg;
	public AgeException(String msg)
	{
		super(msg);
		exmsg=msg;
	}
	public String toString()
	{
		return "Exception Message: "+exmsg;
	}
}
class Form
{
	private String name;
	private int age;
	private int id;
	private double marks;
	public void input() throws Exception
	{
		Scanner sc = new Scanner(System.in);

		System.out.println("Enter the name: ");
		name=sc.nextLine();

		System.out.println("Enter the age: ");
		age=sc.nextInt();
		if(age<18 || age>25)
		{
			throw new AgeException ("Age is not within age window"); 
		}
		System.out.println("Enter the id: ");
		id=sc.nextInt();

		System.out.println("Enter the marks: ");
		marks=sc.nextDouble();
	}
	void display()
	{
		System.out.println("Info: Name: "+name+"\t id: "+id+"\t age: "+age+"\t marks: "+marks);
	}
}

class Main
{
	public static void main(String []args)
	{
		Form f=new Form();
		try 
		{
			f.input();
			f.display();
		} 
		catch(Exception e) 
		{
		    System.out.println("Info:"+e.getMessage());
		    System.out.println("\n ---------------------------------------------");
		    System.out.println("Info:"+e);
		    System.out.println("\n ---------------------------------------------");
		    System.out.println("Info:");
			e.printStackTrace();
		}
		System.out.println("End of program");
	}
}

//---------------------------------------------------------------------------------------------------------------------------

	// Some practic exampes of userdefined exceptions

Example 1: In this example, we have created a custom exception class NegativeBalanceException, which extends Exception, as well as a class BankAccount, which includes a withdrawal method. If the balance is less than the amount withdrawn, an instance of NegativeBalanceException with an error message is thrown. The exception is then caught and the error message is printed in the main method.

class NegativeBalanceException extends Exception 
{
    	public NegativeBalanceException(String message) 
	{
        	super(message);
    	}
}
class BankAccount 
{
	private double balance;
    	public BankAccount(double balance) 
	{
        	this.balance = balance;
    	}
    	public double getBalance()
	{
        	return balance;
    	}
	public void withdraw(double amount) throws NegativeBalanceException 
	{
        	if (balance - amount < 0) 
		{
            		throw new NegativeBalanceException("Insufficient funds to withdraw " + amount + " rs.");
        	} 
		else 
		{
            		balance -= amount;
        	}
    	}
}
class Main 
{
	public static void main(String[] args) 
	{
        	BankAccount ba = new BankAccount(100);
        	try 
		{
            		ba.withdraw(200);
        	} 
		catch (NegativeBalanceException ex) 
		{
            		System.out.println(ex.getMessage());
        	}

        	System.out.println("Remaining balance: " + ba.getBalance());
    	}
}

//----------------------------------------------------------------------------------------------------------------

// Example 2: User Defined exception in java for Validating Login Credentials

class InvalidCredentialsException extends Exception 
{
    	public InvalidCredentialsException(String message) 
	{
        	super(message);
    	}
}

class Login 
{
    	private String username;
    	private String password;

   	public Login(String username, String password) throws InvalidCredentialsException 
	{
        	if (username == null || username.isEmpty()) 
		{
            		throw new InvalidCredentialsException("Username cannot be null or empty.");
        	}

        	if (password == null || password.isEmpty()) 
		{
            		throw new InvalidCredentialsException("Password cannot be null or empty.");
        	}

        	this.username = username;
        	this.password = password;
    	}

    	public boolean validate()
	{
        	// Check the username and password against a database or other sources
        	return true;
    	}
}

class MainLoginApplication 
{
    	public static void main(String[] args) 
	{
        	try 
		{
            		Login login = new Login("", "password");
       	 	} 
		catch (InvalidCredentialsException ex) 
		{
            		System.out.println(ex.getMessage());
       		}

		//-----------------

       		try 
		{
        		Login login = new Login("username", "");
        	} 
		catch (InvalidCredentialsException ex) 
		{
            		System.out.println(ex.getMessage());
        	}
		
		//-----------------

        	try 
		{
            		Login login = new Login("username", "password");
           		if (login.validate()) 
			{
                		System.out.println("Login successful.");
           		} 
			else 
			{
                		System.out.println("Login failed.");
            		}
        	} 
		catch (InvalidCredentialsException ex) 
		{
            		System.out.println(ex.getMessage());
        	}
    	}
}

//------------------------------------------------------------------------------------------------

	// Example 3: User Defined exception in java for Validity of an Entity

class InvalidEntityException extends Exception 
{
	public InvalidEntityException(String message) 
	{
        	super(message);
    	}
}

class Entity 
{
	private String name;
    	private int age;

    	public Entity(String name, int age) throws InvalidEntityException 
	{
        	if (name == null || name.isEmpty()) 
		{
            		throw new InvalidEntityException("Name cannot be null or empty.");
        	}

        	if (age < 0) 
		{
            		throw new InvalidEntityException("Age cannot be negative.");
        	}

        	this.name = name;
        	this.age = age;
    	}

    	public String getName() 
	{
        	return name;
    	}

    	public int getAge() 
	{
        	return age;
    	}
}

class MainEntityCheck
{
    	public static void main(String[] args) 
	{
        	try 
		{
            		Entity e = new Entity("John", -30);
        	} 
		catch (InvalidEntityException ex) 
		{
            		System.out.println(ex.getMessage());
        	}

        	try 
		{
            		Entity e = new Entity("", 25);
        	} 
		catch (InvalidEntityException ex) 
		{
            		System.out.println(ex.getMessage());
        	}

       	 	try 
		{
            		Entity e = new Entity("Jane", 30);
            		System.out.println("Name: " + e.getName());
            		System.out.println("Age: " + e.getAge());
        	} 
		catch (InvalidEntityException ex) 
		{
            		System.out.println(ex.getMessage());
        	}
   	}
}	

//--------------------------------------------------------------------------------------

	// Example 4: User Defined exception in java for Validating the age of user

class InvalidAgeException extends Exception 
{
    	public InvalidAgeException(String message) 
	{
        	super(message);
    	}
}

class User 
{
    	private int age;
    	public User(int age) throws InvalidAgeException 
	{
       		if (age < 0) 
		{
            		throw new InvalidAgeException("Age cannot be negative.");
        	}

        	if (age > 150) 
		{
            		throw new InvalidAgeException("Age is too high.");
        	}
	        this.age = age;
   	}
}

class Main 
{
    	public static void main(String[] args) 
	{
        	try 
		{
            		User user = new User(-1);
        	} 
		catch (InvalidAgeException ex) 
		{
            		System.out.println(ex.getMessage());
        	}

        	try 
		{
            		User user = new User(151);
        	} 
		catch (InvalidAgeException ex) 
		{
            		System.out.println(ex.getMessage());
        	}

        	try 
		{
            		User user = new User(30);
            		System.out.println("Age is valid.");
        	} 
		catch (InvalidAgeException ex) 
		{
            		System.out.println(ex.getMessage());
        	}
    	}
}

   -----------------------------------------------------------------------------------------------------

    1. What are the types of exceptions in Java?
          Checked Exceptions: Exceptions checked at compile time (e.g., IOException, SQLException).
          Unchecked Exceptions: Exceptions that occur at runtime (e.g., ArithmeticException, NullPointerException).
          Error: Represents serious system issues that applications should not handle (e.g., OutOfMemoryError,StackOverflowError).

  
   2. What is the difference between throw and throws?

                 Feature	throw	                                          throws
                 Purpose	Used to explicitly throw an exception	          Declares exceptions that a method may throw
                 Usage	        Inside the method body	                          In method signature
                 Syntax	        throw new Exception();	                          public void method() throws Exception
                 Type	       Used for throwing one specific exception           Declares multiple exceptions
 
   
       Detailed Explanation
         
 1. throw Keyword
         -  Used to explicitly throw an exception from a method or a block of code.
         - It must be followed by an instance of an exception class (subclass of Throwable).

public class ThrowExample {
    public static void validateAge(int age) {
        if (age < 18) {
            throw new IllegalArgumentException("Age must be 18 or older.");
        }
        System.out.println("Valid age.");
    }

    public static void main(String[] args) {
        validateAge(15); // This will throw an exception
    }
}

o/p:  Exception in thread "main" java.lang.IllegalArgumentException: Age must be 18 or older.



      2. throws Keyword
     - throws informs the caller about exceptions a method might throw.
     - The throws keyword is used in method declarations to declare the exceptions that a method might throw.
     - Used in the method signature to declare exceptions that a method may throw.
     - The calling method must handle the exception using try-catch or propagate it further.
     - Used mainly for checked exceptions.


import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

public class ThrowsExample {
    public static void readFile() throws IOException {
        BufferedReader reader = new BufferedReader(new FileReader("test.txt"));
        System.out.println(reader.readLine());
        reader.close();
    }

    public static void main(String[] args) {
        try {
            readFile();       // Handle the exception here
        } catch (IOException e) {
            System.out.println("Caught IOException: " + e.getMessage());
        }
    }
}





   3. How does the finally block work?
             The finally block always executes after the try and catch blocks, regardless of whether an exception is thrown or not.
              It is used for resource cleanup (e.g., closing database connections or file streams).


   3.1 What happens if an exception is not caught in Java?
        If an exception is not caught, the program terminates abnormally, and the JVM prints the exception's stack trace.


     4. Can you have multiple catch blocks in Java?
          Yes, multiple catch blocks are allowed to handle different types of exceptions.

try {
    int[] arr = new int[5];
    arr[10] = 50;
} catch (ArrayIndexOutOfBoundsException e) {
    System.out.println("Array out of bounds!");
} catch (Exception e) {
    System.out.println("General exception caught");
}


        5. What is the difference between Checked and Unchecked exceptions?

               Feature	            Checked Exceptions	           Unchecked Exceptions
               Compile-time	    Checked at compile-time	   Not checked at compile-time
               Inheritance	    Subclasses of Exception	   Subclasses of RuntimeException
               Examples	            IOException, SQLException	  ArithmeticException, NullPointerException ,IllegalArgumentException
                                                                       ArrayIndexOutOfBoundsException
               Checked At	    Compile time	           Runtime
               Handling	            Must be handled or declared.   Optional to handle.



        6. What is the difference between final, finally, and finalize()?

               Keyword	         Purpose
               final	         Used for constants, methods, and class declarations
               finally	         Block that executes after try-catch
               finalize()	 Method called by garbage collector before object is destroyed


  
      6. Can you create custom exceptions in Java? How?
          Yes, custom exceptions can be created by extending the Exception or RuntimeException class.


      7. What is exception propagation in Java?
            Exception propagation refers to the process by which an exception is thrown from one method and passed to its caller until it is handled.

      
      8. What are suppressed exceptions in Java?
                Suppressed exceptions are exceptions that are thrown but not propagated because another exception is already being thrown.


      9. How does try-with-resources work? What is AutoCloseable?
               try-with-resources automatically closes resources that implement the AutoCloseable interface.


      10. How does exception chaining work in Java?
                 Exception chaining allows associating a cause exception with another exception using the Throwable constructor.
try {
    throw new IOException("I/O error");
} catch (IOException e) {
    throw new RuntimeException("Runtime issue", e);
}



    11. Can you explain the best practices for exception handling in Java?
          Use specific exceptions instead of generic ones.
          Avoid empty catch blocks.
          Clean up resources in finally or use try-with-resources.
          Create meaningful custom exceptions.
          Don't swallow exceptions silently.


     12.  Can you override the getMessage() and printStackTrace() methods in custom exceptions?
           Yes, custom exceptions can override these methods to provide customized error messages and stack traces.



    13.Can a try block exist without a catch block?
            Yes, but it must have a finally block.


    
    15. Can we catch multiple exceptions in a single catch block in Java 7 and later?
             Yes, Java 7 introduced multi-catch blocks.

try {
    int result = 10 / 0;
} catch (ArithmeticException | NullPointerException e) {
    System.out.println("Exception: " + e.getMessage());
}



     16. Can we rethrow an exception in Java?
             Yes, you can rethrow an exception using the throw statement.

    try {
    throw new IOException("Error");
} catch (IOException e) {
    System.out.println("Handling exception");
    throw e; // Rethrowing the exception
}


   17.  What happens if the finally block has a return statement?
        If a finally block has a return statement, it will override any return value from the try or catch blocks.


///==============================================================================================================================
////=========================================================================================================================
//===============================================================================================================================



///===================================================================================================================
///===================================================================================================================
///===================================================================================================================

	// ------------------------- Multi-Threading(Concurrent Programming) in Java ---------------------------------

	- Concurrent means operating or occurring at the same time.

Why to go for the concurrent programming? 
-------------------------------------------
	- Improved Performance: Utilizes available computational resources efficiently, leading to faster 
	  execution times.

	- Enhanced Responsiveness: Allows systems to remain responsive even during time-consuming operations, 
	  crucial for user-facing applications.

	- Better Resource Utilization: Maximizes CPU and I/O resources by overlapping computation with I/O 
	  operations or executing tasks concurrently.

	- Scalability: Enables systems to handle increasing workloads by distributing tasks across multiple 
	  threads or processes.

	- Parallelism: Provides multi-core processors to execute multiple tasks simultaneously, speeding 
	  up processing for computationally intensive tasks.

	- Fault Isolation: Contains errors within separate threads or processes, preventing them from affecting 
	  the entire system and enhancing reliability.

	- Modularity and Maintainability: Encourages modular software design, making systems easier to understand,
	  maintain, and modify.


what is thread and what is process.
------------------------------------
A process and a thread are both independent sequences of execution, but they differ in a few key ways:

Process: A process is an instance of a program that is being executed. It includes the program itself, data,
resources such as files, and execution info such as process relation information kept by the OS. Each process 
exists within its own address or memory space and does not share it with other processes. 

Thread: A thread is a segment of a process or a part of process, which means a process can have multiple threads. 
These threads are managed independently by the scheduler. Unlike processes, threads within the same process run 
in a shared memory space. 

Here are some key differences between a process and a thread:

- A process takes more time to terminate and create, while a thread takes less time, as the process is heavyweight 
  and thread is lightweigth.
- Processes having different memory area, where as the threads shares the same memory space.
- Processes do not share data with each other, while threads share data with each other.
- You can say that Procsess is Heavyweigth Thread and Thread is ligthweight Process.
- Interthread communication is quite easy coz threads are within same memory area.
- InterProcess communication is complex as they are exists within different memory space.

//-----------------------------------------------

What is Single Thread?
A single thread in Java is basically a lightweight and the smallest unit of processing, which will execute all its 
instructions in sequence. 

Advantages of single thread:
	- Reduces overhead in the application as single thread execute in the system.
	- Also, it reduces the maintenance cost of the application.

What is Multithreading in Java?
Multithreading in Java is a process of executing two or more threads simultaneously to maximum utilization of CPU.
where java allows user to split the code into two or more parts and provides the ability to execute them in parallel
with each other.

- multithreading refers to the ability to execute multiple Threads within a single process concurrently.
- Multitasking bcan be achieved through multithreading where each task is divided into Threads that are manage concurrently

Example:
A Web browser can use multithreading by having a separate Threads for rendering the page, running JavaScript, and managing User inputs.
This makes the browser more responsive and efficient


Advantages of multithread:
	- The users are not blocked because threads are independent, and we can perform multiple operations at a times
	- As such the threads are independent, the other threads won’t get affected if one thread meets an exception.

so in simple terms, Multithreading is a programming concept in which the application can create a small unit of tasks 
to execute in parallel. If you are working on a computer, it runs multiple applications and allocates processing power 
to them. A simple program runs in sequence and the code statements execute one by one. This is a single-threaded 
application. But, if the programming language supports creating multiple threads and passes them to the operating 
system to run in parallel, it’s called multithreading.


Multithreading vs Multiprocessing:

Multiprocessing refers to the use of multiple processors or processor cores within a single computer system to execute 
multiple tasks concurrently. It is a technique used to improve the performance and scalability of software systems by 
distributing computational workload across multiple processing units.

When we talk about multithreading, we don’t care if the machine has a 2-core processor or a 16-core processor. Our work 
is to create a multithreaded application and let the OS handle the allocation and execution part. In short, 
multithreading has nothing to do with multiprocessing.

//-------------------------------------------------

How does Java Support Multithreading?
Java has great support for multithreaded applications. Java supports multithreading through Thread, then How to 
create the threads?
	
In Java, There are two different ways of Thread creation.
	 - By extending Thread class.
	 - By implementing Runnable Interface

What are the different types of threads?

	There are two types of threads in an application - user thread and daemon thread. 
	When we start an application, the main is the first user thread created. We can create multiple user threads 
	as well as daemon threads. When all the user threads are executed, JVM terminates the program.

//-----------------------------------------------

Multitasking

multitasking allows an operating system to run multiple processes simultaneously on a single core CPU this is done through time sharing, rapidly switching between task. On multi core CPU is true parallel execution occurs with task distributed across course. The OS scheduler Balance the load ensuring efficient and responsivie system performance

Example:
we are browsing the internet while listening to the music and downloading a file

multitasking utilizes the capabilities of a CPU and its course when operating system perform multitasking it can assign different task to different cores. This is more efficient than assigning all tasks to a single Core


Context Switching: context switching is the process of saving the state of the currently running process or thread and loading the state
                   of the next one to be executed
Function: when a process or threads time slice expires the OS scheduler performs a context switch to move CPU focus on another process or Thread.

Purpose: This allows multiple processes and Threads to share the CPU is giving the appearance of simultaneous execution On a single cpu or
improving parallelism on multi-core CPUs 


Thread Lifecycle:
 
	New Born
	    |
	    | start()
	    V
      Ready to Run <-------------
	(Runnable)		|
	    |			| - resume(),  notify(), noyifyAll()
   run()    |			|
 |--------->|		  Waiting/Blocked
 |	    V			^
 |<-----Running ------>---------|
	    |      sleep(), join() - will enters into Runnable state automatically
      stop()|	   - suspend(),wait()-> resumes only when resume() or notify(), noyifyAll() methods are called.
   destroy()|
 interrupt()|
	    V
	  Dead
	    

 - New: In this phase, the thread is created using class “Thread class”.It remains in this state till the program starts the thread. It is also known as born thread.
     E.g: World t1 = new thread();  //create new thread

 - Runnable: In this page, the instance of the thread is invoked with a start method. The thread control is given to scheduler to finish the execution. It depends on the scheduler, whether to run the thread.
     e.g: t1.start();  //Runnable

 - Running: When the thread starts executing, then the state is changed to “running” state. The scheduler selects one thread from the thread pool, and it starts executing in the application.

 - Waiting/Blocked: This is the state when a thread has to wait. As there multiple threads are running in the application, there is a need for synchronization between threads. Hence, one thread has to wait, till the other thread gets executed. Therefore, this state is referred as waiting state.

 - Dead: This is the state when the thread is terminated. The thread is in running state and as soon as it completed processing it is in “dead state”.

//-----------------------------------------------------------------------------------------------
	
	// Creating Threads 

	- Using java.lang.Thread class.

	// Thread class Constants: 
	
	In Java, the java.lang.Thread class provides several constants. Here's a list of some of the important constants 
	in the Thread class:

	- MIN_PRIORITY: The minimum priority that a thread can have. Its value is 1.
	- NORM_PRIORITY: The default priority of a thread. Its value is 5.
	- MAX_PRIORITY: The maximum priority that a thread can have. Its value is 10.

	These constants are typically used when setting or getting the priority of a thread using the setPriority() 
	and getPriority() methods. default priority is 5. i.e. NORM_PRIORITY


	// Thread class Constructors: 

	In the java.lang.Thread class, there are several constructors available for creating a new thread instance. 
	Here's a list of constructors:

	$- Thread(): Constructs a new thread instance.
	$- Thread(Runnable target): Constructs a new thread with the specified Runnable target.
	$- Thread(ThreadGroup group, Runnable target): Constructs a new thread with the specified ThreadGroup and Runnable target.
	$- Thread(String name): Constructs a new thread with the specified name.
	$- Thread(ThreadGroup group, String name): Constructs a new thread with the specified ThreadGroup and name.
	$- Thread(Runnable target, String name): Constructs a new thread with the specified Runnable target and name.
	$- Thread(ThreadGroup group, Runnable target, String name): Constructs a new thread with the specified ThreadGroup, 
		Runnable target, and name.
	- Thread(ThreadGroup group, Runnable target, String name, long stackSize): Constructs a new thread with the specified
		ThreadGroup, Runnable target, name, and stack size.



	// Thread class methods: 
	
	The java.lang.Thread class in Java provides a variety of methods for managing threads. Here's a list of some of the 
	commonly used methods in the Thread class:

	$- start(): Causes this thread to begin execution. The Java Virtual Machine calls the run method of this thread.
	$- run(): If this thread was constructed using a separate Runnable run object, then that Runnable object's run method is 		 called; otherwise, this method does nothing and returns.
	$- sleep(long millis): Causes the currently executing thread to sleep (temporarily cease execution) for the specified 
		number of milliseconds.
	- interrupt(): Interrupts this thread.
	- isInterrupted(): Tests whether this thread has been interrupted.
	- join(): Waits for this thread to die.
	$- setName(String name): Changes the name of this thread to the specified name.
	$- getName(): Returns the name of this thread.
	$- getPriority(): Returns the priority of this thread.
	$- setPriority(int priority): Changes the priority of this thread.
	$- getId(): return int id of thread.
	- isAlive(): Tests whether this thread is alive.
	- yield(): Causes the currently executing thread object to temporarily pause and allow other threads to execute.
                      it  gives chance to another thread to execute
	- currentThread(): Returns a reference to the currently executing thread object.
	- isDaemon(): Tests if this thread is a daemon thread.
	- setDaemon(boolean on): Marks this thread as either a daemon thread or a user thread.

-UserThread : A User Thread in Java is any thread created by the application that keeps running until it completes its task or is explicitly stopped. Unlike Daemon Threads, user threads prevent the Java program from exiting until all user threads have finished executing.

-A Daemon Thread is a low-priority background thread that runs in the JVM and terminates when all user threads have finished execution.
  (main thread/user thread finished execution  then demon thread terminated )
-Daemon threads are typically used for background tasks like garbage collection, monitoring, or logging.



===========================================================================================

Example from Youtube:

class MyThread extends Thread{

	@Override
	public void run()
	{
     System.out.println("RUNNING");
	 try{
		 Thread.sleep(2000);
	 }
	 catch(InterruptedException e){
		System.out.println(e);
	 }

	}


public static void main(String[] args) throws InterruptedException
{
	MyThread t1= new MyThread();  // MyThread();
	System.out.println(t1.getState());// NEW state
    t1.start();
    System.out.println(t1.getState()); //RUNNABLE State

	//System.out.println(Thread.currentThread().getState()); // RUNNABLE

	Thread.sleep(100);
	System.out.println(t1.getState());  //TIMED_WAITING

	t1.join(); // main method was waiting to t1 to get finish
	System.out.println(t1.getState());  //TERMINATED


	}

}

o/p:
NEW
RUNNABLE
RUNNING
TIMED_WAITING
TERMINATED


---------------- Thread VS Runnable-----

   e.g = class MyThread extends Thread{}

   e.g = public class A extends B implements Runnable();


===========================================================================================

   isInterrupted() Method : Tests whether this thread has been interrupted

import java.*;
class MyThread extends Thread {
@Override
public void run(){
    try{
        Thread.sleep(1000);
        System.out.println("Thread is Running.....");
    }
    catch(InterruptedException e){
        System.out.println("Thread Interrupted" +e);
    }

}

public static void main(String []args) throws InterruptedException{

         MyThread t1 = new MyThread();
         t1.start();
         t1.interrupt();
  }
    
}
===========================================================================================

- yield(): Causes the currently executing thread object to temporarily pause and allow other threads to execute.
                      it  gives chance to another thread to execute



import java.*;

class MyThread extends Thread {

    public MyThread(String name){
        super(name);
    }

@Override
public void run(){
    for(int i=0; i<5; i++)
    {
        System.out.println(Thread.currentThread().getName() + "is running");
        Thread.yield();
    }
}

public static void main(String []args) throws InterruptedException{

         MyThread t1 = new MyThread("T1");
         MyThread t2 = new MyThread("T2");
         t1.start();
         t2.start();
        
  }
    
}

o/p:
T2is running
T1is running
T2is running
T1is running
T2is running
T1is running
T2is running
T1is running
T2is running
T1is running

===========================================================================================

-A Daemon Thread is a low-priority background thread that runs in the JVM and terminates when all user threads have finished execution.
  (main thread/user thread finished execution  then demon thread terminated )
-Daemon threads are typically used for background tasks like garbage collection, monitoring, or logging.


import java.*;

class MyThread extends Thread {

@Override
public void run(){
    while ( true) {
        System.out.println("Hello wolrd.....");
    }
}

public static void main(String []args) throws InterruptedException{

         MyThread t1 = new MyThread();
         t1.setDaemon(true);
         MyThread t2 = new MyThread();
         t2.start();
         t1.start();
         System.out.println("Main done");
        
        
  }
    
}




Main done
Hello wolrd.....
Hello wolrd.....
==================================================================


	// simple example 

class MyThread extends Thread
{
	public MyThread() {
		System.out.println("Thread is created...!!");
	}
	public void run() {
		System.out.println("Thread is Running...!!");
	}
}
class ThreadExample
{
	public static void main(String[] args) 
	{
		System.out.println("main() started..!");
		MyThread t1 = new MyThread();
		t1.start();
		System.out.println("T1 is Running: "+t1.isAlive());
		System.out.println("main() end..!");
	}
}
// ---------- On Execution -------------
main() started..!
Thread is created...!!
Thread is Running...!!
T1 is Running: true
main() end..!
Press any key to continue . . .

//--------------------------------------------------------------------------------------------

	// Creating the main and one userdefined thread

class MyThread extends Thread
{
	public MyThread() {
		System.out.println("Thread is created...!!");
	}
	public void run() {
		for(int i=0 ;i<20 ; i++) {
			System.out.println(this);
			try{Thread.sleep(200);}catch(Exception e){}
		}
	}
}
class ThreadExample
{
	public static void main(String[] args) 
	{
		System.out.println("main() started..!");
		MyThread t1 = new MyThread();
		t1.start();
		System.out.println("T1 is Running: "+t1.isAlive());
		for(int i=0 ;i<20 ; i++) {
			System.out.println(Thread.currentThread());
			try{Thread.sleep(400);}catch(Exception e){}
		}
		System.out.println("main() end..!");
	}
}

//--------------------------------------------------------------------------------

	// Creating Multiple threads of same type

class MyThread extends Thread
{
	public MyThread() {
		System.out.println("Default - Thread is created...!!");
	}	
	public MyThread(String name) {  //setName Method
		super(name);
		System.out.println("Para - Thread is created...!!");
	}
	public void run() {
		for(int i=0 ;i<20 ; i++) {
			System.out.println(this);
			try{Thread.sleep(200);}catch(Exception e){}
		}
	}
}
class ThreadExample
{
	public static void main(String[] args) 
	{
		System.out.println("main() started..!");
		MyThread t1 = new MyThread("One");
		t1.setPriority(1);
		t1.start();
		MyThread t2 = new MyThread("Two");
		t2.setPriority(10);
		t2.start();
		System.out.println("T1 is Running: "+t1.isAlive());
		for(int i=0 ;i<20 ; i++) {
			System.out.println(Thread.currentThread());
			try{Thread.sleep(400);}catch(Exception e){}
		}
		System.out.println("main() end..!");
	}
}

//--------------------------------------------------------------------------------

	// Creating Multiple threads of Different type

class MyThread extends Thread
{
	public MyThread() {
		System.out.println("Default - MyThread is created...!!");
	}	
	public MyThread(String name) {
		super(name);
		System.out.println("Para - MyThread is created...!!");
	}
	public void run() {
		for(int i=0 ;i<20 ; i++) {
			System.out.println(this);
			try{Thread.sleep(200);}catch(Exception e){}
		}
	}
}
class YourThread extends Thread
{
	public YourThread() {
		System.out.println("Default - YourThread is created...!!");
	}	
	public YourThread(String name) {
		super(name);
		System.out.println("Para - YourThread is created...!!");
	}
	public void run() {
		for(int i=0 ;i<20 ; i++) {
			System.out.println(this.getName());
			try{Thread.sleep(200);}catch(Exception e){}
		}
	}
}
class ThreadExample
{
	public static void main(String[] args) 
	{
		System.out.println("main() started..!");

		MyThread t1 = new MyThread("One");
		t1.setPriority(1);
		t1.start();

		YourThread t2 = new YourThread("Two");
		t2.setPriority(10);
		t2.start();

		System.out.println("T1 is Running: "+t1.isAlive());
		for(int i=0 ;i<20 ; i++) {
			System.out.println(Thread.currentThread().getName());
			try{Thread.sleep(400);}catch(Exception e){}
		}
		System.out.println("main() end..!");
	}
}

//-----------------------------------------------------------------------------------------

	// Using ThreadGroup

class MyThread extends Thread
{
	public MyThread() {
		System.out.println("Default - MyThread is created...!!");
	}	
	public MyThread(ThreadGroup tg, String name) {
		super(tg, name);
		System.out.println("Para - MyThread is created...!!");
	}
	public void run() {
		for(int i=0 ;i<20 ; i++) {
			System.out.println(this);
			try{Thread.sleep(200);}catch(Exception e){}
		}
	}
}
class YourThread extends Thread
{
	public YourThread() {
		System.out.println("Default - YourThread is created...!!");
	}	
	public YourThread(ThreadGroup tg,String name) {
		super(tg, name);
		System.out.println("Para - YourThread is created...!!");
	}
	public void run() {
		for(int i=0 ;i<20 ; i++) {
			System.out.println(this.getName());
			try{Thread.sleep(200);}catch(Exception e){}
		}
	}
}
class ThreadExample
{
	public static void main(String[] args) 
	{
		System.out.println("main() started..!");

		ThreadGroup tg = new ThreadGroup("MyGroup");

		MyThread t1 = new MyThread(tg,"One");
		t1.setPriority(1);
		t1.start();

		YourThread t2 = new YourThread(tg,"Two");
		t2.setPriority(10);
		t2.start();

		System.out.println("T1 is Running: "+t1.isAlive());
		for(int i=0 ;i<20 ; i++) {
			System.out.println(Thread.currentThread().getName());
			try{Thread.sleep(400);}catch(Exception e){}
		}
		System.out.println("main() end..!");
	}
}

//---------------------------------------------------------------------------------------------------------------------------

	// Using Runnable Interface to create the Threads.
	//===================================================

class DemoThread implements Runnable
{
	public void run() {
		for(int i=0 ;i<20 ; i++) {
			System.out.println(Thread.currentThread().getName());
			try{Thread.sleep(200);}catch(Exception e){}
		}
	}
}
class ExampleThreadRunnable 
{
	public static void main(String[] args) 
	{
		System.out.println("Main start....!!");

		DemoThread d1 = new DemoThread();
		Thread t1 = new Thread(d1);
		t1.start();

		for(int i=0 ;i<20 ; i++) {
			System.out.println(Thread.currentThread().getName());
			try{Thread.sleep(400);}catch(Exception e){}
		}
		System.out.println("main() end..!");
	}
}

//-----------------------------------------

	// Another Way

class DemoThread implements Runnable
{
	Thread t=null;
	public  DemoThread() {
		t=new Thread(this);
		t.setName("Dthread");
		t.start();
	}
	public void run() {
		for(int i=0 ;i<20 ; i++) {
			System.out.println(t.getName());
			try{Thread.sleep(200);}catch(Exception e){}
		}
	}
}
class ExampleThreadRunnable 
{
	public static void main(String[] args) 
	{
		System.out.println("Main start....!!");
		DemoThread d1 = new DemoThread();

		for(int i=0 ;i<20 ; i++) {
			System.out.println(Thread.currentThread().getName());
			try{Thread.sleep(400);}catch(Exception e){}
		}
		System.out.println("main() end..!");
	}
}

//--------------------------------------------------------------------------------

	// calling start() from outside

class DemoThread implements Runnable
{
	Thread t=null;
	public  DemoThread() {
		t=new Thread(this);
		t.setName("Dthread");
	}
	public void run() {
		for(int i=0 ;i<20 ; i++) {
			System.out.println(Thread.currentThread().getName());
			try{Thread.sleep(200);}catch(Exception e){}
		}
	}
}
class ExampleThreadRunnable 
{
	public static void main(String[] args) 
	{
		System.out.println("Main start....!!");
		DemoThread d1 = new DemoThread();
		d1.t.start();
		for(int i=0 ;i<20 ; i++) {
			System.out.println(Thread.currentThread().getName());
			try{Thread.sleep(400);}catch(Exception e){}
		}
		System.out.println("main() end..!");
	}
}

//--------------------------------------------------------------------------------------------------

	// Using the anonymous inner class:

	// Using Thread class
class DemoAnoThread 
{
	public static void main(String[] args) 
	{
		System.out.println("Main Started...!!!");

		Thread t1 = new Thread() {
			public void run() {
				for(int i=0 ; i<20 ; i++) {
					System.out.println("t1 - "+i);
					try{ Thread.sleep(600); } catch(Exception e){}
				}
			}
		};
		t1.start();

		for(int i=0 ; i<20 ; i++) {
				System.out.println("main - "+i);
				try{ Thread.sleep(1200); } catch(Exception e){}
		}

		System.out.println("Main ended...!!!");
	}
}

//--------------------

	// Using Runnable Interface


class DemoAnoInterface
{
	public static void main(String[] args) 
	{
		System.out.println("Main Started...!!!");

		Thread t1 = new Thread( new Runnable() {
			public void run() {
				for(int i=0 ; i<20 ; i++) {
					System.out.println("t1 - "+i);
					try{ Thread.sleep(1200); } catch(Exception e){}
				}
			}
		});
		t1.start();

		Thread t2 = new Thread( new Runnable() {
			public void run() {
				for(int i=0 ; i<20 ; i++) {
					System.out.println("t2 - "+i);
					try{ Thread.sleep(1200); } catch(Exception e){}
				}
			}
		});
		t2.start();

		for(int i=0 ; i<20 ; i++) {
				System.out.println("main - "+i);
				try{ Thread.sleep(1200); } catch(Exception e){}
		}

		System.out.println("Main ended...!!!");
	}
}

//------------------------------------------------------------------------------------------------------------------------

	// Thread Transaction: changing the thread states

	// Suspend and resume() methods:

	- Suspend() method puts thread from running to waiting state. And thread can go from waiting to runnable state 
		    only when resume() method is called on thread. Suspend method is deprecated method.
	- Resume() method is only used with suspend() method that’s why it’s also deprecated method.

	Suspend() and resume() are deprecated methods and marked for removal because if not used properly they might 
	lead to deadlock.

//-------------------------------------------------------------------------------------------------------------------------

	// Using interrupt() method: 

	- used to interrupt an executing Thread and for that it will set interrupt status true.
	- interrupt() method will work when thread is in sleeping or waiting state.
	- when thread is not in sleeping or waiting state then calling the interrupt() method will perform normal behavior.
	- when we use an interrupt() method, it throws an InterruptedException, and then thread execution is terminated.

class MyThread extends Thread
{
	public void run()
	{
		try
		{
			for(int i=0;i<15;i++)
			{
				System.out.println(i + " - "+this);
				Thread.sleep(3000);
			}
		}
		catch (InterruptedException e)
		{
			System.out.println("Thread t1 Terminated");
		}
	}
}
class InterruptExample 
{
	public static void main(String[] args) 
	{
		MyThread t1=new MyThread();
		t1.start();

		try
		{
			for(int i=0;i<15;i++)
			{
				System.out.println("main - "+ i);
				Thread.sleep(600);
				if(i==5)
					t1.interrupt();
			}
		}
		catch(Exception e){}

		
	}
}

//-------------------

	// interrupted() and isInterrupted():

		- Both returns true when thread is interrupted, otherwise both will return false.
		- Note that the call to interrupt() method will generates the InterruptedException only when the interrupt status
		  is ture.
		- Difference is that interrupted() method changes the interrupted status from true to false but isInterrupted()
		  does not affact the interrupted status.
		- interrupted() will change the result, but isInterrupted() wil not change the result if called twice.
		- method signature: 
			- public static boolean interrupted()
			- public boolean isInterrupted()


///-------------------------------------------------------------------------------------------------------------------------------

	// Using the yield() methods:

		- will stops current executing thread and gives chance to other thread.
		- Till Java 5, internally the sleep() was used but from Java 6 Onwords it will informs to scheduler 
		  about the his opinion, but it is decided by scheduler

class MyThread extends Thread
{
	public MyThread(String name)
	{
		super(name);
		start();
	}
	public void run()
	{
		try
		{
			for(int i=0;i<20;i++)
			{
				System.out.println(i+" - "+this.getName());
				Thread.sleep(300);
			}
		}
		catch (Exception e)
		{
		}
	}
}
class  ThreadYieldExample
{
	public static void main(String[] args) 
	{
		MyThread t1=new MyThread("One");
		MyThread t2=new MyThread("Two");
		MyThread t3=new MyThread("Three");
		MyThread t4=new MyThread("Four");
		MyThread t5=new MyThread("Five");
		try
		{
			t3.yield();
			for(int i=0;i<20;i++)
			{
				System.out.println("Hi");
				Thread.sleep(300);
			}
		}
		catch (Exception e)
		{
		}
	}
}

//-------------------------------------------------------------------------------

	// Using the join() and isAlive()

	
	The join() method in Java is a part of the Thread class and is used to ensure that one thread waits for 
	the completion of another thread before proceeding further. It provides a way to pause the execution of 
	the current thread until the thread on which join() is called finishes its execution.

	public final void join() throws InterruptedException
	public final void join(long millis) throws InterruptedException
	public final void join(long millis, int nanos) throws InterruptedException

	The current thread will wait for the specified number of milliseconds for the target thread to complete. 
	If the target thread does not finish in that time, the current thread resumes execution.


	isAlive(): 

	The isAlive() method in Java is part of the Thread class and is used to check whether a thread is currently 
	active or alive. A thread is considered alive when it has been started and has not yet finished its execution.

	returns true: If the thread has been started (using start()) and has not yet terminated. otherwise false

class MyThread extends Thread
{
	public void run() {
		for(int i=0 ; i<20 ; i++) {
			System.out.println(this.getName()+" - "+i);
			try{ Thread.sleep(600); } catch(Exception e){}
		}
	}
}
class YourThread extends Thread
{
	public YourThread() {
		super("Test_Thread");
	}
	public void run() {
		for(int i=0 ; i<20 ; i++) {
			System.out.println(this.getName()+" - "+i);
			try{ Thread.sleep(200); } catch(Exception e){}
		}
	}
}
class DemoJoinMethod
{
	public static void main(String[] args) 
	{
		MyThread t1 = new MyThread();
		t1.start();
        
		YourThread t2 = new YourThread();
		t2.start();
		
		MyThread t3 = new MyThread();
		t3.start();
        
        	for(int i=0 ; i<20 ; i++) {
			System.out.println("main - "+i);
			System.out.println("T2 is Alive - "+t2.isAlive());
			try{ Thread.sleep(600); } catch(Exception e){}
			if(i==5) {
				try{ t2.join(); } catch(Exception e){}
			}
		}
		
	}
}

///-------------------------------------------------------------------------------------------------------------------------

	Thread Synchronization
	------------------------
	
	Synchronization is a process of handling resource accessibility by multiple thread requests. The main purpose 
	of synchronization is to avoid thread interference. At times when more than one thread try to access a shared 
	resource, we need to ensure that resource will be used by only one thread at a time. The process by which 
	this is achieved is called synchronization. 

	in simple terms, When two or more threads need access to a shared resource, they need some way to ensure that 
	the resource will be used by only one thread at a time. The process by which this is achieved is called 
	synchronization. Java implements synchronization through use of the synchronized keyword.

	Why we need Syncronization?
	If we do not use syncronization, and let two or more threads access a shared resource at the same time, it 
	will lead to distorted results.

	Lets consider the Shared Resource (Object of Message class), which is accessed by multiple threads.

class Message
{
	public void show() {
		System.out.println("Hello ");
		System.out.println("All ");
		System.out.println("good ");
		try{ Thread.sleep(1600); } catch(Exception e){}
		System.out.println("afternoon ");
		System.out.println("to ");
		System.out.println("all ");
		try{ Thread.sleep(2600); } catch(Exception e){}
		System.out.println("of ");
		System.out.println("you ");
	}
}
class DemoThread extends Thread
{
	Message msg;
	public DemoThread(Message ob) {
		msg = ob;
	}
	public void run() {
		msg.show();
	}
}
class DisplayMessageExample
{
	public static void main(String[] args) 
	{
		Message ob = new Message();

		DemoThread t1 = new DemoThread(ob);
		t1.start();

		DemoThread t2 = new DemoThread(ob);
		t2.start();
	}
}

//----------- output -----------

Hello
All
good
Hello
All
good
afternoon
afternoon
to
all
to
all
of
you
of
you
Press any key to continue . . .

//-------------------------------------------------------

	The synchronized keyword in Java is used to handle thread synchronization, ensuring that only one 
	thread can access a critical section of code at a time. This prevents race conditions and ensures 
	thread safety when multiple threads are accessing shared resources.

	When a thread enters a synchronized block or method, it acquires a lock (monitor) on the object or 
	class. Other threads trying to execute synchronized code on the same object or class must wait until 
	the lock is released.

	Note some important terms:
	
	- A lock is a mechanism that allows only one thread to access a shared resource (like a variable or a 
	  critical section of code) at a time. Locks ensure mutual exclusion, preventing data inconsistency 
	  caused by concurrent access.

		- Every object in Java has an intrinsic lock or monitor lock, which is used in conjunction with 
		  the synchronized keyword.
		- Explicit locks, like those provided by java.util.concurrent.locks.Lock, offer more advanced 
		  features such as try-lock and timed-lock.

	- A monitor is a synchronization construct that is built into each Java object. It combines:
		- Mutual exclusion (lock): Ensures that only one thread can execute a synchronized method or 
		  block at a time.
		- Thread coordination (wait/notify): Helps threads coordinate their execution using methods 
		  like wait(), notify(), and notifyAll().
	   A monitor is automatically associated with a synchronized method or block in Java. When a thread enters 
	   a synchronized method or block, it acquires the monitor lock for the object. No other thread can enter 
	   any synchronized code on the same object until the monitor is released.

	- A mutex is a synchronization primitive that ensures mutual exclusion, meaning only one thread can access 
	  a critical section at a time. It is conceptually similar to a lock, but the term is more general and widely 
	  used across programming languages.
	  In Java, the intrinsic lock of an object (used with synchronized) or explicit locks (like ReentrantLock) 
	  can act as a mutex.

	- A race condition occurs when two or more threads access shared data concurrently, and the result of the 
	  program depends on the timing of their execution. This often leads to unpredictable behavior or incorrect 
	  results.

//-------------------------------------------------------
=========================================================================================
=========================================================================================
=========================================================================================
              
                                          Synchronization in You tube Video

  Synchronization in Video: if one object is shared between multiple threads then we got the incorrect result.(incorrect result occurs 
                            due to shared data between resources ) the place where shared sources are access or modify using method this     
                             part of program called critical section.

Synchronized Method 
Synchronized bock:  

Syntax:  Synchronized (this){  // this refers to only one instance
             count++;
          }

locking: if one thread (T1) access the shared resource then it apply lock so  that another threads (T1, T2) can not access e shared resource 
Types of Locks:
               1.Intrinsic:These are the built into every object in Java.you don't see them but they're there. 
                            when you use synchronised keyword you're using this automatic locks

               2.Explicit: These are more advanced locks you can control yourself using the locks class from java.util.concurrent.locks
                            you explicitly say when to unlock, giving you more control over how and (when people can write in the notebook = e.g)


There are some issues in Synchronized: Using synchronized, we do not have control over the order in which threads acquire the lock, nor can we specify the duration for which a thread will hold the lock before releasing it.

e.g of Notebook as shared Resource : Using Synchronized we don't have control over who write first or last in notebook, for how many period 
                                         of time they will be written.

 using locks we can give specific time to access the resources

 locks is interface
 private Lock lock = new ReentrantLock();

 ReentrantLock is class which implements lock interface .it is use to as deadlock prevention


=========================================================================================
=========================================================================================
=========================================================================================
//-------------------------------------------------------


class Message
{
	synchronized public void show() {
		System.out.println("Hello ");
		System.out.println("All ");
		System.out.println("good ");
		try{ Thread.sleep(1600); } catch(Exception e){}
		System.out.println("afternoon ");
		System.out.println("to ");
		System.out.println("all ");
		try{ Thread.sleep(2600); } catch(Exception e){}
		System.out.println("of ");
		System.out.println("you ");
	}
}
class DemoThread extends Thread
{
	Message msg;
	public DemoThread(Message ob) {
		msg = ob;
	}
	public void run() {
		msg.show();
	}
}
class DisplayMessageExample
{
	public static void main(String[] args) 
	{
		Message ob = new Message();

		DemoThread t1 = new DemoThread(ob);
		t1.start();

		DemoThread t2 = new DemoThread(ob);
		t2.start();
	}
}

//----------- Output ------------
Hello
All
good
afternoon
to
all
of
you
Hello
All
good
afternoon
to
all
of
you
Press any key to continue . . .

//-----------------------------------------------------------------------------------------------------------------

	In java, the synchronization is achieved using the following concepts.

	- Mutual Exclusion (Using Synchronized keyword)
	- Inter thread communication (wait(), notify() notifyAll() )


	Mutual Exclusion(Mutex) [Exclusion-The act of not allowing someone or something to take part in an activity or 
	to enter a place] Using the mutual exclusion process, we keep threads from interfering with one another while 
	they accessing the shared resource. In java, mutual exclusion is achieved using the following concepts.

	- Synchronized method
	- Synchronized block
	- Static synchronization.


	// - Synchronized method

	When a method defined using a synchronized keyword, it allows only one Thread to access resource at a time. 
	When an object calls a synchronized method, it put a lock on that method so that other objects or thread 
	that are trying to call the same method must wait, until the lock is released. Once the lock is released 
	on the shared resource, one of the threads among the waiting threads will be start using the shared 
	resource again.

	lets see the above exampe with the synchronized keyword...!!

class Resource
{
	private String []data = {"hello", "Good day", "to", "all", "of you","wish", "you ", "all the", "best"};
	
	synchronized public void show() {
		System.out.println("The Data is: ");
		for( int i=0 ; i<data.length ; i++ ) {
			try{ Thread.sleep(600); } catch(Exception e){}
			System.out.println(data[i]);
		}
	}
}
class DemoSyncMethod
{
	public static void main(String[] args) 
	{
		System.out.println("Main started");

		Resource rob = new Resource();

		// Thread 1
		Thread t1 = new Thread(){
			public void run() {
				rob.show();
			}
		};
		t1.start();

		// Thread 2
		Thread t2 = new Thread(){
			public void run() {
				rob.show();
			}
		};
		t2.start();

		System.out.println("Main ended");
	}
}

//----------------------------------------------------------

	// what is thread-safe and non thread-safe in java multithreading?

   In Java multithreading, "thread-safe" refers to code or data structures that can be safely accessed and manipulated 
   by multiple threads concurrently without causing any issues such as data corruption, race conditions, or 
   unexpected behavior. On the other hand, "non-thread-safe" refers to code or data structures that are not designed 
   to handle concurrent access from multiple threads and may lead to problems if accessed concurrently.

  Thread-Safe:
	- Thread-safe code ensures that shared data structures or resources are accessed in a synchronized manner 
	  to prevent concurrent modification issues.
	- Thread-safe classes often use synchronization mechanisms such as locks, mutexes, or atomic operations to 
	  ensure mutual exclusion.
	- Examples of thread-safe classes in Java include StringBuffer.

  Non-Thread-Safe:
	- Non-thread-safe code or data structures do not provide mechanisms to handle concurrent access safely.
	- Accessing non-thread-safe code concurrently may lead to race conditions, data corruption, or inconsistent 
	  behavior.
	- Examples of non-thread-safe classes in Java include ArrayList and HashMap. These classes are not synchronized, 
	  so concurrent access without external synchronization can lead to issues.


//------------------------------------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------------------------------

     

           **************************  Thread-Safe in video *****************
     
Thread-Safe: Thread safety ensures that when multiple threads access an object or a block of code simultaneously, it does not produce unexpected results. 
                Race Condition or data Corruption does not happen then it called as Thread safe. 

  -we use Synchronized, ReentrantLock, Read-WriteLock, Wait, notify are all uses to make thread safe


//------------------------------------------------------------------------------------------------------------------

  Runnable is a functional Interface which conations only one abstract method. so its implementation can be write using lambda expression
  
  lambda expression Can be assigned to Runnable or functional interface Reference.
   

Lambda Expressions Syntax:

 Runnable runnable = ()  -> {
                 
      	System.out.println("Hello world");
       
     };


 1. Anonymous Function (Lambda Expressions)

  Usage - Used for functional interfaces


An anonymous function, also called a lambda expression, is a function without a name. It is mainly used to simplify functional programming, especially when working with functional interfaces like Runnable, Comparator, etc.


interface MathOperation {
    int operate(int a, int b);
}

public class LambdaExample {
    public static void main(String[] args) {

        // Lambda Expression (Anonymous Function)
        MathOperation addition = (a, b) -> a + b;

        int result = addition.operate(5, 3);
        System.out.println("Addition Result: " + result); // Output: 8
    }
}


       2. Anonymous Class:

Usage :  Used for classes and interfaces

An anonymous class is a class without a name that is declared and instantiated in a single expression. It is typically used when we need a one-time-use implementation of an interface or a subclass.

abstract class Animal {
    abstract void makeSound();
}

public class AnonymousClassExample {
    public static void main(String[] args) {
        Animal dog = new Animal() {       // Anonymous Class
            @Override
            void makeSound() {
                System.out.println("Bark! Bark!");
            }
        };

        dog.makeSound(); // Output: Bark! Bark!
    }
}


   


//------------------------------------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------------------------------



	// Using Synchronized block (Object level Synchronization)

	Synchronized block in Java is another way of managing the execution of threads. It is mainly used to perform 
	synchronization on a certain block of code or statements inside the method.

	Synchronizing a block of code is more powerful than synchronized method. For example, suppose there are 30 lines 
	of code in a method, but we want to synchronize only 5 lines of code. In this case, we should use a synchronized 
	block.

	If we place all the codes of the method in the synchronized block, it will work the same as the synchronized 
	method.

	lets see the example below, in which there are two different instruction groups(blocks) enclosed witin scope
	of synchronized keyword. It requres an object of any type, which is considered as a lock. and all 
	such synchronized blocks will be restricted to paralled execution, having a same lock.

class Resource
{
	private String []data1 = {"hello", "Good day", "to", "all", "of you","wish", "you ", "all the", "best"};
	private String []data2 = {"THIS", "IS", "THE", "ANOTHER", "MESSAGE","DISPLAYED", "USING ", "DIFFERENT", "METHOD"};
	Object lock = new Object();
	 public void show() {
		System.out.println("The Data show() is: ");
		
		synchronized(lock) {
			for( int i=0 ; i<data1.length ; i++ ) {
				try{ Thread.sleep(600); } catch(Exception e){}
				System.out.println(data1[i]);
			}
		}
		System.out.println("End of show() ");
	}	
	public void display() {
		System.out.println("The Data display() is: ");

		synchronized(lock) {
			for( int i=0 ; i<data2.length ; i++ ) {
				try{ Thread.sleep(600); } catch(Exception e){}
				System.out.println(data2[i]);
			}
		}
		System.out.println("End of display() ");
	}
}
class DemoSyncMethod
{
	public static void main(String[] args) 
	{
		Resource rob = new Resource();

		// Thread 1
		Thread t1 = new Thread(){
			public void run() {
				rob.show();
			}
		};
		t1.start();

		// Thread 2
		Thread t2 = new Thread(){
			public void run() {
				rob.display();
			}
		};
		t2.start();

	}
}

	* Note: when two different objects are there used as a lock, the we will see the 
	        parallel execution.(like unsynchronized)

//-----------------------------------------------------------------------------------------------------------------

	
	- Static synchronization (class level synchronization)
	------------------------------------------------------

	Static synchronization in Java involves synchronizing access to a shared resource using a static keyword. When 
	a method is declared as static synchronized, only one thread can execute that method at a time for the entire 
	class, not just for the object instance.

			    ob1				    ob2	
		t1 -------> [ print() ]		t11 -------> [ print()  ]
			      ^				       ^
			      |				       |
			     t2                               t22

	In the example below, there are two different objects of type ShowArray, and each will be accessed using a pair
	of threads in synchronized manner. But as the synchronization is at instance(object) level, a single thread from
	each pair will execute at a time.


			    ob1				    ob2	
		t1 -------> [      ] ====== print()====== [   ] <------- t11
			      ^	    (common to all objects)    ^
			      |				       |
			     t2                               t22

class Resource
{
	private static String []data = {"hello", "Good day", "to", "all", "of you","wish", "you ", "all the", "best"};
	
	synchronized static public void show() {
		System.out.println("The Data is: ");
		for( int i=0 ; i<data.length ; i++ ) {
			try{ Thread.sleep(600); } catch(Exception e){}
			System.out.println(Thread.currentThread().getName()+" - "+data[i]);
		}
	}
}
class StaticSyncMethod
{
	public static void main(String[] args) 
	{
		System.out.println("Main started");

		Resource rob1 = new Resource();
		Resource rob2 = new Resource();

		// Thread 1
		Thread t1 = new Thread(){
			public void run() {
				rob1.show();
			}
		};
		t1.setName("One");
		t1.start();

		// Thread 2
		Thread t2 = new Thread(){
			public void run() {
				rob1.show();
			}
		};
		t2.setName("Two");
		t2.start();

		//-----------------------------------

		// Thread 3
		Thread t3 = new Thread(){
			public void run() {
				rob2.show();
			}
		};
		t3.setName("Three");
		t3.start();

		// Thread 4
		Thread t4 = new Thread(){
			public void run() {
				rob2.show();
			}
		};
		t4.setName("Four");
		t4.start();

		System.out.println("Main ended");
	}
}

//----------------------------------------------------------------------------------
                            Thread communication

          Thread communication:
                       without proper communication mechanism Threads might end up in inefficient busy-waiting states,
                        leading to wastage of CPU resources and potential deadlocks.

	
	- Inter thread communication (wait(), notify() notifyAll() ): Another way of achieving synchronization.

	You might have noticed Object class has three final method called wait(), notify() and notifyAll(). 
	These methods are used for inter thread communication. Java 5 has introduced executor framework which takes 
	care of inter thread communication for you and internally uses wait(), notify() and notifyAll()
	but you still require basic understanding of these methods and how inter thread communication works in 
	java using wait(), notify() and notifyAll().

 	- What are wait(), notify() and notifyAll() methods?
	 ----------------------------------------------
	wait(), notify() and notifyAll() methods are used to allow threads to communicate to each other via accessing 
	common object or in other terms, Object can be considered a medium for inter thread communication via these 
	methods. These methods need to be called from synchronized context, otherwise it will throw 
	java.lang.IllegalMonitorStateException.

 	- Some background on synchronized block :
 	-------------------------------------------
		- Only one thread can enter at a time in synchronized block.
		- A thread required lock on the object to enter in synchronized block.
		- If Thread A want to enter in synchronized block then Thread A has to wait for Thread B to release it.

	Lets see wait(), notify() and notifyAll() methods:

	- wait(): When you call wait method on the object then it tell threads to give up the lock and go to sleep state 
		unless and until some other thread enters in same monitor and calls notify() or notifyAll() methods on it.

	- notify(): When you call notify method on the object, it wakes one of thread waiting for that object. 
	            So if multiple threads are waiting for an object, it will wake of one of them. Now you must be 
		    wondering which one it will wake up. It actually depends on OS implementation.

	- notifyAll(): notifyAll will wake up all threads waiting on that object unlike notify which wakes up only one of them.
		       Which one will wake up first depends on thread priority and OS implementation.
                
             e.g: When more than one thread are waiting then use notifyAll. OR when there is one producer and multiple Consumer then use notifyAll

           - Notify()- notify other threads to produce or Consume data.

 // lets see, how wait() and notify() works in synchronized environment


import java.util.Random;
class Cart extends Thread
{
	double bill=0.0;
	public double getBill(){return bill;}
	public void run()
	{
		for(int i=0;i<5;i++)
		{
			try{Thread.sleep(400);}catch(Exception e){}
				System.out.println("Waiting....."+i);
		}
		synchronized(this)
		{
			for(int i=0;i<5;i++)
			{
			
				try{Thread.sleep(400);}catch(Exception e){}
				int price=new Random().nextInt(200);
				System.out.println("Item "+(i+1)+" Price: "+price);
				bill=bill+price;
			}
			this.notify();
		}
	}
}
class ShoppingMain 
{
	public static void main(String[] args) 
	{
		Cart c1=new Cart();
		c1.start();
		
		synchronized(c1)
		{
			for(int i=0;i<20;i++)
			{
				try{Thread.sleep(400);}catch(Exception e){}
					System.out.println("Main()....."+i);
				if(i==10)
				{
					try{c1.wait();}catch(Exception e){}
				}
			}
		}

		System.out.println("Total Bill: "+c1.getBill());
	}
}

//----------------------------------------------------------------------------------------------

	//  By eliminating delays

import java.util.Random;
class Cart extends Thread
{
	double bill=0.0;
	public double getBill(){return bill;}
	public void run()
	{
		synchronized(this)
		{
			for(int i=0;i<5;i++)
			{
			
				try{Thread.sleep(400);}catch(Exception e){}
				int price=new Random().nextInt(200);
				System.out.println("Item "+(i+1)+" Price: "+price);
				bill=bill+price;
			}
			this.notify();
		}
	}
}
class ShoppingMain1
{
	public static void main(String[] args) 
	{
		Cart c1=new Cart();
		c1.start();
		
		synchronized(c1)
		{
			try{c1.wait();}catch(Exception e){}
		}

		System.out.println("Total Bill: "+c1.getBill());
	}
}

//-------------------------------------------------------------------------------

	// Same program using the common lock for synchronized block in different classes


import java.util.Random;
class Cart extends Thread
{
	Object lock;
	double bill=0.0;
	public Cart( Object lock) {
		this.lock = lock;
	}
	public double getBill(){return bill;}
	
	public void run()
	{
		for(int i=0;i<5;i++)
		{
			try{Thread.sleep(400);}catch(Exception e){}
				System.out.println("Waiting....."+i);
		}
		synchronized(lock)
		{
			for(int i=0;i<5;i++)
			{
			
				try{Thread.sleep(400);}catch(Exception e){}
				int price=new Random().nextInt(200);
				System.out.println("Item "+(i+1)+" Price: "+price);
				bill=bill+price;
			}
			lock.notify();
		}
	}
}
class TaskCaller extends Thread
{
	Object lock;
	Cart c1;
	public TaskCaller(Object lock, Cart c1) {
		this.lock = lock;
		this.c1 = c1;
	}
	public void run() {
		synchronized(lock)
		{
			for(int i=0;i<20;i++)
			{
				try{Thread.sleep(400);}catch(Exception e){}
					System.out.println("Main()....."+i);
				if(i==10)
				{
					try{lock.wait();}catch(Exception e){}
				}
			}
		}
		System.out.println("Total Bill: "+c1.getBill());
	}
}
class ShoppingMainLock
{
	public static void main(String[] args) 
	{
		Object lock = new Object();

		Cart c1=new Cart(lock);
		c1.start();

		TaskCaller t1 = new TaskCaller(lock, c1);
		t1.start();
		
		
	}
}
//--------------------------------------------------------------------------------------------------

	// Lets write another program

class Resource
{
	public void sayHi(){
		System.out.println("Hi...!!");
	}
	public void sayHello(){
		System.out.println("Hello...!!");
	}
}

class MainExampleResource
{
	public static void main(String []args)
	{
		Resource rob = new Resource();

		Thread t1 = new Thread(){
			public void run(){
				for(int i=0 ; i<7 ; i++){
					rob.sayHi();
					try{Thread.sleep(500);}catch(Exception e){}
				}
			}
		};

		Thread t2 = new Thread(){
			public void run(){
				for(int i=0 ; i<7 ; i++){
					rob.sayHello();
					try{Thread.sleep(500);}catch(Exception e){}
				}
			}
		};
	}
}

//---------------------------------------------------------------------------

	// In above program we dont have the control over the thread execution, to gaing the control
	// we need to make the shared resource synchronized, and to gain the greater control, we need 
	// to use wait() and notify() as shown below. 

	// here only Synchronization, will gives the guranty that one thread will access the resource 
	// at a time, but will not gives the confirmation that they will execute alternatively.

class Message
{
	boolean respond=false;
	synchronized void displayHi()
	{
		if(!respond)
		{
			try{ wait(); } catch(Exception e){}
		}
		System.out.println("Hi");
		respond=false;
		notify();
	}
	synchronized void displayHello()
	{
		if(respond)
		{
			try{ wait(); } catch(Exception e){}	
		}
		System.out.println("Hello");
		respond=true;
		notify();
	}
}

class SynchroDemo1
{
	public static void main(String []args)
	{
		Message ob=new Message();

		Thread t1 = new Thread(){
			public void run() {
				while(true) {
					ob.displayHi();
					try{Thread.sleep(300);}catch(Exception e){}
				}
			}
		};
		t1.start();

		Thread t2 = new Thread(){
			public void run() {
				while(true) {
					ob.displayHello();		
					try{Thread.sleep(700);}catch(Exception e){}
				}
			}
		};
		t2.start();
	}
}
//--------------------------------------------------------------------------------------------------------------------------
//--------------------------------------------------------------------------------------------------------------------------

	/// // Producer-Consumer Problem (Using wait() notify() )  - block synchronization implementation

	The Producer-Consumer Problem (sometimes called the Bounded-Buffer Problem) is a classic example of a 
	multi-threaded synchronization problem.

	The problem describes two threads, the Producer and the Consumer, and they are sharing a common, fixed-size 
	resource.

	The Producer produces an item, puts that item into the resource(increases value by 1), and keeps repeating this 
	process. On the other hand, the Consumer is consuming the item from the shared resource(decreases value by 1), 
	one item at a time.

class Resource
{
	int value;
	{value = 0;}
	public int getValue(){return value;}
	public void produce() {
		value++;
		System.out.println("Produced - Value: "+value);
	}
	public void consume() {
		value--;
		System.out.println("Consumed - Value: "+value);
	}
}
class Producer extends Thread
{
	Resource rob;
	public Producer(Resource rob) {
		this.rob = rob;
	}
	public void run() {
		synchronized(rob) {
			for(int i=0 ; i<15 ; i++) {
				if(rob.getValue()==1)
				{
					try{ rob.wait(); } catch(Exception e){}
				}
				try{Thread.sleep(300);}catch(Exception e){}
				rob.produce();
				rob.notify();
			}
		}
	}
}
class Consumer extends Thread
{
	Resource rob;
	public Consumer(Resource rob) {
		this.rob = rob;
	}
	public void run() {
		synchronized(rob) {
			for(int i=0 ; i<15 ; i++) {
				if(rob.getValue()==0)
				{
					try{ rob.wait(); } catch(Exception e){}
				}
				try{Thread.sleep(300);}catch(Exception e){}
				rob.consume();
				rob.notify();
			}
		}
	}
}
class ProducerConsumerExample
{
	public static void main(String[] args) 
	{
		Resource rob = new Resource();

		Producer p = new Producer(rob);
		Consumer c = new Consumer(rob);

		p.start();
		c.start();
	}
}

//---------------------------------------------------------------------------------------------------------

	// Above program using Anonymous Class

class Resource
{
	int value;
	{value = 0;}
	public int getValue(){return value;}
	public void produce() {
		value++;
		System.out.println("Produced - Value: "+value);
	}
	public void consume() {
		value--;
		System.out.println("Consumed - Value: "+value);
	}
}

class ProducerConsumerExample
{
	public static void main(String[] args) 
	{
		Resource rob = new Resource();

		// Producer
		Thread p = new Thread(){
			public void run() {
				synchronized(rob) {
					for(int i=0 ; i<15 ; i++) {
						if(rob.getValue()==1)
						{
							try{ rob.wait(); } catch(Exception e){}
						}
						try{Thread.sleep(300);}catch(Exception e){}
						rob.produce();
						rob.notify();
					}
				}
			}
		};

		// Consumer
		Thread c = new Thread(){
			public void run() {
				synchronized(rob) {
					for(int i=0 ; i<15 ; i++) {
						if(rob.getValue()==0)
						{
							try{ rob.wait(); } catch(Exception e){}
						}
						try{Thread.sleep(300);}catch(Exception e){}
						rob.consume();
						rob.notify();
					}
				}
			}
		};

		p.start();
		c.start();
	}
}
//----------------------------------------------------------------------------------------------------
===================================================================================================================================

                ****************  The Deadlock in Video *****************

          Deadlock is a situation in multithreading where two or more threads are blocked forever, waiting for each other to release a resource. 
          This typically occurs when two or more threads have circular dependencies on a set of locks.


******Deadlocks typically occur when four conditions are met simultaneously:

1. Mutual Exclusion: Only one thread can access a resource at a time.

2. Hold and Wait: A thread holding at least one resource is waiting to acquire additional resources held by other threads.

3. No Preemption: Resources cannot be forcibly taken from threads holding them.

4. Circular Wait: A set of threads is waiting for each other in a circular chain.



A deadlock occurs when two or more threads are waiting on each other to release a resource, leading to a situation where no thread can proceed.

In this example:
Thread A has a pen and wants a paper.
Thread B has a paper and wants a pen.
Both threads wait for each other to release their resources, causing a deadlock.


===================================================================================================================================
//----------------------------------------------------------------------------------------------------

	// The Deadlock in synchronization -  Reader-Writer Problem.
	
	A special type of error that you need to avoid that relates specifically to multitasking is deadlock,
	which occurs when two threads have a circular dependency on a pair of synchronized objects.

	Lets see the the famous problems in multi-threading and is referred to as the Reader-Writer Problem.

	There are two threads Reader and Writer both share a common object “message”.

	- Reader reads the message when it is not empty otherwise, it will wait for the Writer to write the message.

	- On the other hand, Writer writes the message when it is empty else it waits for Reader to read the message 
	  and mark the message empty.

	Now let’s create two threads Writer and Reader and one shared object for both the thread that is Message object.

import java.util.Random;
class Message 
{
	String message;
    	boolean empty = true; 

    	//Method used by reader
    	public synchronized String read() 
	{
        	while(empty) 		// if message is empty then keep looping.
		{
			System.out.println("Waiting for data write..!! so able to read");			
			try {Thread.sleep(2000);} catch (InterruptedException e) {}
		}
        	empty = true; 		// Reader reads the message and marks empty as true.
        	return message; 	//Reader reads the message.
    	}

    	//Method used by writer
    	public synchronized void write(String message) 
	{
        	while(!empty) 			//if message is not empty then keep looping.
		{
			System.out.println("Waiting for data read..!! so able to write");
			try {Thread.sleep(2000);} catch (InterruptedException e) {}
		}
        	this.message = message;		//Writer writes the message.
        	empty = false;			//Now make empty as false.
   	 }
}
class Writer implements Runnable 
{
	private Message message;
    	public Writer(Message message) 
	{
        	this.message = message;
    	}
    	public void run() 
	{
        	String messages[] = {
                "Johnny, Johnny, Yes Papa",
                "Eating sugar? No, Papa!",
                "Telling lies? No, Papa!",
                "Open your mouth, Ha! Ha! Ha!"
        	};

        	Random random = new Random();
        	for (int i = 0; i < messages.length; i++) 
		{
            		message.write(messages[i]);
            		try {Thread.sleep(random.nextInt(2000));} catch (InterruptedException e) {}
        	}
        	message.write("Finished!");
    	}
}

class Reader implements Runnable 
{
    	private Message message;
    	public Reader(Message message)
	{
        	this.message = message;
    	}
    	public void run() 
	{
        	Random random = new Random();
        	for (String latestMessage = message.read(); !"Finished!".equals(latestMessage); latestMessage = message.read()) 
		{
            		System.out.println(latestMessage);            
            		try {Thread.sleep(random.nextInt(2000));} catch (InterruptedException e) {}
        	}
   	}
}
public class MainReaderWriter 
{
	public static void main(String[] args) 
	{
        	//Shared message object between Reader and Writer threads.
        	Message message = new Message();

        	Thread writerThread = new Thread(new Writer(message));
        	Thread readerThread = new Thread(new Reader(message));

        	writerThread.start();
        	readerThread.start();
    }
}


-------------- Output on Run --------------
Johnny, Johnny, Yes Papa
Eating sugar? No, Papa!
Waiting for data read..!! so able to write
Waiting for data read..!! so able to write
Waiting for data read..!! so able to write
Waiting for data read..!! so able to write
Waiting for data read..!! so able to write

or any other ... or may be expected ... each time different output

Basically, by looking at the output above, you might wonder why aren’t the rest of the messages printed.
Now, the Simple Answer Is “DEADLOCK”.

Let me take the first output and explain to you why this deadlock occurred.

	- When we started the threads through the main() method from the Main class, both the threads 
	  called the run() method.
	- Note that both threads are sharing a common message object. Now the Reader thread called the 
	  synchronized read() method and hence acquired the lock of the message object.
	- As initially the boolean empty flag was set to true, the Reader thread keeps executing while looping infinitely.
	- Also, the Writer thread won’t be able to execute the write() method as the lock of the message object is 
	  already acquired by the Reader thread.

	Hence we don’t see any output on the console in the first output. Similarly, you can also try to trace 
	the second output.

	If you have noticed, none of the threads can do their required tasks, and they are waiting infinitely. 
	This scenario is called DEADLOCK.

	The solution to overcome the deadlock is very simple. We just have to introduce an acquire and release mechanism
	for monitor/intrinsic lock in the read() and write()synchronized methods which are causing deadlock. This problem
	is solved by using wait() and notify() and notifyAll().

	Let's see the example

import java.util.Random;
class Message 
{
    String message;
    boolean empty = true;

    //Method used by reader
    public synchronized String read() {
        while (empty) {
            try {
                wait();
            } catch (InterruptedException e) {
                System.out.println(Thread.currentThread().getName() + "Interrupted.");
            }
        }
        empty = true;//Reader reads the message and marks empty as true.
        notifyAll();
        return message;//Reader reads the message.
    }

    //Method used by writer
    public synchronized void write(String message) {
        while (!empty) {
            try {
                wait();
            } catch (InterruptedException e) {
                System.out.println(Thread.currentThread().getName() + "Interrupted.");
            }
        }
        this.message = message;//Writer writes the message.
        empty = false;//Now make empty as false.
        notifyAll();
    }
}
class Writer implements Runnable 
{
    private Message message;

    public Writer(Message message) 
	{
        this.message = message;
    }

    public void run() 
	{
        String messages[] = {
                "Johnny, Johnny, Yes Papa",
                "Eating sugar? No, Papa!",
                "Telling lies? No, Papa!",
                "Open your mouth, Ha! Ha! Ha!"
        };

        Random random = new Random();

        for (int i = 0; i < messages.length; i++) 
		{
            message.write(messages[i]);
            try 
			{
                Thread.sleep(random.nextInt(2000));
            } 
			catch (InterruptedException e) 
			{
                System.out.println("Writer Thread Interrupted!!!");
            }
        }
        message.write("Finished!");
    }
}

class Reader implements Runnable 
{
    private Message message;

    public Reader(Message message) {
        this.message = message;
    }
    public void run() {
        Random random = new Random();
        for (String latestMessage = message.read(); !"Finished!".equals(latestMessage); latestMessage = message.read()) 
	{
            System.out.println(latestMessage);
            try {Thread.sleep(random.nextInt(2000));} catch (InterruptedException e) 
	    {
                System.out.println("Reader Thread Interrupted!!!");
            }
        }
    }
}
public class MainReaderWriter 
{
    public static void main(String[] args) 
	{
        //Shared message object between Reader and Writer threads.
        Message message = new Message();

        Thread writerThread = new Thread(new Writer(message));
        Thread readerThread = new Thread(new Reader(message));

        writerThread.start();
        readerThread.start();
    }
}

---------- Output On Run ------------

Johnny, Johnny, Yes Papa
Eating sugar? No, Papa!
Telling lies? No, Papa!
Open your mouth, Ha! Ha! Ha!
Press any key to continue . . .


//--------------------------------------------------------------------------------------------------------------------

Even though this approach solves our problem, there are a few drawbacks of this approach:

	- All the threads that are in a blocked state can’t be interrupted.
	- If multiple threads are waiting for a lock and when the lock is available, the order in which the threads will 
	  get the lock is not guaranteed. Let’s say that the first thread which went into the wait state might be the 
	  last to get the lock to execute its synchronized block.
	- synchronized doesn't support thread scheduling. This can be solved using ReentrantLock. ReentrantLock has 
	  support for a configurable fairness policy, allowing more flexible thread scheduling.
	- We cannot hold the lock across the methods. This means we cannot hold the single monitor lock in one synchronized 
	  method and release it in another synchronized method. This can be done using ReentrantLock.

	i.e.

		private ReentrantLock lock;

		public void method1() {
 		...
  		lock.lock();
  		...
		}
		public void method2() {
  		...
  		lock.unlock();
  		...
		}

//----------------------------------------------------------------------------------------------------------------

	Java Locks:
	------------

	Most of the times, synchronized keyword is the way to go but it has some shortcomings that lead the way to 
	inclusion of Lock API in Java Concurrency package. Java 5 Concurrency API came up with java.util.concurrent.locks
	package with Lock interface and some implementation classes to improve the Object locking mechanism. 
	Some important interfaces and classes in Java Lock API are:

		java.util.concurrent.locks.Lock  (Interface)
			│
			├── ReentrantLock             	(Class - Implements Lock)
			│
			├── ReadWriteLock             	(Interface - Extends Lock functionality)
			|   |
			│   ├── ReentrantReadWriteLock 	(Class - Implements ReadWriteLock)
			│
			└── StampedLock               	(Class - Implements lock mechanism with stamps)
	

	Lock: This is the base interface for Lock API. It provides all the features of synchronized keyword with 
	additional ways to create different Conditions for locking, providing timeout for thread to wait for lock. 
	Some of the important methods are, lock() to acquire the lock, unlock() to release the lock, tryLock() to wait 
	for lock for a certain period of time, newCondition() to create the Condition etc.

	Condition: Condition objects are similar to Object wait-notify model with additional feature to create different 
	sets of wait. A Condition object is always created by Lock object. Some of the important methods are await() 
	that is similar to wait() and signal(), signalAll() that is similar to notify() and notifyAll() methods.

	ReadWriteLock: It contains a pair of associated locks, one for read-only operations and another one for writing. 
	The read lock may be held simultaneously by multiple reader threads as long as there are no writer threads. 
	The write lock is exclusive.

	ReentrantLock: This is the most widely used implementation class of Lock interface. This class implements the 
	Lock interface in similar way as synchronized keyword. Apart from Lock interface implementation, ReentrantLock 
	contains some utility methods to get the thread holding the lock, threads waiting to acquire the lock etc. 
	synchronized block are reentrant in nature i.e if a thread has lock on the monitor object and if another 
	synchronized block requires to have the lock on the same monitor object then thread can enter that code block. 
	I think this is the reason for the class name to be ReentrantLock. 

	The StampedLock class is a part of the java.util.concurrent.locks package, introduced in Java 8. It is a 
	modern locking mechanism designed to improve performance in scenarios with frequent reads and occasional 
	writes.



	Here are some of the commonly used methods of the ReentrantLock class:

 	- lock(): Acquires the lock. If the lock is not available, the current thread will wait until the lock becomes 
		  available.
 
	- unlock(): Releases the lock. It's important to ensure that unlock() is always called in a finally block 
		    to ensure the lock is released even if an exception occurs.

 	- tryLock(): Attempts to acquire the lock without waiting. Returns true if the lock was acquired successfully, 
		     false otherwise.

 	- tryLock(long time, TimeUnit unit): Attempts to acquire the lock within the specified time period. 
					     Returns true if the lock was acquired successfully within the specified 
					     time, false otherwise.

 	- isHeldByCurrentThread(): Returns true if the lock is held by the current thread, false otherwise.

 	- getHoldCount(): Returns the number of times the current thread has acquired the lock. If the lock is not 
			  held by the current thread, it returns 0.

 	- getQueueLength(): Returns an estimate of the number of threads waiting to acquire the lock.

 	- hasQueuedThreads(): Returns true if there are any threads waiting to acquire the lock.

 	- isLocked(): Returns true if the lock is held by any thread, false otherwise.



//=============================================================================================
//=============================================================================================

 
   -lock.lock(): Similar to synchronized. lock.lock() Wait until it acquires the locks

   Fairness of locks:
               In Java, the fairness of locks determines the order in which threads acquire a lock when multiple threads are waiting.

    1. Unfair Locks (Default in synchronized):
        - The synchronized keyword in Java does not provide fairness.
        - Threads compete for the lock, and there is no guarantee of which thread will acquire it next.
        - This can lead to thread starvation, where some threads may wait indefinitely if other threads frequently acquire the lock.

    2. Fair Locks (ReentrantLock):
           - Unlike synchronized, ReentrantLock provides an option for fairness when instantiated with new ReentrantLock(true).
           - A fair lock follows a first-come, first-served (FIFO) approach, ensuring that the longest-waiting thread gets the lock next.
           - However, fair locks may reduce performance due to increased overhead in managing the queue of waiting threads.

- Use fair locks when ensuring equal opportunity for all threads is more important than raw performance.

- we get the output in the order of requesting of thread


    What is Starvation?
             Starvation occurs in multithreading when a thread is perpetually denied access to resources because other higher-priority
             threads are continuously getting access. This means the starving thread is never scheduled or gets very little CPU time, 
             causing it to never make progress.

     The thread don't get chance to run it called Starvation



   ********** Disadvantages of synchronized over ReentrantLock

     1. Fairness = does not guarantee for fairness.
     2. Blocking = threads are block for indefinite time
     3. Interpretability = does not provides interpretability if it takes more time.
     4. Read/ Write Locking = synchronized does not no which is read or write so it blocks all. synchronized done the unnecessary locking of blocks.
                               If we done locking manually then this disadvantage can be overcome.




     ****** Read/Write Locks in Java (ReentrantReadWriteLock):
                Java provides Read/Write Locks to handle concurrency where multiple threads can read a resource simultaneously, 
             but only one thread can write to it at a time. This improves performance in cases where reads are more frequent than writes.


    ****** Why Use Read/Write Locks?
                  1. Improves Performance: Multiple threads can read simultaneously, reducing contention.
                  2. Prevents Data Corruption: Only one thread can write at a time, ensuring consistency.
                  3. Avoids Blocking: Readers do not block other readers, only writers block.

import java.util.concurrent.locks.ReentrantReadWriteLock;

class SharedResource {
    private String data = "Initial Data";
    private final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();

    // Read Operation
    public void readData() {
        lock.readLock().lock(); // Acquire Read Lock
        try {
            System.out.println(Thread.currentThread().getName() + " is reading: " + data);
            Thread.sleep(1000); // Simulate read time
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.readLock().unlock(); // Release Read Lock
        }
    }

    // Write Operation
    public void writeData(String newData) {
        lock.writeLock().lock(); // Acquire Write Lock
        try {
            System.out.println(Thread.currentThread().getName() + " is writing...");
            Thread.sleep(1000); // Simulate write time
            data = newData;
            System.out.println(Thread.currentThread().getName() + " updated data to: " + data);
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.writeLock().unlock(); // Release Write Lock
        }
    }
}

public class ReadWriteLockExample {
    public static void main(String[] args) {
        SharedResource resource = new SharedResource();

        // Create Reader Threads
        Runnable readTask = resource::readData;
        Thread reader1 = new Thread(readTask, "Reader 1");
        Thread reader2 = new Thread(readTask, "Reader 2");

        // Create Writer Thread
        Runnable writeTask = () -> resource.writeData("Updated Data");
        Thread writer = new Thread(writeTask, "Writer");

        // Start Threads
        reader1.start();
        reader2.start();
        writer.start();
    }
}

o/p:
Reader 1 is reading: Initial Data
Reader 2 is reading: Initial Data
Writer is writing...
Writer updated data to: Updated Data



//=============================================================================================
//=============================================================================================



Let’s understand this feature with a simple example. ( Try to execute with and without comments) 


import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
class Runner
{
	int counter=0;
	ReentrantLock lockob = new ReentrantLock();
	void increament() 
	{
		//lockob.lock();
		try
		{
			for(int i=0;i<10;i++)
			{
				counter++;
				System.out.println(Thread.currentThread().getName()+" - "+counter+" - InWaiting:: "+lockob.getQueueLength());
				try{Thread.sleep(700);}catch(Exception e){}
			}
		}
		catch(Exception e){}
		finally
		{
			//lockob.unlock();
		}
	}
}
class DemoRenterentockex
{
	public static void main(String[] args) 
	{
		Runner ob=new Runner();

		Thread t1=new Thread(){
			public void run()
			{
				ob.increament();
			}
		};
		t1.start();

		try{Thread.sleep(2000);}catch(Exception e){}

		Thread t2=new Thread(){
			public void run()
			{
				ob.increament();
			}
		};
		t2.start();

		try{Thread.sleep(2000);}catch(Exception e){}

		Thread t3=new Thread(){
			public void run()
			{
				ob.increament();
			}
		};
		t3.start();
	}
}

//--------------------------------------------------------------------------------------------

	// Using lock() in caller, rather than resource:

	It is allowed to use a lock() within caller, rather than resource, only 
	condition is that,

		- Every call must be within the lock()-unlock().

		- Same lock object must be used for locking and unlocking, if different
		  lock object is used then we will get the parallel execution of threads.

	// Using same lock object in caller

import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
class Runner
{
	int counter=0;
	void increament()
	{
		for(int i=0;i<10;i++)
		{
			counter++;
			System.out.println(Thread.currentThread().getName()+" - "+counter);
			try{Thread.sleep(700);}catch(Exception e){}
		}
	}
}
class DemoRenterentock
{
	public static void main(String[] args) 
	{
		Runner ob=new Runner();
		Lock lock=new ReentrantLock();

		Thread t1=new Thread(){
			public void run()
			{
				lock.lock();
				try
				{
					ob.increament();
				}
				catch (Exception e){}
				finally
				{
					lock.unlock();
				}
			}
		};
		t1.start();

		Thread t2=new Thread(){
			public void run()
			{
				lock.lock();
				try
				{
					ob.increament();
				}
				catch (Exception e){}
				finally
				{
					lock.unlock();
				}
			}
		};
		t2.start();
	}
}
-------- Output on Run -----------
Thread-0 - 1
Thread-0 - 2
Thread-0 - 3
Thread-0 - 4
Thread-0 - 5
Thread-0 - 6
Thread-0 - 7
Thread-0 - 8
Thread-0 - 9
Thread-0 - 10
Thread-1 - 11
Thread-1 - 12
Thread-1 - 13
Thread-1 - 14
Thread-1 - 15
Thread-1 - 16
Thread-1 - 17
Thread-1 - 18
Thread-1 - 19
Thread-1 - 20
Press any key to continue . . .

//--------------------------------------------------------------------------------------------


	// Using different lock object in the caller

import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
class Runner
{
	int counter=0;
	void increament()
	{
		for(int i=0;i<10;i++)
		{
			counter++;
			System.out.println(Thread.currentThread().getName()+" - "+counter);
			try{Thread.sleep(700);}catch(Exception e){}
		}
	}
}
class DemoRenterentock
{
	public static void main(String[] args) 
	{
		Runner ob=new Runner();
		Lock lock=new ReentrantLock();
		Lock lock1=new ReentrantLock();

		Thread t1=new Thread(){
			public void run()
			{
				lock.lock();
				try
				{
					ob.increament();
				}
				catch (Exception e)	{}
				finally
				{
					lock.unlock();
				}
			}
		};
		t1.start();

		Thread t2=new Thread(){
			public void run()
			{
				lock1.lock();
				try
				{
					ob.increament();
				}
				catch (Exception e)	{}
				finally
				{
					lock1.unlock();
				}
			}
		};
		t2.start();
	}
}
--------------- Output on Run ---------------------

Thread-1 - 2
Thread-0 - 2
Thread-1 - 3
Thread-0 - 4
Thread-1 - 5
Thread-0 - 5
Thread-0 - 6
Thread-1 - 7
Thread-0 - 8
Thread-1 - 9
Thread-0 - 10
Thread-1 - 10
Thread-0 - 12
Thread-1 - 11
Thread-0 - 13
Thread-1 - 13
Thread-0 - 14
Thread-1 - 15
Thread-1 - 16
Thread-0 - 17
Press any key to continue . . .

//------------------------------------------------------------------------------------------------------------------


	- Accessing a different method from shared resource using different threads

	When a resource contains the two methods and both will be accessed by
	different threads, then without using the lock it will executes in the parallel 
	manner but using same lock, it will attend synchronization.


import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
class Runner
{
	int counter=0;
	Lock lock=new ReentrantLock();
	void increament()
	{
		lock.lock();
		try
		{
			for(int i=0;i<10;i++)
			{
				counter++;
				System.out.println("INC - "+Thread.currentThread().getName()+" - "+counter);
				try{Thread.sleep(700);}catch(Exception e){}
			}
		}
		catch(Exception e){}
		finally
		{
			lock.unlock();
		}
	}
	void decreament()
	{
		lock.lock();
		try
		{
			for(int i=0;i<10;i++)
			{
				counter--;
				System.out.println("DEC - "+Thread.currentThread().getName()+" - "+counter);
				try{Thread.sleep(700);}catch(Exception e){}
			}
		}
		catch(Exception e){}
		finally
		{
			lock.unlock();
		}
	}
}
class DemoRenterentock1
{
	public static void main(String[] args) 
	{
		Runner ob=new Runner();

		Thread t1=new Thread(){
			public void run()
			{
				ob.increament();
			}
		};
		t1.start();

		Thread t2=new Thread(){
			public void run()
			{
				ob.decreament();
			}
		};
		t2.start();
	}
}
//---------------------------------------------------------------------------------------------------------

	/// producer-consumer using lock again

import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

class Resource {
    private int value;
    private final Lock lock = new ReentrantLock();
    private final Condition notFull = lock.newCondition();
    private final Condition notEmpty = lock.newCondition();

    public Resource() {
        value = 0;
    }

    public int getValue() {
        lock.lock();
        try {
            return value;
        } finally {
            lock.unlock();
        }
    }

    public void incr() {
        lock.lock();
        try {
            while (value == 1) {
                try {
                    notFull.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            value++;
            System.out.println("After Produce Value is: " + value);
            notEmpty.signal();
        } finally {
            lock.unlock();
        }
    }

    public void decr() {
        lock.lock();
        try {
            while (value == 0) {
                try {
                    notEmpty.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            value--;
            System.out.println("After consume Value is: " + value);
            notFull.signal();
        } finally {
            lock.unlock();
        }
    }
}

class Producer extends Thread {
    Resource res;

    public Producer(Resource res) {
        this.res = res;
        start();
    }

    public void run() {
        while (true) {
            res.incr();
            try {
                Thread.sleep(200);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

class Consumer extends Thread {
    Resource res;

    public Consumer(Resource res) {
        this.res = res;
        start();
    }

    public void run() {
        while (true) {
            res.decr();
            try {
                Thread.sleep(800);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

public class MainPCUsingLock2 {
    public static void main(String[] args) {
        Resource ob = new Resource();

        Producer p = new Producer(ob);
        Consumer c = new Consumer(ob);
    }
}

//------------------------------------------------------------------------------------------------------------------------

// Lets see the another program (Reader - Writer using Locks)

import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.Random;

class Message {
    private String message;
    private boolean empty = true;
    private Lock lock = new ReentrantLock();
    private Condition notEmpty = lock.newCondition();
    private Condition notFull = lock.newCondition();

    // Method used by reader
    public String read() throws InterruptedException {
        lock.lock();
        try {
            while (empty) {
                notEmpty.await(); // Wait until a message is available
            }
            empty = true; // Reader reads the message and marks empty as true
            notFull.signalAll(); // Signal that space is available for writing
            return message; //Reader reads the message
        } finally {
            lock.unlock();
        }
    }

    // Method used by writer
    public void write(String message) throws InterruptedException {
        lock.lock();
        try {
            while (!empty) {
                notFull.await(); // Wait until the message has been read
            }
            this.message = message; // Writer writes the message
            empty = false; // Now make empty as false
            notEmpty.signalAll(); // Signal that a new message is available for reading
        } finally {
            lock.unlock();
        }
    }
}

class Writer implements Runnable {
    private Message message;

    public Writer(Message message) {
        this.message = message;
    }

    public void run() {
        String messages[] = {
            "Johnny, Johnny, Yes Papa",
            "Eating sugar? No, Papa!",
            "Telling lies? No, Papa!",
            "Open your mouth, Ha! Ha! Ha!"
        };

        Random random = new Random();

        for (int i = 0; i < messages.length; i++) {
            try {
                message.write(messages[i]);
                Thread.sleep(random.nextInt(2000)); // Simulate some time taken to write a message
            } catch (InterruptedException e) {
                System.out.println("Writer Thread Interrupted!!!");
            }
        }

        try {
            message.write("Finished!");
        } catch (InterruptedException e) {
            System.out.println("Writer Thread Interrupted!!!");
        }
    }
}

class Reader implements Runnable {
    private Message message;

    public Reader(Message message) {
        this.message = message;
    }

    public void run() {
        Random random = new Random();
        try {
            for (String latestMessage = message.read(); !"Finished!".equals(latestMessage); latestMessage = message.read()) {
                System.out.println(latestMessage); // Print the message
                Thread.sleep(random.nextInt(2000)); // Simulate some time taken to read a message
            }
        } catch (InterruptedException e) {
            System.out.println("Reader Thread Interrupted!!!");
        }
    }
}

public class MainReaderWriter1 {
    public static void main(String[] args) {

        // Shared message object between Reader and Writer threads
        Message message = new Message();

        // Create and start writer and reader threads
        Thread writerThread1 = new Thread(new Writer(message));
        Thread readerThread1 = new Thread(new Reader(message));

        Thread writerThread2 = new Thread(new Writer(message));
        Thread readerThread2 = new Thread(new Reader(message));

        writerThread1.start();
        readerThread1.start();

        writerThread2.start();
        readerThread2.start();
    }
}

Java Lock vs synchronized

	Based on above details and program, we can easily conclude following differences between Java Lock 
	and synchronization.

	- Java Lock API provides more visibility and options for locking, unlike synchronized where a thread 
	  might end up waiting indefinitely for the lock, we can use tryLock() to make sure thread waits for 
	  specific time only.

	- Synchronization code is much cleaner and easy to maintain whereas with Lock we are forced to have 
	  try-finally block to make sure Lock is released even if some exception is thrown between lock() and unlock() 
	  method calls.

	- synchronization blocks or methods can cover only one method whereas we can acquire the lock in one method 
	  and release it in another method with Lock API.

	- synchronized keyword doesn’t provide fairness whereas we can set fairness to true while creating 
	  ReentrantLock object so that longest waiting thread gets the lock first.

	- We can create different conditions for Lock and different thread can await() for different conditions.

//=================================================================================================================================
//=================================================================================================================================

              ***************** Executors Framework in Video ********************

              The Executors Framework was introduced in Java 5 as a part of Java.util.concurret package to simplify the development 
              of concurrent application by abstracting away many of the complexities involved in creating and managing threads


          1. Manual Thread Management
          2. Resource management
          3. Scalability
          4. Thread Reuse
          5. Error Handling


          Executors Framework:
              1. Executors 
              2. ExecutorService
              3. ScheduledExecutorsService


    syntax:  ExecutorService executor = Executors.newFixedThreadPool(3);

    <?> = any type vaild card , <String>= string type

   
           Runnable VS Callable Difference
     

         Runnable = 1. Runnable does not return anything
                    2. run() method.
                    3. Signature diff- try-catch block to handle Exception



         Callable = 1. If we want to return something then use callable.
                    2. call() method.
                    3. Signature diff- throws block to handle Exception

        
                  public object call() throws Exception{
                        
                       Thread.sleep(10);
                        return 1;
          
               }

///////////////////////////


        Method in Executors:

import java.*;
import java.util.concurrent.Executor;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;

public class Main1 {
 
public static void main(String []args) throws ExecutionException,InterrruptedException{

    ExecutorService executorService = Executor.newFixedThreadPool(2);  //ExecutorService creates 2 new thread
    Future<Integer> submit = executorService.submit(()->1+2);
    Integer sum = submit.get();
    System.out.println("Sum is:"+sum);
    executorService.shutdown();
    Thread.sleep(10);
    System.out.println(executorService.isShutdown()); // return true 
    System.out.println(executorService.isTerminated()); // return true if all task are completed after shutdown
      System.out.println(executorService.invokeAll()); //InvokeAll take collection of task to execute at time
      System.out.println(executorService.invokeAny()); return only one ans if two threads are running.
        
  }
    
}
  

Future Methods:
f.get(); // wait to complete the task.
f.isDone(); //if task is complete return true
f.isCancelled();
f.get(time);
f.cancel(true) = task is cancel in any condition i.e. task is completed or not completed it will be cancel.
f.cancel(false) = task does not interrupt 

//-------------------------------------------------



         *******************  ScheduledExecutorsService ***********


ScheduledExecutorsService: schedule the task after specific time interval.

Methods:  1. scheduleAtFixedRate();  = overlap happen because task start after fixedtime
          2. scheduleWithFixedDelay();  = overlap don't happen. for how much time waiting to start the next task after the first task finish
          3. scheduler.schedule();



             1. newFixedThreadPool(int nThreads)
                     - A FixedThreadPool creates a fixed number of threads.
                     - If all threads are busy, new tasks wait in a queue until a thread becomes available.
                     - Suitable for CPU-bound tasks where a constant number of threads is preferred.

            Key Points
                ✅ Thread Reuse: Reuses a fixed number of threads for efficiency.
                ✅ Prevents Overloading: Limits thread creation to avoid excessive resource usage.


           Example: Processing a fixed set of tasks like image processing, database updates.



            2. newCachedThreadPool()
                   - A CachedThreadPool creates unlimited threads (as needed) but reuses idle threads.
                   - If a thread remains idle for 60 seconds, it is terminated to free resources.
                   - Suitable for short-lived tasks where thread creation overhead is high.

            Key Points
                  ✅ Dynamic Thread Management: Creates new threads as needed, up to system limits.Dynamically manage threadpool
                  ✅ Best for I/O-Intensive Tasks: Suitable for tasks where waiting time is high (e.g., database calls, network requests).


           Example: Handling many short-lived network requests, real-time logging, chat systems. short-lived task and variable load 
                     scenario use cacheThreadPool




    ************* CountDownLatch in Java (Multi-threading Synchronization)

                   CountDownLatch is a synchronization aid in Java that allows one or more threads to wait for a set of operations 
                  to complete before proceeding. It is useful when you want to ensure that multiple threads complete their tasks 
                  before a main thread continues execution.
                    
                  - One-time Use: CountDownLatch cannot be reused once the count reaches zero.


                 A CountDownLatch is initialized with a count (number of tasks to wait for).  e.g. int numberOfServices = 3;

                    -  Threads call countDown() to decrease the count when they finish their tasks.
                    -  The main thread calls await(), which blocks execution until the count reaches zero.
                                              await() blocks until all required operations complete.



     *********************CyclicBarrier in Java (Multi-threading Synchronization)

                CyclicBarrier is a synchronization mechanism in Java that allows multiple threads to wait for each other at a common
                 execution point before proceeding further.

                Unlike CountDownLatch, a CyclicBarrier can be reused once the waiting threads reach the barrier.


          ** How CyclicBarrier Works?
                -  It is initialized with a count (number of threads) that must reach the barrier before any can proceed.
                -  Each thread calls await(), and once all threads reach the barrier, they are released simultaneously.



       Feature	                  CyclicBarrier	                                         CountDownLatch

    1 Thread Synchronization	  Waits for all threads before proceeding together	   Waits for tasks but does not require all to proceed together
    2 Reusability	          Yes (Resets after all threads reach the barrier)	   No (Cannot be reused once count reaches 0)
    3 Use Case	                  Coordinating threads for phases of execution	           One-time waiting for multiple tasks





       CompletableFuture in Java (Asynchronous Programming): java 8

          CompletableFuture is part of Java’s java.util.concurrent package and is used for asynchronous programming.
          It provides powerful features like non-blocking execution, chaining, exception handling, and combining multiple futures.


   1. Why Use CompletableFuture?
✅ Asynchronous Execution: Run tasks in the background without blocking the main thread.
✅ Chaining Operations: Execute tasks sequentially (thenApply, thenAccept).
✅ Combining Multiple Tasks: Wait for multiple futures (thenCombine, allOf).
✅ Exception Handling: Handle failures gracefully (exceptionally, handle)



                                    ****** end of video lecture Notes ********

//=================================================================================================================================
//=================================================================================================================================

	
// Executors in java: Java 5
// ------------------

	// In the threading also you are defining the procedures, which are executed
	// and will gives you the desired output, as given by the programs that we
	// have seen before the multithreading. Only difference is that all the code
	// groups will execute in the parallel manner.

	There are different ways of defining the task(procedures)

		- define it with the run method of class extending the Thread or implementing
		  the runnable interface. Both are made to execute in a parallel manner.

		- define a task as a part of normal class and call it from the run method.

 // Suppose we have to find the total of number from 1 to 10, we can write it 
 // as a method in a simple class, and call using its object. but if you want to call
 // it multiple time and want to execute in the parallel manner the thread is a 
 // correct option coz in case of normal method there may be a multipe calls but
 // it will be executed in a sequence.

 Lets try with a single thread which will gives you a clear idea of how to define
 a task, within a thread.

class ExecuteTask extends Thread
{
	public void run()
	{
		int tot=0;
		for(int i=0;i<=10;i++)
		{
			tot=tot+i;
			System.out.println("i=: "+i);
			try{Thread.sleep(700);}catch(Exception e){}
		}
		System.out.println("\n Total is: "+tot);
	}
}
class StartingTheTaskEx
{
	public static void main(String[] args) 
	{
		ExecuteTask me1=new ExecuteTask ();
		me1.start();
	}
}

//--------------------------

Can be written in a different way where Task and Thread are defined in seperate classes. (seperations of cocerns)

class Task
{
	int tot=0;
	public void calcSum() {
		for(int i=0;i<=10;i++)
		{
			tot=tot+i;
			System.out.println("i=: "+i);
			try{Thread.sleep(700);}catch(Exception e){}
		}
		System.out.println("\n Total is: "+tot);
	}
}
class TaskExecuter extends Thread
{
	Task tob;
	public TaskExecuter(Task tob) {
		this.tob = tob;
	}
	public void run()
	{
		tob.calcSum();
	}
}
class StartingTheTaskEx1
{
	public static void main(String[] args) 
	{
		Task tob = new Task();
		TaskExecuter me1=new TaskExecuter (tob);
		me1.start();
	}
}

//----------------------------------------------------------------

	// Now Lets modify the the above program and execute the task of adding number
	// from different which is executed by same thread and therefore it is called
	// Executer therad, (In out case SumExecuter)


class MyTask
{
	int start,end;
	public MyTask(int start, int end)
	{
		this.start=start;
		this.end=end;
	}
	void findTotal()
	{
		int tot=0;
		for(int i=start;i<=end;i++)
		{
			tot=tot+i;
			try{Thread.sleep(1000);}catch(Exception e){}
			System.out.println("Processing..."+Thread.currentThread().getName());
		}
		System.out.println("\n Total is: "+tot);;
	}
}
class SumExecutor extends Thread
{
	MyTask task;
	public SumExecutor(MyTask task)
	{
		this.task=task;
		start();
	}
	public void run()
	{
		task.findTotal();
	}
}
class StartingTheTaskEample
{
	public static void main(String[] args) 
	{
		MyTask task1=new MyTask(2,7);
		SumExecutor me1=new SumExecutor(task1);

		MyTask task2=new MyTask(1,5);
		SumExecutor me2=new SumExecutor(task2);

		MyTask task3=new MyTask(5,10);
		SumExecutor me3=new SumExecutor(task3);;
	}
}

//---------------------------------------------------------------------------------

	// Note carefully that if we want to execute all theads in a synchronized
	// manner then we have to go for either synchronized keyword or lock.

	// but we are facing the difficulty while using it for the thread management
	// (i.e. resource allocation, thread pooling, thread Control etc...)

	so we need one standard aritecture to handle it and that is provided in java 5,
	called executor.

	In the java mutithreading, we can divide the entire work in two different steps, 
	- first is defining a task and 
	- second the thread management which includes thread creation, pooling, and lifecycle management etc.

	The task being done by a new thread, as defined by its Runnable object, and the thread itself, 
	as defined by a Thread object. This works well for small applications, but in large-scale applications,
 	it makes sense to separate thread management and creation from the rest of the application. Objects 
	that encapsulate these facilities are known as executors.

	This high-level concurrency attended by using concurrency API in the java.util.concurrent package 
	that provides utility classes commonly useful in concurrent programming such as executors, threads 
	pool management, scheduled tasks execution, the Fork/Join framework(new in JDK 7), concurrent 
	collections, etc.

	In Java, an Executor is an interface in the java.util.concurrent package that provides a way to 
	decouple task submission from the mechanics of how each task will be run, including details like 
	thread use, scheduling, etc. It's essentially a framework for executing tasks asynchronously.

	Here's a detailed breakdown of how Executor works:

	- Decoupling Task Submission: Instead of directly creating threads to execute tasks, you submit 
	  tasks to an executor. This decouples the task submission from the execution mechanism. This 
	  decoupling is beneficial because it allows the executor framework to manage the execution details, 
	  such as thread creation, pooling, and lifecycle management.

	- Executor Interface: The Executor interface declares a single method void execute(Runnable command). 
	  This method accepts a Runnable object, which represents a task that can be executed asynchronously.

	  [Synchronous Execution: A task is synchronous if the caller thread waits for the task to complete before 
	    proceeding. The calling thread is blocked until the task finishes. Example: Traditional method calls, 
	    single-threaded programs.

	    Asynchronous Execution: A task is asynchronous if it runs in the background, allowing the caller thread 
	    to continue execution without waiting. The calling thread does not wait for the task to finish. 
	    Example: Multi-threading, Executors.
	  ]

	- ExecutorService: The ExecutorService interface extends Executor and provides additional methods to 
	  manage the lifecycle of the executor, such as shutting it down, waiting for tasks to complete, etc. 
	  It also defines methods for submitting tasks that can return a Future object representing the 
	  result of the computation.

	- ThreadPoolExecutor: This is one of the most commonly used implementations of the ExecutorService 
	  interface. It manages a pool of worker threads and a queue of tasks waiting to be executed. When 
	  a task is submitted to a ThreadPoolExecutor, it is executed either by an existing thread in the 
	  pool or by creating a new one, depending on the current state of the pool.

	- Executor Execution Policies: Executors can have different policies for executing tasks, such as 
	  fixed-size thread pools, cached thread pools, single-threaded executors, etc. These policies 
	  determines how tasks are executed based on factors like thread availability, task priority, 
	  and queueing strategy.

	- Task Execution: When a task is submitted to an executor, it is typically added to a queue. The 
	  executor then picks up tasks from the queue and executes them using one or more threads from its 
	  thread pool. The exact mechanism of task execution depends on the type of executor and its 
	  configuration.

	- Exception Handling: Executors provide mechanisms for handling exceptions that occur during task 
	  execution. 
	  For example, Future objects returned by some executor methods can be used to retrieve the result 
	  of a task and handle any exceptions that occurred during its execution.


	Understanding Thread Pool in Java
	-----------------------------------

	In terms of performance, creating a new thread is an expensive operation because it requires the 
	operating system allocates resources needed for the thread. Therefore, in practice thread pool is 
	used for large-scale applications that launch a lot of short-lived threads in order to utilize 
	resources efficiently and increase performance.

	Instead of creating new threads when new tasks arrive, a thread pool keeps a number of idle threads 
	that are ready for executing tasks as needed. After a thread completes execution of a task, it does 
	not die. Instead it remains idle in the pool waiting to be chosen for executing new tasks.

	You can limit a definite number of concurrent threads in the pool, which is useful to prevent overload.
	If all threads are busily executing tasks, new tasks are placed in a queue, waiting for a thread 
	becomes available.

           Why Thread Pool ?
             1.Resorce Management: creating and Destroying a thread is an expensive operation.it has some overhead, 
             2.Response Time.
             3.Control over Tread count: it apply limit on how many threads are created
  

	The Java Concurrency API supports the following types of thread pools:

		- Cached thread pool: keeps a number of alive threads and creates new ones as needed.

		- Fixed thread pool: limits the maximum number of concurrent threads. Additional tasks are 
				     waiting in a queue.

		- Single-threaded pool: keeps only one thread executing one task at a time.

		- Fork/Join pool: a special thread pool that uses the Fork/Join framework to take advantages of 
			     	  multiple processors to perform heavy work faster by breaking the work into smaller 
				  pieces recursively.

	That’s basically how thread pool works. In practice, thread pool is used widely in web servers where a thread pool is 
	used to serve client’s requests. Thread pool is also used in database applications where a pool of threads maintaining 
	open connections with the database.

	Implementing a thread pool is a complex task, but you don’t have to do it yourself. As the Java Concurrency API allows 
	you to easily create and use thread pools without worrying about the details


	Understanding Executors in Java
	An Executor is an object that is responsible for threads management and execution of Runnable tasks submitted 
	from the client code. It decouples the details of thread creation, scheduling, etc from the task submission 
	so you can focus on developing the task’s business logic without caring about the thread management details.


	The Java Concurrency API defines the following 3 base interfaces for executors:

		- Executor: is the super type of all executors. It defines only one method execute(Runnable).

		- ExecutorService: is an Executor that allows tracking progress of value-returning tasks (Callable) via 
		  Future object, and manages the termination of threads. Its key methods include submit() and shutdown().

		- ScheduledExecutorService: is an ExecutorService that can schedule tasks to execute after a given delay, 
		  or to execute periodically. Its key methods are schedule(), scheduleAtFixedRate() and scheduleWithFixedDelay().
		  
	You can create an executor by using one of several factory methods provided by the 
	Executors utility class.

	Executor (Interface)
	│
	├── ExecutorService (Interface)
	│   ├── AbstractExecutorService (Class)
	│   │   ├── ThreadPoolExecutor (Class)
	│   │   ├── ScheduledThreadPoolExecutor (Class)
	│   │   └── ForkJoinPool (Class)
	│   │
	│   ├── ScheduledExecutorService (Interface)
	│   │   └── ScheduledThreadPoolExecutor (Class)
	│   │
	│   ├── ForkJoinPool (Class)
	│   ├── ThreadPoolExecutor (Class)
	│   ├── ScheduledThreadPoolExecutor (Class)
	│   ├── DelegatedExecutorService (Class)
	│   ├── FinalizableDelegatedExecutorService (Class)
	│   ├── Executors (Utility Class)
	│
	└── ExecutorCompletionService (Class)


	Knowing the Executors class:

	In Java, the Executors class is a part of the java.util.concurrent package and serves as a factory 
	and utility class for creating and managing instances of ExecutorService, which provides a way to 
	manage asynchronous tasks.

	This class supports the following kinds of methods:
	- Methods that create and return an ExecutorService set up with commonly useful configuration settings.
	- Methods that create and return a ScheduledExecutorService set up with commonly useful 
	  configuration settings.
	- Methods that create and return a "wrapped" ExecutorService, that disables reconfiguration by making 
	  implementation-specific methods inaccessible.
	- Methods that create and return a ThreadFactory that sets newly created threads to a known state.
	- Methods that create and return a Callable out of other closure-like forms, so they can be used in 
	  execution methods requiring Callable.

	 Here are some commonly used methods provided by the java.util.concurrent.Executors class:

	- newFixedThreadPool(int nThreads):Creates a thread pool that reuses a fixed number of threads.

	- newCachedThreadPool():Creates a thread pool that creates new threads as needed but reuses existing 
		ones when they are available.

	- newSingleThreadExecutor(): Creates a single-threaded executor that uses a single worker thread 
		operating off an unbounded queue.

	- newScheduledThreadPool(int corePoolSize): Creates a thread pool that can schedule commands to 
		run after a given delay or to execute periodically.

	- newSingleThreadScheduledExecutor():Creates a single-threaded executor that can schedule commands 
		to run after a given delay or to execute periodically.

	- newWorkStealingPool():Creates a thread pool that maintains enough threads to support the given 
		parallelism level and may use multiple queues to reduce contention.

	- newFixedThreadPool(int nThreads, ThreadFactory threadFactory):Creates a thread pool that reuses a 
		fixed number of threads, using a provided ThreadFactory to create new threads.

	- newSingleThreadExecutor(ThreadFactory threadFactory): Creates a single-threaded executor that uses 
		a single worker thread operating off an unbounded queue, using a provided ThreadFactory 
		to create new threads.

	- newScheduledThreadPool(int corePoolSize, ThreadFactory threadFactory):Creates a thread pool that can 
		schedule commands to run after a given delay or to execute periodically, using a provided 
		ThreadFactory to create new threads.

	- newSingleThreadScheduledExecutor(ThreadFactory threadFactory):Creates a single-threaded executor 
		that can schedule commands to run after a given delay or to execute periodically, using a 
		provided ThreadFactory to create new threads.

	Simple Executor and ExecutorService Examples:
	----------------------------------------------
 
/**
 * This program demonstrates how to create a single-threaded executor
 * to execute a Runnable task.
 */
 /*

// single task 

import java.util.concurrent.*;
public class SimpleExecutorExample {
 
    public static void main(String[] args) {
        ExecutorService pool = Executors.newSingleThreadExecutor();
 
        Runnable task = new Runnable() {
            public void run() {
		for(int i=0;i<10;i++) {
			System.out.println(Thread.currentThread().getName()+" - "+i);
			try{Thread.sleep(800);}catch(Exception e){}
		}
            }
        }; 
        pool.execute(task);
        pool.shutdown();
    }
}

//----------------------------------------------------------------------------------------------------------------------

/// Multiple tasks

import java.util.concurrent.*;
public class SimpleExecutorExample {
 
    public static void main(String[] args) {
          ExecutorService pool = Executors.newSingleThreadExecutor();	
        // ExecutorService pool = Executors.newCachedThreadPool();
		// check the output, uncommenting above and commenting exsisting 
 
        Runnable task = new Runnable() {
            public void run() {
				for(int i=0;i<10;i++)
				{
					System.out.println(Thread.currentThread().getName()+" - "+i);
					try{Thread.sleep(800);}catch(Exception e){}
				}
            }
        }; 
        pool.execute(task);
 
        Runnable task1 = new Runnable() {
            public void run() {
				for(int i=0;i<10;i++)
				{
					System.out.println(Thread.currentThread().getName()+" - "+i);
					try{Thread.sleep(800);}catch(Exception e){}
				}
            }
        }; 
        pool.execute(task1);
 
        pool.shutdown();
    }
}	

//----------------------------------------------------------------------------------------------------------------------

//----------------------------------------------------------------------------------------------------------------------

	Java Callable and Future
	--------------------------

	Java Callable and Future are used a lot in multithreaded programming. we learned a lot about java threads but 
	sometimes we wish that a thread could return some value that we can use. Java 5 introduced java.util.concurrent.
	Callable interface in concurrency package that is similar to Runnable interface but it can return any Object 
	and able to throw Exception.

	The ExecutorServiceinterface defines a method that allows us to execute such kind of value-returning tasks:
	Future is an interface introduced in Java 5 that represents the result of an asynchronous computation. It allows 
	you to start a task, continue with other work, and later retrieve the result when it's ready.

     	<T> Future<T> submit(Callable<T> task)

	Here, the type parameter T is the return type of the task. You submit a task that implements the Callable

import java.util.concurrent.*;
 
/**
 * This program demonstrates how to create a single-threaded executor
 * to execute a Callable task.
 */
public class SimpleExecutorServiceExample {
 
    public static void main(String[] args) {

        ExecutorService pool = Executors.newSingleThreadExecutor();	
	
        Callable<Integer> task = new Callable<Integer>() {
            public Integer call() {
				int i=0, tot=0;
                try {
                    //task
					for(i=0;i<=10;i++)
					{
						tot=tot+i;
						Thread.sleep(1000);
						System.out.println("result = " + tot);
					}
                } catch (InterruptedException ex) {
                    ex.printStackTrace();
                }
 
                return tot;
            }
        };
 
        Future<Integer> result = pool.submit(task);
 
        try {
 
            Integer returnValue = result.get();
 
            System.out.println("Final result = " + returnValue);
 
        } catch (InterruptedException | ExecutionException ex) {
            ex.printStackTrace();
        }
 
        pool.shutdown();
    }
}

//-------------------------------

	CompletableFuture is an enhancement to the Future concept, introduced in Java 8. It allows you to 
	create more complex asynchronous workflows, making it easier to chain multiple asynchronous tasks.


//------------------------------------------------------------------------------------------------------------------------

	// Java Cached Thread Pool Executor Example
	
	The following example shows you how to create a cached thread pool to execute some tasks concurrently. 
	Given the following class:

/**
 * This class represents a coutdown clock.
 */
import java.util.concurrent.*;
class CountDownClock extends Thread {
    private String clockName;
 
    public CountDownClock(String clockName) {
        this.clockName = clockName;
    }
 
    public void run() {
        String threadName = Thread.currentThread().getName();
 
        for (int i = 5; i >= 0; i--) {
 
            System.out.printf("%s -> %s: %d\n", threadName, clockName, i);
 
            try {
                Thread.sleep(1000);
            } catch (InterruptedException ex) {
                ex.printStackTrace();
            }
        }
    }
} 
/**
 * This program demonstrates how to execute multiple tasks
 * with different kinds of executors.
 */
public class MultipleTasksExecutorExample {
 
    public static void main(String[] args) {
 
        ExecutorService pool = Executors.newCachedThreadPool();
 
        pool.execute(new CountDownClock("A"));
        pool.execute(new CountDownClock("B"));
        pool.execute(new CountDownClock("C"));
        pool.execute(new CountDownClock("D"));
        pool.execute(new CountDownClock("E"));
 
        pool.shutdown();
 
    }
}

//-------------------------------------------------------------------------------------------------------------

Fixed Thread Pool Executor Example
----------------------------------

/**
 * This class represents a coutdown clock.
 */
import java.util.concurrent.*;
class CountDownClock extends Thread {
    private String clockName;
 
    public CountDownClock(String clockName) {
        this.clockName = clockName;
    }
 
    public void run() {
        String threadName = Thread.currentThread().getName();
 
        for (int i = 5; i >= 0; i--) {
 
            System.out.printf("%s -> %s: %d\n", threadName, clockName, i);
 
            try {
                Thread.sleep(1000);
            } catch (InterruptedException ex) {
                ex.printStackTrace();
            }
        }
    }
} 
/**
 * This program demonstrates how to execute multiple tasks
 * with different kinds of executors.
 */
public class FixedeTasksExecutorExample {
 
    public static void main(String[] args) {
 
        ExecutorService pool = Executors.newFixedThreadPool(2);
 
        pool.execute(new CountDownClock("A"));
        pool.execute(new CountDownClock("B"));
        pool.execute(new CountDownClock("C"));
        pool.execute(new CountDownClock("D"));
        pool.execute(new CountDownClock("E"));
 
        pool.shutdown();
 
    }
}

//----------------------------------------------------------------------------------------------------------------------

Single-threaded Pool Executor Example
--------------------------------------

/**
 * This class represents a coutdown clock.
 */
import java.util.concurrent.*;
class CountDownClock extends Thread {
    private String clockName;
 
    public CountDownClock(String clockName) {
        this.clockName = clockName;
    }
 
    public void run() {
        String threadName = Thread.currentThread().getName();
 
        for (int i = 5; i >= 0; i--) {
 
            System.out.printf("%s -> %s: %d\n", threadName, clockName, i);
 
            try {
                Thread.sleep(1000);
            } catch (InterruptedException ex) {
                ex.printStackTrace();
            }
        }
    }
} 
/**
 * This program demonstrates how to execute multiple tasks
 * with different kinds of executors.
 */
public class SingleTasksExecutorExample {
 
    public static void main(String[] args) {
 
        ExecutorService pool = Executors.newSingleThreadExecutor();
 
        pool.execute(new CountDownClock("A"));
        pool.execute(new CountDownClock("B"));
        pool.execute(new CountDownClock("C"));
        pool.execute(new CountDownClock("D"));
 
        pool.shutdown();
 
    }
}


//--------------------------------------------------------------------------------------------------------------------------

	Custom Thread Pool Executor
	-----------------------------

	In case you want to have more control over the behaviors of a thread pool, you can create a thread pool executor 
	directly from the ThreadPoolExecutorclass instead of the factory methods of the Executors utility class.

	For example, the ThreadPoolExecutor has a general purpose constructor as follows:

	public ThreadPoolExecutor(int corePoolSize,
                  int maximumPoolSize,
                  long keepAliveTime,
                  TimeUnit unit,
                  BlockingQueue<Runnable> workQueue)

	You can tweak the parameters to suit your need, as long as you really understand what they mean:

	- corePoolSize: the number of threads to keep in the pool.
	- maximumPoolSize: the maximum number of threads to allow in the pool.
	- keepAliveTime: if the pool currently has more than corePoolSize threads, excess threads will be terminated 
			if they have been idle for more than keepAliveTime.
	- unit: the time unit for the keepAliveTime argument. Can be NANOSECONDS, MILLISECONDS, SECONDS, MINUTES, HOURS and DAYS.
	- workQueue: the queue used for holding tasks before they are executed. Default choices are SynchronousQueue 
		     for multi-threaded pools and LinkedBlockingQueue for single-threaded pools.

	Let’s see an example. The following code creates a cached thread pool that keeps minimum of 10 threads and allow 
	maximum of 1,000 threads, and idle threads are kept in the pool for 120 seconds:

	int corePoolSize = 10;
	int maxPoolSize = 1000;
	int keepAliveTime = 120;
	BlockingQueue<Runnable> workQueue = new SynchronousQueue<Runnable>();
 
	ThreadPoolExecutor pool = new ThreadPoolExecutor(corePoolSize, maxPoolSize, keepAliveTime, TimeUnit.SECONDS, workQueue);
	pool.execute(new RunnableTask());

//------------------------------------------------------------

	Fork/Join is a framework (new in JDK 7) for taking advantage of multiple processors.
	---------------------------------------------------------------------------------------

	The Fork/Join framework was indeed introduced in Java 7 as part of the java.util.concurrent package. 
	It's designed to make it easier to write parallelizable algorithms by decomposing them into smaller tasks 
	that can be executed concurrently, taking advantage of multiple processors or cores.

	Here's a brief overview of the Fork/Join framework:

	o- Divide and Conquer: The Fork/Join framework follows the divide-and-conquer paradigm. It breaks down a 
	   large task into smaller subtasks, which are executed independently in parallel. Once the subtasks are 
           completed, their results are combined to produce the final result of the original task.

	o- Work-Stealing Algorithm: Fork/Join employs a work-stealing algorithm to achieve load balancing among worker 
	   threads. Each worker thread maintains its own deque (double-ended queue) of tasks. When a thread finishes 
	   executing its tasks, it can "steal" tasks from the deque of another thread that is busy or has more tasks 
	   queued.

	o- Main Components:
	 - ForkJoinPool: The central component of the Fork/Join framework. It manages a pool of worker threads 
	   and distributes tasks among them.
	 - ForkJoinTask: Represents a task that can be executed asynchronously in the Fork/Join pool. It's an abstract 
	   class that can be subclassed to define specific tasks.
	 - RecursiveAction and RecursiveTask: Subclasses of ForkJoinTask. RecursiveAction is used for tasks that don't 
	   return a result, while RecursiveTask is used for tasks that produce a result.

	o- Parallelism and Concurrency: The Fork/Join framework allows developers to write parallel algorithms easily, 
	   taking advantage of the parallelism offered by modern multi-core processors. By decomposing tasks into 
	   smaller units of work and executing them concurrently, it can significantly improve the performance of 
	   certain types of computations.


import java.util.concurrent.RecursiveTask;
import java.util.concurrent.ForkJoinPool;

public class ArraySumExample extends RecursiveTask<Long> {
    private static final int THRESHOLD = 1000;
    private int[] array;
    private int start;
    private int end;

    public ArraySumExample(int[] array, int start, int end) {
        this.array = array;
        this.start = start;
        this.end = end;
    }

    @Override
    protected Long compute() {
        if (end - start <= THRESHOLD) {
            // Compute sum sequentially for small arrays
            long sum = 0;
            for (int i = start; i < end; i++) {
                sum += array[i];
            }
            return sum;
        } else {
            // Divide the array into smaller subarrays
            int mid = (start + end) / 2;
            ArraySumExample leftTask = new ArraySumExample(array, start, mid);
            ArraySumExample rightTask = new ArraySumExample(array, mid, end);

            // Fork the left and right subtasks
            leftTask.fork();
            long rightResult = rightTask.compute();

            // Join the results of the left and right subtasks
            long leftResult = leftTask.join();

            // Combine the results
            return leftResult + rightResult;
        }
    }

    public static void main(String[] args) {
        int[] array = new int[10000];
        // Initialize array with random values
        for (int i = 0; i < array.length; i++) {
            array[i] = (int) (Math.random() * 100);
        }

        // Create a ForkJoinPool
        ForkJoinPool pool = new ForkJoinPool();

        // Create a task to compute the sum of the array
        ArraySumExample task = new ArraySumExample(array, 0, array.length);

        // Execute the task in the pool
        long result = pool.invoke(task);

        // Print the result
        System.out.println("Sum of the array: " + result);
    }
}

//---------------------------------------------------------------------


import java.util.concurrent.Semaphore;

class Resource {
    private int value = 0;

    // Semaphores
    private final Semaphore emptySlots = new Semaphore(1); // Allow 1 production
    private final Semaphore filledSlots = new Semaphore(0); // Block consumption until produced
    private final Semaphore mutex = new Semaphore(1); // Ensure mutual exclusion

    public int getValue() {
        return value;
    }

    public void produce() throws InterruptedException {
        emptySlots.acquire(); // Wait if already produced
        mutex.acquire(); // Lock resource

        value++;
        System.out.println("Produced - Value: " + value);

        mutex.release(); // Unlock resource
        filledSlots.release(); // Signal consumer that item is available
    }

    public void consume() throws InterruptedException {
        filledSlots.acquire(); // Wait if no item is available
        mutex.acquire(); // Lock resource

        value--;
        System.out.println("Consumed - Value: " + value);

        mutex.release(); // Unlock resource
        emptySlots.release(); // Signal producer that space is available
    }
}

public class ProducerConsumerExample11 {
    public static void main(String[] args) {
        Resource rob = new Resource();

        // Producer Thread
        Thread producer = new Thread(() -> {
            for (int i = 0; i < 15; i++) {
                try {
                    Thread.sleep(300); // Simulate production time
                    rob.produce();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });

        // Consumer Thread
        Thread consumer = new Thread(() -> {
            for (int i = 0; i < 15; i++) {
                try {
                    Thread.sleep(300); // Simulate consumption time
                    rob.consume();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });

        producer.start();
        consumer.start();
    }
}

//---------------------------------------------------------------------

	Semaphore in java   
	-----------------
	(Semaphore: Dictionary meaning - an apparatus for conveying information by means of visual signals)

	Semaphore in Java (Concurrency API)
	A Semaphore in Java is a thread synchronization mechanism used to control access to shared resources 
	by multiple threads. It is part of the java.util.concurrent package.

	What is a Semaphore?
	- Semaphore maintains a set of permits(tokens).
	- A thread must acquire a permit before accessing a resource.
	- If no permits are available, the thread waits until one is released.
	- When a thread is done, it releases the permit, allowing another thread to proceed.	

	Types of Semaphore in Java
	- Counting Semaphore – Allows multiple permits (e.g., limit access to threads at a time).
	- Binary Semaphore (like a mutex) – Allows only one thread at a time (like synchronized).


in Java when we want to Limit number of concurrent Threads accessing any resources so then we should go for Semaphore. Semaphore maintain the set of permits and permits are not available then thread has to wait like suppose there are 5 threads and then want to limit that only 3 threads will be executed then we set the limit to three.so only three threads will be executed and other thread will be in waiting state

import java.util.concurrent.Semaphore;
class Resource
{
	int []x = {11,22,33,44,55,66,77,88,99};	
	// Semaphore semaphore = new Semaphore(1);
	// Semaphore semaphore = new Semaphore(2);
	 Semaphore semaphore = new Semaphore(3);
	 Semaphore semaphore = new Semaphore(3,true);
	public void show() {
		try
		{
			semaphore.acquire();
			for(int i=0;i<10;i++)
			{
				System.out.println(Thread.currentThread().getName()+" - "+i);
				try{Thread.sleep(800);}catch(Exception e){}
			}
		}
		catch (Exception e) {}
		finally {
			System.out.println(Thread.currentThread().getName() + " released permit.");
			semaphore.release();
		}
	}
}
class DemoSemophare
{
	public static void main(String[] args) 
	{
		Resource res = new Resource();		
		for(int i=0 ; i<5 ; i++) {
			new Thread(){
				public void run() {
					res.show();
				}
			}.start();
		}
	}
}


//---------------------------------------------

Here's your Producer-Consumer example rewritten using Semaphores instead of wait() and notify().
import java.util.concurrent.Semaphore;

class Resource {
    private int value = 0;

    // Semaphores
    private final Semaphore emptySlots = new Semaphore(1); // Allow 1 production
    private final Semaphore filledSlots = new Semaphore(0); // Block consumption until produced
    private final Semaphore mutex = new Semaphore(1); // Ensure mutual exclusion

    public int getValue() {
        return value;
    }

    public void produce() throws InterruptedException {
        emptySlots.acquire(); // Wait if already produced
        mutex.acquire(); // Lock resource

        value++;
        System.out.println("Produced - Value: " + value);

        mutex.release(); // Unlock resource
        filledSlots.release(); // Signal consumer that item is available
    }

    public void consume() throws InterruptedException {
        filledSlots.acquire(); // Wait if no item is available
        mutex.acquire(); // Lock resource

        value--;
        System.out.println("Consumed - Value: " + value);

        mutex.release(); // Unlock resource
        emptySlots.release(); // Signal producer that space is available
    }
}

public class ProducerConsumerExample11 {
    public static void main(String[] args) {
        Resource rob = new Resource();

        // Producer Thread
        Thread producer = new Thread(() -> {
            for (int i = 0; i < 15; i++) {
                try {
                    Thread.sleep(300); // Simulate production time
                    rob.produce();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });

        // Consumer Thread
        Thread consumer = new Thread(() -> {
            for (int i = 0; i < 15; i++) {
                try {
                    Thread.sleep(300); // Simulate consumption time
                    rob.consume();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });

        producer.start();
        consumer.start();
    }
}

//-------------------------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------------------------

	- Daemon Thread
       ------------------

	What is Daemon Thread in Java?
	Daemon thread in Java is a low-priority thread that performs background operations such as garbage collection, 
	finalizer, Action Listeners, Signal dispatches, etc.

	Daemon thread in Java is also a service provider thread that helps the user thread. Its life is at the mercy of user 
	threads; when all user threads expire, JVM immediately terminates this thread.

	In simple words, we can say that it provides services to user threads for background-supporting tasks. Daemon thread 
	in Java has no role in life other than to serve user threads.

	 Properties of Daemon Thread in Java
	- It's a thread with the possible lowest priority
	- They won't be able to stop the JVM from quitting once all of the user threads have completed their tasks.
	- When all user threads have completed their execution, the JVM terminates Daemon Thread.
	- If JVM finds a running daemon thread, it terminates the thread and, after that, shutdown it.
	- The JVM is unconcerned about whether the Daemon thread is active or not.
	- The nature of a demon is passed down from parent to child. That is, if the parent is a Daemon, the child will 
	  be a Daemon as well, and if the parent is a non-daemon, the child will be a non-daemon as well.

Methods for Daemon Thread in Java by Thread Class

 - public void setDaemon(boolean status)	
	This method marks whether the current thread as a daemon thread or a user thread.

 - public final boolean isDaemon()	
	This method is used to determine whether or not the current thread is a daemon. If the thread is Daemon, it returns true. 
	Otherwise, false is returned.

import java.util.Random;
class WorkerThread extends Thread
{
	public WorkerThread()
	{
		start();
	}
	public void run()
	{
		for(int i=0;i<10;i++)
		{
			System.out.println(i+" - "+Thread.currentThread().getName()+" isDaemon: "+Thread.currentThread().isDaemon());
			try{Thread.sleep(new Random().nextInt(1000));}catch(Exception e){}
		}
		System.out.println(Thread.currentThread().getName()+" - Ended");
	}
}
class Runner extends Thread
{
	public void run()
	{
		while(true)
		{
			
			try{Thread.sleep(new Random().nextInt(2000));}catch(Exception e){}
			System.out.println("Ob is Running: "+this.isAlive());
		}			
	}
}
class DaemonThreadExample
{
	public static void main(String[] args) 
	{
		Runner ob=new Runner();
		ob.setDaemon(true);
		ob.start();
		System.out.println("Ob is Running: "+ob.isAlive());

		Thread []tar=new Thread[4];
		for(int i=0;i<tar.length;i++)
		{
			tar[i]=new WorkerThread();
		}

		System.out.println("Ob is Running: "+ob.isAlive());
		System.out.println("Main Ended");
	}
}

//-------------------------------------------------------


Daemon Thread vs User Thread

learn more about the distinctions between Daemon and User threads:

	Daemon Threads					User Threads (Non-daemon)

	- Low Priority threads				- High priority threads
	- The JVM does not wait for its execution 	- The JVM waits till the execution is finished.
	  to complete.
	- Life is dependent on user threads		- Life is independent
	- Daemon threads are created by JVM		- An application creates its own user threads.
	- provides service to the user thread 		- Used for foreground tasks.
	  which runs in the background


//---------------------------------------------------------------------------------------------------------------------

	// Runtime class in java 

	The Runtime class in Java is a part of the java.lang package and represents the runtime environment 
	of the Java application. It allows the application to interact with the JVM (Java Virtual Machine) 
	in various ways, such as executing processes, interacting with the garbage collector, and accessing 
	information about the system.

	When to Use the Runtime Class?
	- Monitoring system resources like memory and processor availability.
	- Running system commands or launching external processes.
	- Registering shutdown hooks for cleanup before application termination.
	- Accessing system-level information for performance optimization.

//Executing a System Command
public class ExecuteCommandExample {
    public static void main(String[] args) {
        try {
            // Get the runtime instance
            Runtime runtime = Runtime.getRuntime();

            // Execute a system command (example: open Notepad in Windows)
            Process process = runtime.exec("notepad");

            // Wait for the process to complete
            process.waitFor();

            System.out.println("Notepad exited.");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

//Getting Runtime Information

public class RuntimeInfoExample {
    public static void main(String[] args) {
        // Get the runtime instance
        Runtime runtime = Runtime.getRuntime();

        // Print memory details
        System.out.println("Total Memory: " + runtime.totalMemory());
        System.out.println("Free Memory: " + runtime.freeMemory());
        System.out.println("Max Memory: " + runtime.maxMemory());

        // Print available processors
        System.out.println("Available Processors: " + runtime.availableProcessors());
    }
}

//------------------------------
// Code Example: Shutdown Using Runtime Class

import java.io.IOException;

public class ShutdownComputer {
    public static void main(String[] args) {
        // Get the runtime instance
        Runtime runtime = Runtime.getRuntime();

        try {
            // Check the operating system
            String os = System.getProperty("os.name").toLowerCase();

            if (os.contains("win")) {
                // Windows shutdown command
                runtime.exec("shutdown -s -t 0");
            } else if (os.contains("mac")) {
                // macOS shutdown command
                runtime.exec("shutdown -h now");
            } else if (os.contains("nix") || os.contains("nux") || os.contains("aix")) {
                // Linux/Unix shutdown command
                runtime.exec("shutdown -h now");
            } else {
                System.out.println("Unsupported operating system: " + os);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
//----------------------------------------------------------------------------

	Java Shutdown Hook: 

	A Java Shutdown Hook is a feature that allows you to execute custom cleanup code when a Java Virtual 
	Machine (JVM) is shutting down. The shutdown hook is a thread that you can register with the JVM to 
	perform tasks such as closing resources, saving application state, or logging information before the 
	application exits.

	How Shutdown Hook Works
	When the JVM shuts down, either normally (e.g., program exit) or abnormally (e.g., by a user interrupt
	like Ctrl+C), it executes all registered shutdown hooks. However, these hooks will not run in certain 
	situations like:

	- The JVM is forcefully terminated using System.exit() with no hooks registered.
	- The JVM is killed using OS commands like kill -9.

public class ShutdownHookExample {
    public static void main(String[] args) {

        // Registering a shutdown hook
        Runtime.getRuntime().addShutdownHook(new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println("Shutdown Hook is running...");
                // Perform cleanup operations here
            }
        }));

        System.out.println("Application is running...");
        
        // Simulate some operation
        try {
            Thread.sleep(5000); // Let the program run for 5 seconds
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("Application is exiting...");
    }
}

///===============================================================================================================================
///===============================================================================================================================

               ************** Generics (java 5) in java You tube Video************** 


   Issues before Generics :

     1. No Type safety.
     2. Manual Casting.
     3. No Compile time checking. 


 ***********  Class Generic ***********

import java.lang.reflect.Array;
import java.util.ArrayList;

public class Thread3{

    public static void main(String[]args)
    {
        ArrayList<String> list  = new ArrayList<>();
        list.add("hello");
        list.add("hiii");
       
        String s =  list.get(0);
        String s1 = list.get(1);



       // String str = (String)list.get(0);   // manual casting
        //Integer integer = (Integer)list.get(1);

    }
}


          <T> : Type (Convention)
           E  : Element (Used in Collection)
           K  : Key (Used in maps)
           V  : Value (Used in maps)
           N  : Number



************  Generic Interface **************


  *************  Bounded type **************
 Syntax: <T extends Number> : T class extends Number
  
    






///===============================================================================================================================
///===============================================================================================================================
///===============================================================================================================================

/// Using Java Library Classes: 


	/// java.lang.Object:
	------------------

	In Java, java.lang.Object is the root class of all classes. Every class in Java is a direct or indirect subclass 
	of Object. It's located in the java.lang package, which is automatically imported into every Java program, 
	o you don't need to explicitly import it.

	constructor: 
	 - Object() : Default Constructor.

	The Object class defines several important methods that are available to all Java objects. 
	Some of the most commonly used methods defined in Object are:

	- toString(): Returns a string representation of the object. By default, this method returns the class 
	  name followed by the "@" symbol and the hash code of the object.

	- equals(Object obj): Indicates whether some other object is "equal to" this one. The default implementation 
	  in Object compares object references.

	- hashCode(): Returns a hash code value for the object. The default implementation returns the internal 
	  memory address of the object in hexadecimal form.

	- getClass(): Returns the runtime class of this object. This method returns an instance of the Class class 
	  that provides information about the object's class.

	- notify(), notifyAll(), and wait(): These methods are used for inter-thread communication and synchronization.


	// creating an object of Object class.

class ObjectDemoEx
{
	public static void main(String[] args) 
	{
		Object ob=new Object();
		System.out.println(" Ob Prints: "+ob);
		System.out.println(" tostring Prints: "+ob.toString());
		System.out.println(" hashcode Prints: "+ob.hashCode());
		System.out.println(" getclass Prints: "+ob.getClass());

		String str=new String("hello");
		System.out.println(" equals str Prints: "+ob.equals(str));
		
		Object ob1=new Object();
		System.out.println(" equal another Object Prints: "+ob.equals(ob1));

		Object ob3 = ob;
		System.out.println(" equals same reference Prints: "+ob.equals(ob3));
	}
}


	A hash code is an integer value that is associated with each object in Java. 
	Its main purpose is to facilitate hashing in hash tables, which are used by 
	data structures like HashMap.



	// generally it is the string representation of an object, bydefault its starts with class namethen @ and then 
	// hashcode of object, but it is expected that, override that method in child class to represent the object in 
	// its equivalent object as as you want or as needed.

	// When you print object directly the bydefault toString method is invoked.

class ObjectDemo 
{
	public static void main(String[] args) 
	{
		Object ob=new Object();
		System.out.println(" Ob Prints: "+ob);
		System.out.println(" Ob Prints: "+ob.toString());
	}
}

// which will gives same output.

//---------------------------------------------------------

	// Overriding the toString method: AS any class having the java.lang.Object as parent. we are allowed to 
	   override the toString method.

class MyClass
{
	String info;
}
class ObjectDemoExample
{
	public static void main(String[] args) 
	{
		MyClass ob=new MyClass();
		System.out.println("Object Information: "+ob);
	}
}
	
-------output on run ---------
 Ob Prints: java.lang.Object@372f7a8d
Press any key to continue . . .


class MyClass
{
	String info;
	public String toString()
	{
		return "Printing object inforamtion";
	}
}
class ObjectDemoExample
{
	public static void main(String[] args) 
	{
		MyClass ob=new MyClass();
		System.out.println("Object Information: "+ob);
	}
}
-------output on run ---------
Object Information: Printing object inforamtion
Press any key to continue . . .

//----------------------------------------------------------------------------	

class MyClass extends Thread
{
	Thread t;
	public MyClass()
	{
		super("Thread - 0");
		t=this;
	}
	String info;
	public String toString()
	{
		t=Thread.currentThread();
		info= "["+t.getName()+", "+t.getPriority()+", "+t.getThreadGroup()+"]";
		return info;
	}
}
class ObjectDemoExample
{
	public static void main(String[] args) 
	{
		MyClass ob=new MyClass();
		System.out.println("Object Information: "+ob);
	}
}

//--------------------------------------------------
class MyException extends Exception
{
	String exp_info;
	public MyException(String t)
	{
		exp_info=t;
	}
	public String toString()
	{
		return exp_info;
	}
}

class ObjectDemoExample
{
	public static void main(String[] args) 
	{
		MyException ob=new MyException("Exception inforamtion");
		System.out.println("Object Information: "+ob);
	}
}

//=========================================================================================================

	// Wrapper Classes in Java: 

	- It is actually group of classes, used to represent the data type in its equivalent object form.
	- They are known as wrapper classes, coz individual class represents, i.e. wraps up, one data
	  type within it.
	
		e.g.: just like the classes that we have defined..!!

		class MyIntArray		class MyInt		class MyString
		{				{			{
			int x[];			int no;			char []data;	
			....				.....		 	.....
		} 				}			}

	- Here in java we are unable to pass the the values of builtin type by reference. coz we dont 
	  have ampersand operator or here in java creating alise using &, is not allowed. But as the 
	  object gains the dynamic memory space, it is possible to values of builtin by reference, when
	  they are represented in its equivalent object from.

	- List of data type and provided classes

		----------------------------------------------
		data type			Wrapper class
		----------------------------------------------
		char				Character
		byte				Byte
		short				Short
		int				Integer
		long				Long
		float				Float
		double				Double
		boolean				Boolean
		----------------------------------------------
	 Note that,
			byte b;	   // is a variable
			Byte b;    // is a object

	- Hierarchical diagram of Wrapper classes

	Object
	│
	├─── Number
	│    ├─── Byte
	│    ├─── Short
	│    ├─── Integer
	│    ├─── Long
	│    ├─── Float
	│    └─── Double
	├─── Boolean
	└─── Character


	- Wrapper classes provide useful methods and properties that are not available with primitive data types. 
	- Using Wrapper classes Autoboxing and Unboxing become very easy.
	- They facilitate converting primitive data types into objects and vice versa. 
	- Wrapper classes allow for null values. Primitive data types cannot be null, but their corresponding wrapper classes can.
	  This is beneficial when you need to represent the absence of a value.
	- They simplify casting between different types. 
	- They enable the use of primitive data types in collections and other classes that only work with objects.
	- wrapper classes in Java, provides instances which are immutable. Once created, the value cannot be changed.


         e.g: Integer a = 1;
 
             Integer = class

             a= (object/ref variable)
//----------------------------------------------------------------

- java.lang.Number Class:
--------------------------
	class Declaration: 
		- public abstract class Number extends Object implements Serializable

	(Serialization in Java refers to the process of converting an object into a byte stream, 
	 which can be easily stored in a file or sent over the network. This byte stream can then be 
	 reconstructed back into an object whenever needed.)

	Constructor: 
		- Number(): 

	methods: 	
	- byte byteValue(): method returning the value of the specified number as a byte.
	- double doubleValue(): Abstract method returning the value of the specified number as a double.
	- float floatValue(): Abstract method returning the value of the specified number as a float.
	- int intValue(): Abstract method returning the value of the specified number as an integer.
	- long longValue(): Abstract method returning the value of the specified number as a long.
	- short shortValue(): method returning the value of the specified number as a short.

	*Note: All these methods are present in all classes used to represent Numeric values.

- java.lang.Byte class:
-------------------------
	The java.lang.Byte class is a wrapper class for the primitive data type byte. It provides methods 
	to parse, convert, and manipulate byte values. 

	Fields:
	- public static final byte MIN_VALUE: The minimum value that a byte can have: -128.
	- public static final byte MAX_VALUE: The maximum value that a byte can have: 127.
	- public static final Class<Byte> TYPE: The Class object representing the primitive type byte.
	- public static int BYTES: The number of bytes used to represent a byte value in two's complement binary form.
	- public static int SIZE: The number of bits used to represent a byte value in two's complement binary form.

	Constructors:
	- public Byte(byte value): Constructs a newly allocated Byte object that represents the specified byte value.
	- public Byte(String s) throws NumberFormatException: Constructs a newly allocated Byte object that represents 
		the byte value indicated by the String parameter. The string is converted to a byte value as if by the 
		byte.parseByte method.

	Methods:
	- public byte byteValue(): Returns the value of this Byte object as a byte primitive.
	- public int compareTo(Byte anotherByte): Compares two Byte objects numerically.
	- public double doubleValue(): Returns the value of this Byte object as a double primitive.
	- public boolean equals(Object obj): Compares this object to the specified object. The result is true if and 
		only if the argument is not null and is a Byte object that contains the same byte value as this object.
		(will checks the references are same or not.)
	- public float floatValue(): Returns the value of this Byte object as a float primitive.
	- public int hashCode(): Returns a hash code for this Byte object.
	- public int intValue(): Returns the value of this Byte object as an int primitive.
	- public long longValue(): Returns the value of this Byte object as a long primitive.
	- public static byte parseByte(String s) throws NumberFormatException: Parses the string argument as a 
		signed decimal byte.
	- public short shortValue(): Returns the value of this Byte object as a short primitive.
	- public String toString(): Returns a string representation of this Byte object in base 10.
	- static String	toString(byte b): Returns a new String object representing the specified byte.
	- public static Byte valueOf(byte b): Returns a Byte instance representing the specified byte value.
	- public static Byte valueOf(String s) throws NumberFormatException: Returns a Byte object holding the 
		value of the specified String.
	- public static Byte valueOf(String s, int radix) throws NumberFormatException: Returns a Byte object holding the 
		value extracted from the specified String when parsed with the radix given by the second argument.


class ByteWrapperDemo 
{
	public static void main(String[] args) 
	{
		// Byte class fields
		System.out.println("Min Value: "+Byte.MIN_VALUE);
		System.out.println("Min Value: "+Byte.MAX_VALUE);
		System.out.println("Representing primitive type: "+Byte.TYPE);		
		System.out.println("Space Needed in bytes: "+Byte.BYTES);		
		System.out.println("Space Needed in bits: "+Byte.SIZE);

		// Using Byte class constructors
		Byte ob1=new Byte((byte)10);  		
		byte b=10;
		Byte ob2=new Byte(b);      
		Byte ob3=new Byte("123");     
		
		// Converting the value to different primitive type
		System.out.println("byte value: "+ob1.byteValue());
		System.out.println("short value: "+ob1.shortValue());
		System.out.println("int value: "+ob1.intValue());
		System.out.println("long value: "+ob1.longValue());
		float ft=ob1.floatValue();
		System.out.println("float value: "+ft);
		double db=ob1.doubleValue();
		System.out.println("double value: "+db);

		// using public int compareTo(Byte anotherByte)
		// this method returns numeric ans of ob1-ob2/ob3, it is non-zero when
		// objects having different value and zero when objects having same value.
		int t=ob1.compareTo(ob3);
		System.out.println("return value t: "+t);
		t=ob1.compareTo(ob2);
		System.out.println("return value t: "+t);

		// using public boolean equals(Object obj):
		boolean ans=ob1.equals(ob2);
		System.out.println("return value ans: "+ans);
		// equals give true when both reference refering towards samelocation
		// here in this case ans is true coz as the ob1 and ob2 having same value
		// while creating object, in same vaue is there in memory the that location
		// is refered by new reference.
		// if we change the value of ob1 or ob2, then it will gives false.

		// Note: compareTo() compares the numeric values of object and equals()
		//	     compares the references of both objects, means both objects are
		//		 refering towards same ocation or not.

		ans=ob1.equals(ob3);
		System.out.println("return value ans: "+ans);


		// Using Parsing
		String num="120";
		byte n=Byte.parseByte(num);
		System.out.println("byte n: "+n);

		// using toString()
		byte val1=56;
		String s=Byte.toString(val1);		
		System.out.println("String s: "+s);

		String s1=ob3.toString();
		System.out.println("String s1: "+s1);

		// using valueOf()

		byte val2=15;
		Byte ob4=Byte.valueOf(val2);
		System.out.println("ob4 is: "+ob4); // ob4.toString() called internally

		String s2="45";
		Byte ob5=Byte.valueOf(s2);
		System.out.println("ob5 is: "+ob5);
	}
}

//----------------------------------------------------------------------------------------------
 
- java.lang.Short class:
-------------------------
	The java.lang.Short class is a wrapper class for the primitive data type short. It provides methods to parse, convert, 
	and manipulate short values. 

	Fields:
	- public static final short MIN_VALUE: The minimum value that a short can have: -32768.
	- public static final short MAX_VALUE: The maximum value that a short can have: 32767.
	- public static final Class<Short> TYPE: The Class object representing the primitive type short.
	- static int BYTES: The number of bytes used to represent a short value in two's complement binary form.
	- static int SIZE: The number of bits used to represent a short value in two's complement binary form.

	Constructors:
	- public Short(short value): Constructs a newly allocated Short object that represents the specified short value.
	- public Short(String s) throws NumberFormatException: Constructs a newly allocated Short object that represents 
		the short value indicated by the String parameter. The string is converted to a short value as if by the 
		short.parseShort method.

	Methods:
	- public byte byteValue()
	- public int compareTo(Short anotherShort)
	- public double doubleValue()
	- public boolean equals(Object obj)
	- public float floatValue()
	- public int hashCode()
	- public int intValue()
	- public long longValue()
	- public static short parseShort(String s) throws NumberFormatException
	- public static short parseShort(String s, int radix) throws NumberFormatException
	- public short shortValue()
	- public String toString()
	- public static Short valueOf(short s)
	- public static Short valueOf(String s) throws NumberFormatException
	- public static Short valueOf(String s, int radix) throws NumberFormatException


class ShortDemo 
{
	public static void main(String[] args) 
	{
		String nms="1111";
		short no=Short.parseShort(nms,2);
		System.out.println("No: "+no);
	}
}

//----------------------------------------------

java.lang.Integer class:
-------------------------

	Fields:
	- public static final int MIN_VALUE
	- public static final int MAX_VALUE
	- public static final Class<Integer> TYPE
	- static int BYTES
	- static int SIZE

	Constructors:
	- public Integer(int value)
	- public Integer(String s) throws NumberFormatException

	Methods:
	- public byte byteValue()
	- public int compareTo(Integer anotherInteger)
	- public double doubleValue()
	- public boolean equals(Object obj)
	- public float floatValue()
	- public int hashCode()
	- public int intValue()
	- public long longValue()
	- public static int parseInt(String s) throws NumberFormatException
	- public static int parseInt(String s, int radix) throws NumberFormatException
	- public short shortValue()
	- public String toString()
	- public static Integer valueOf(int i)
	- public static Integer valueOf(String s) throws NumberFormatException
	- public static Integer valueOf(String s, int radix) throws NumberFormatException

	

//----------------------------------------------------------------------------------------------

java.lang.Long class:
----------------------

	Fields:
	- public static final long MIN_VALUE
	- public static final long MAX_VALUE
	- public static final Class<Long> TYPE

	Constructors:
	- public Long(long value)
	- public Long(String s) throws NumberFormatException

	Methods:
	- public byte byteValue()
	- public int compareTo(Long anotherLong)
	- public double doubleValue()
	- public boolean equals(Object obj)
	- public float floatValue()
	- public int hashCode()
	- public int intValue()
	- public long longValue()
	- public static long parseLong(String s) throws NumberFormatException
	- public static long parseLong(String s, int radix) throws NumberFormatException
	- public short shortValue()
	- public String toString()
	- public static Long valueOf(long l)
	- public static Long valueOf(String s) throws NumberFormatException
	- public static Long valueOf(String s, int radix) throws NumberFormatException


//----------------------------------------------------------------------------------------------


java.lang.Float class:
----------------------

	Fields:
	- public static final float POSITIVE_INFINITY: Represents positive infinity.
	- public static final float NEGATIVE_INFINITY: Represents negative infinity.
	- public static final float NaN: Represents "not a number" (NaN).
	- public static final float MAX_VALUE: The maximum positive finite value of type float.
	- public static final float MIN_NORMAL: The smallest positive nonzero value of type float.
	- public static final float MIN_VALUE: The smallest positive value of type float.
	- public static final int MAX_EXPONENT: The maximum exponent a finite float variable may have.
	- public static final int MIN_EXPONENT: The minimum exponent a normalized float variable may have.
	- public static final int SIZE: The number of bits used to represent a float value.
	- public static final int BYTES: The number of bytes used to represent a float value.
	- public static final Class<Float> TYPE: The Class object that represents the primitive type float

	Constructors:
	- public Float(double value)
	- public Float(float value)
	- public Float(String s) throws NumberFormatException

	Methods:
	- public byte byteValue()
	- public int compareTo(Float anotherFloat)
	- public double doubleValue()
	- public boolean equals(Object obj)
	- public int hashCode()
	- public int intValue()
	- public boolean isInfinite()
	- public boolean isNaN()
	- public long longValue()
	- public static float parseFloat(String s) throws NumberFormatException
	- public short shortValue()
	- public String toString()
	- boolean isInfinite()
	- static boolean isInfinite(float v)
	- boolean isNaN()
	- static boolean isNaN(float v)
	- static float	max(float a, float b)
	- static float	min(float a, float b)
	- static float	sum(float a, float b)
	- static String	toHexString(float f)
	- public static String toString(float f)
	- public static Float valueOf(float f)
	- public static Float valueOf(String s) throws NumberFormatException

class FractionaWrapperExampe 
{
	public static void main(String[] args) 
	{
		int x=10, y=0;
		//System.out.println("x/y: "+(x/y)); 
		//Exception in thread "main" java.lang.ArithmeticException: / by zero

		float a=12.4f,b=0.0f;
		System.out.println("a/b: "+(a/b)); // a/b: Infinity

		float p=-132.4f,q=0.0f;
		System.out.println("p/q: "+(p/q)); // p/q: -Infinity

		System.out.println(0.0 / 0.0);	  //zero divided by zero //NaN
        	System.out.println(Math.sqrt(-1)); //take sqrt of negative number //NaN
        	System.out.println(10.0 % 0);      //taking mod by zero //NaN

		float v1=56.34f, v2=67.23f,vmax=0.0f,vmin=0.0f;
		vmax=Float.max(v1,v2);
		vmin=Float.min(v1,v2);
		System.out.println("Min Value: "+vmin+"\t Max Value: "+vmax);
		System.out.println("v1+v2= "+Float.sum(v1,v2));

		v1=15F;
		System.out.println("Hex of v1: "+Float.toHexString(v1));		
	}
}

//--------------------------------------------------------------------------

java.lang.Double class:
------------------------

	Fields:
	- public static final double POSITIVE_INFINITY
	- public static final double NEGATIVE_INFINITY
	- public static final double NaN
	- public static final double MAX_VALUE
	- public static final double MIN_NORMAL
	- public static final double MIN_VALUE
	- public static final int MAX_EXPONENT
	- public static final int MIN_EXPONENT
	- public static final int SIZE
	- public static final int BYTES
	- public static final Class<Double> TYPE

	Constructors:
	- public Double(double value)
	- public Double(String s) throws NumberFormatException

	Methods:
	- public byte byteValue()
	- public int compareTo(Double anotherDouble)
	- public double doubleValue()
	- public boolean equals(Object obj)
	- public float floatValue()
	- public int hashCode()
	- public int intValue()
	- public boolean isInfinite()
	- public boolean isNaN()
	- public long longValue()
	- public static double parseDouble(String s) throws NumberFormatException
	- public short shortValue()
	- public String toString()	
	- static float	max(float a, float b)
	- static float	min(float a, float b)
	- static float	sum(float a, float b)
	- static String	toHexString(float f)
	- public static String toString(double d)
	- public static Double valueOf(double d)
	- public static Double valueOf(String s) throws NumberFormatException


 - boxing, autoboxing and unboxing in java
----------------------------------------------

	In Java, boxing, autoboxing, and unboxing are concepts related to the conversion between primitive data types and
	their corresponding wrapper classes.

	- Boxing: Boxing is the process of converting a primitive data type into its equivalent wrapper class object manually. 
		This conversion is done explicitly by calling the constructor of the wrapper class or by using static 
		factory methods.

	- Autoboxing: Autoboxing is the automatic conversion of primitive data types into their corresponding wrapper 
		class objects. It occurs when a primitive data type is used in a context where an object of its wrapper 
		class is expected. it will automatically converting primitive types to their wrapper classes when needed.

	- Unboxing: Unboxing is the process of converting a wrapper class object back to its corresponding primitive data 
		type manually. This conversion is done explicitly by calling methods provided by the wrapper class, such as 
		intValue() for Integer or it will happen automatically when an object directy assigned to primitive type variable.

class TestExample 
{
	public static void main(String[] args) 
	{
		double d=45.34;
		Double obj=new Double(d); // Boxing
		double val=obj.doubleValue(); // Unboxing
		System.out.println("Double value: "+val);
		//-------------------------------------------
		Integer ob=10;	// Autoboxing
		System.out.println(ob); // Unboxing

		int x=ob;	// Unboxing
		System.out.println(x);
	}
}

//--------------------------------------------------------------------------

java.lang.Boolean class:
-------------------------

	Fields:
	- public static final Boolean TRUE: Represents the true value of the boolean type.
	- public static final Boolean FALSE: Represents the false value of the boolean type.

	Constructors:
	- public Boolean(boolean value): Constructs a newly allocated Boolean object that represents the specified 
		boolean value. This constructor creates a Boolean object initialized with the specified boolean value.

	- public Boolean(String s) throws IllegalArgumentException: Constructs a newly allocated Boolean object that represents 
		the value true if the string argument is not null and is equal, ignoring case, to the string "true". Otherwise, 
		it represents the value false.

	- static Class<Boolean>	TYPE: The Class object representing the primitive type boolean.

	Methods:
	- public boolean booleanValue()
	- public int compareTo(Boolean b)
	- public boolean equals(Object obj)
	- public int hashCode()
	- public static Boolean valueOf(boolean b)
	- public static Boolean valueOf(String s)
	- public String toString()
	- static int hashCode(boolean value)
	- static boolean logicalAnd(boolean a, boolean b)
	- static boolean logicalOr(boolean a, boolean b)
	- static boolean logicalXor(boolean a, boolean b)
	- static boolean getBoolean(String name)

class BooleanWrapperExample 
{
	public static void main(String[] args) 
	{
		Boolean b1=new Boolean(true);
		Boolean b2=new Boolean("false");        
		System.out.println("b1: "+b1+"\t b2: "+b2);

		// logical AND
		System.out.println(Boolean.logicalAnd(b1,b2));
		System.out.println(Boolean.logicalAnd(false,true));
		System.out.println(Boolean.logicalAnd(b1,true));
		System.out.println(Boolean.logicalAnd(false,b2));
		System.out.println("--------------------------------------");

		// logical OR
		System.out.println(Boolean.logicalOr(b1,b2));
		System.out.println(Boolean.logicalOr(false,true));
		System.out.println(Boolean.logicalOr(b1,true));
		System.out.println(Boolean.logicalOr(false,b2));
		System.out.println("--------------------------------------");

		// logical XOR
		System.out.println(Boolean.logicalXor(b1,b2));
		System.out.println(Boolean.logicalXor(false,true));
		System.out.println(Boolean.logicalXor(b1,true));
		System.out.println(Boolean.logicalXor(false,b2));
		System.out.println("--------------------------------------");
	}
}

//-------------------------------------------------------------------------------------------------------------------------

java.lang.Character class:
----------------------------

	Fields:
	- public static final char MIN_VALUE
	- public static final char MAX_VALUE
	- public static final int MIN_RADIX
	- public static final int MAX_RADIX
	- public static final Class<Character> TYPE

	Constructors:
	- public Character(char value)

	Methods:
	- static int charCount(int codePoint)
	- public char charValue()
	- static int compare(char x, char y)
	- public int compareTo(Character anotherCharacter)
	- public boolean equals(Object obj)
	- public int hashCode()
	- static boolean isAlphabetic(int codePoint)
	- public static boolean isDigit(char ch)
	- public static boolean isLetter(char ch)
	- public static boolean isLetterOrDigit(char ch)
	- public static boolean isLowerCase(char ch)
	- public static boolean isUpperCase(char ch)
	- public static char toLowerCase(char ch)
	- public static char toUpperCase(char ch)
	- public static String toString(char c)
	- public static Character valueOf(char c)
	- public static Character valueOf(String s)

public class CharacterMethodsDemo 
{
    public static void main(String[] args) 
    {
        // Character methods demonstration
        char ch = 'A';

        // isLetter
        System.out.println("isLetter('A'): " + Character.isLetter(ch));

        // isDigit
        System.out.println("isDigit('5'): " + Character.isDigit(ch));

        // isWhitespace
        System.out.println("isWhitespace(' '): " + Character.isWhitespace(' '));

        // isUpperCase
        System.out.println("isUpperCase('A'): " + Character.isUpperCase(ch));

        // isLowerCase
        System.out.println("isLowerCase('a'): " + Character.isLowerCase(ch));

        // toUpperCase
        System.out.println("toUpperCase('a'): " + Character.toUpperCase('a'));

        // toLowerCase
        System.out.println("toLowerCase('A'): " + Character.toLowerCase('A'));

        // getNumericValue
        System.out.println("getNumericValue('5'): " + Character.getNumericValue('5'));

        // compare
        System.out.println("compare('A', 'B'): " + Character.compare('A', 'B'));

        // toString
        System.out.println("toString('C'): " + Character.toString('C'));
    }
}

//------------------------------------------------------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------------------------------------------------

//------------------------------------------------------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------------------------------------------------

java.util.Arrays Class:
------------------------

	The Arrays class in Java provides various utility methods for working with arrays. It is part of the java.util package. 
	This class contains various methods for manipulating arrays (such as sorting and searching). This class also contains a 
	static factory that allows arrays to be viewed as lists.
	
	Some of the commonly used methods are:

	- Sorting Arrays:
		- public static void sort(int[] array): Sorts the specified array of integers into ascending numerical order.
		- public static void sort(Object[] array): Sorts the specified array of objects into ascending order, according 
			to the natural ordering of its elements. The range to be sorted extends from the index fromIndex(inclusive) 
			to the index toIndex(exclusive).
		- static void	parallelSort(int[] a): Sorts the specified array into ascending numerical order.

	- Searching Arrays:
		- public static int binarySearch(int[] array, int key): Searches the specified array of integers for the 
			specified value using the binary search algorithm. Returns index of the search key, if it is contained 
			in the array; otherwise returns, (-(insertion point) - 1).
		- public static int binarySearch(Object[] array, Object key): Searches the specified array of objects for 
			the specified object using the binary search algorithm.

	- Converting Arrays to Strings:
		- public static String toString(int[] array): Returns a string representation of the contents of the 
		  specified array.

	- Filling Arrays:
		- public static void fill(int[] array, int value): Assigns the specified int value to each element of the 
			specified array of integers.
		- static void	fill(int[] a, int fromIndex, int toIndex, int val): Assigns the specified int value to each 
			element of the specified range of the specified array of ints.

	- Copying Arrays:
		- public static int[] copyOf(int[] original, int newLength): Copies the specified array, truncating or padding 
			with zeros (if necessary) so the copy has the specified length.
		- static int[]	copyOfRange(int[] original, int from, int to): Copies the specified range of the specified array 
			into a new array.

	- Comparing Arrays:
		- public static boolean equals(int[] a, int[] b): Returns true if the two specified arrays of integers are 
			equal to one another.


Example:

import java.util.Arrays;
class DemoArrays 
{
	public static void main(String[] args) 
	{
		int []a = {23,56,78,89,4,76,22,43};
		System.out.println("Array is: "+a.toString()); // will prints Hashcode

		// Traditional Ways - Using for
		System.out.println("\n Arrays Elements are: ");
		for(int i=0 ;i<a.length;i++) {
			System.out.print("  "+a[i]);
		}

		// using foreach
		System.out.println("\n Arrays Elements are: ");
		for(int val : a) {
			System.out.print("  "+val);
		}

		//Sorting
		Arrays.sort(a);
		System.out.println("\n sorted Array: ");
		for(int val : a) {
			System.out.print("  "+val);
		}

		// searching
		int num = 78;
		int pos = Arrays.binarySearch(a, num);
		System.out.println("\n Element is present at: "+ pos);

		int []a1 = Arrays.copyOf(a,a.length);
		System.out.println("\n a1 copied Array: ");
		for(int val : a1) {
			System.out.print("  "+val);
		}

		int []a2 = Arrays.copyOf(a,10); // fill additional positions with 0
		//int []a2 = Arrays.copyOf(a,5); // copies elements from start and truncate some elements from last
		System.out.println("\n a2 copied Array: ");
		for(int val : a2) {
			System.out.print("  "+val);
		}

		int []a3 = Arrays.copyOfRange(a,2,5); // starting from 2(including) and upto 5(excluding)
		System.out.println("\n a3 copied-range Array: ");
		for(int val : a3) {
			System.out.print("  "+val);
		}
		//fill - 
		Arrays.fill(a2,1); // filled all array elements
		Arrays.fill(a3,1,2,111);	// filled including position 1 till 2(excluding) 	
		System.out.println("After fill x array is: "+Arrays.toString(a2));
		System.out.println("After fill range y array is: "+Arrays.toString(a3));
		// here Arrays.toString(a2) is static imple. of toString() in Arrays class, Not from array object(a.toString())

		//equals
		int []k={1,1,1,1,1,1,1,1,1,1};
		boolean b2=Arrays.equals(k,a2);
		System.out.println("x equals k: "+b2); //  true 
		// contents of both are same, ans as the data in constant pool both refers to same location 

		b2=Arrays.equals(a1,a); // true -> contents are same(as above)
		System.out.println("a1 equals a: "+b2);

		int[] a11 = a.clone();
		b2=Arrays.equals(a11,a); // true -> contents are same(as above) even if clone()
		System.out.println("a11 equals a: "+b2);

	}
}


//--------------------------------------------------------------------------------------------------------------

// Shallow Copy, Deep Copy in Java:
-------------------------------------

 // While using equals() we get confused, to clear all in depth, you must the the concept of shallow copy and Deep copy.

 - Shallow Copy :
	When we do a copy of some entity to create two or more than two entities such that changes in one entity are reflected in 
	the other entities as well, then we can say we have done a shallow copy. In shallow copy, new memory allocation never 
	happens for the other entities, and the only reference is copied to the other entities.
	We will get the same result, when we assign one reference variable to other of same type.

	Sample ob1=new Sample(100); ------|
					  |--- In both cases the reference variables ob1 and ob2 pointing towards same location.
	Sample ob2=ob1; ------------------|    and changing value of one will be reflected in other, so it is Shallow copy.


 - Deep Copy:
	When we do a copy of some entity to create two or more than two entities such that changes in one entity are not reflected 
	in the other entities, then we can say we have done a deep copy. In the deep copy, a new memory allocation happens for the
	other entities, and reference is not copied to the other entities. Each entity has its own independent reference.

	e.g.
	Test t=new Test(10);  --|
			        |---- In both cases the reference variables t and ob are not pointing towards same location.
	Test ob= new Test(10) --|     and changing value of one will not be reflected in other, so it is deep copy.

 - Lazy Copy: 
	A lazy copy can be defined as a combination of both shallow copy and deep copy. At start it is a shallow copy but when
	needed individual exesistence is created.
	
	e.g. when we declare 1st array. and if we declare another array with same values and same size the initially, shallow copy 
	     is created(both references refering towards same location), and when you modify the value of any 1 location from any
	     array they will gains individual exsistence in the memory.(deep copy) and therefore it is known as Lazy copies.


import java.util.Arrays;
class Sample 
{
	private int num;
	public Sample()
	{
		num=1;
	}
	public Sample(int num)
	{
		this.num=num;
	}
	public void set(int num)
	{
		this.num=num;
	}
	public void show()
	{
		System.out.println("value of num: "+num);
	}
}
class ShallowExample
{
	public static void main(String []args)
	{
		// shallow copies
		Sample ob1=new Sample();
		Sample ob2=ob1;
		ob1.set(1000);
		ob2.show();		
		System.out.println("ob1 equals ob2: "+ob1.equals(ob2));
		System.out.println("------------------------------------------");
		// As the change in ob1 is reflected in ob2 these are shallow copies.		
		//---------------------------

		// deep copies
		Sample s1=new Sample(100);	
		Sample s2=new Sample(100);
		System.out.println("s1 equals s2: "+s1.equals(s2));
		s1.set(45);
		s1.show();
		s2.show();
		System.out.println("s1 equals s2: "+s1.equals(s2));
		System.out.println("------------------------------------------");
	
		// In this case both s1 and s2 are deep copies, coz change in s1 will
		// not be reflected in s2.
		//---------------------------

		// Lazy copies
		int []x={11,22,33,44};
		int []y={11,22,33,44};
		
		System.out.println("After value insert x array is: "+Arrays.toString(x));
		System.out.println("x equals y: "+Arrays.equals(x,y));

		y[2]=100;
		System.out.println("x equals y: "+Arrays.equals(x,y));
		// in the initial state both are refering towards same location (as equals()
		// gives true) so it is shallow copy initially. but when we modify one array
		// i.e. the change in y is not reflected in x these are not shallow copy, 
		// and after change equals gives false, means afterwards it will changed to
		// deep copy. and therefore it is known as Lazy copies.
	}
}

//-------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------
   -  String in java 

1. What is a String in Java?
In Java, a String is an object that represents a sequence of characters. It is defined in the java.lang package 
and is one of the most commonly used classes.
Example:
String name = "Java";
Even though it looks like a primitive, String is actually a class in Java, and "Java" is an object of that class

-----------

 2. How are Strings stored in Java memory?
Strings are stored in a special memory area called the String Constant Pool (SCP) inside the Heap memory.

There are two ways to create a String:

a) Using String Literal:
String s1 = "Hello";
This goes into the String pool. If a String with the same content already exists, the new variable refers to the existing object.

b) Using new keyword:
String s2 = new String("Hello");
This creates a new object in the Heap memory, even if an object with the same value already exists in the pool.

----------
 3. Why are Strings immutable in Java?

Strings in Java are immutable—once created, they cannot be changed. Here's why:
Security: Strings are used in sensitive areas like file paths, URLs, and database connections. If mutable, it can be changed easily.
Hashing: Strings are used as keys in hash-based collections (HashMap, HashSet). If strings were mutable, their hashCode would change, breaking the hashing structure.
Performance: String pool optimization is possible only if strings are immutable.
Thread safety: Immutability automatically makes strings thread-safe.

---------------

4. What is the difference between String, StringBuilder, and StringBuffer?

Feature	        String (Immutable)	          StringBuilder (Mutable)	     StringBuffer (Mutable & Thread-safe)
Mutability	Immutable	                  Mutable	                      Mutable
Thread Safety	Not thread-safe	                  Not thread-safe	              Thread-safe (synchronized methods)
Performance	Slower for modifications	  Fastest for single-threaded	      Slower due to synchronization
Use Case	Fixed values, keys	          Efficient string manipulation	      Multi-threaded string manipulation


🔹 StringBuilder – Fast & Efficient (Non-Thread-Safe)
           - Introduced in Java 5.
           - Mutable, meaning the object’s content can be changed without creating a new one.
           - Not synchronized, so it's faster but not thread-safe.

🧪 Example:

StringBuilder sb = new StringBuilder("Hello");
sb.append(" World");
System.out.println(sb);  // Output: Hello World

✅ Best for: Single-threaded environments (e.g., most basic apps, desktop tools).

🔹 StringBuffer – Thread-Safe Version           
           - Available since early Java versions.
           - Also mutable, like StringBuilder.
           - Synchronized, meaning it is safe for multi-threaded programs, but slower.

🧪 Example:

StringBuffer sb = new StringBuffer("Hello");
sb.append(" World");
System.out.println(sb);  // Output: Hello World
✅ Best for: Multi-threaded environments (e.g., servers, concurrent applications).



-----------------

5. How does Java manage memory for String literals and String objects?
Java uses a String Constant Pool to optimize memory:

When you create a string using a literal, the JVM checks the pool:
If the value already exists, it reuses the reference.
If not, it creates a new object in the pool.

When using new String("Java"), a new object is created in the heap, even if "Java" exists in the pool.

Example:
String s1 = "Java";            // Reuses or adds to the pool
String s2 = new String("Java"); // Creates a new object in heap

-----------------
🔹 6. What is the String Constant Pool in Java?

The String Constant Pool (also called String Pool) is a special memory area inside the heap where Java stores String literals.
✅ Key points:
When a String is created using a literal, like:
String s1 = "Java";

the JVM checks the pool first:
If the string already exists, it reuses the reference.
If not, it creates a new object in the pool.
This helps in memory optimization because multiple variables can point to the same immutable string object.

🔁 Example:

String s1 = "Hello";
String s2 = "Hello";  // Points to the same object as s1
System.out.println(s1 == s2); // true


----------------------

 7. What happens when you concatenate strings using + in a loop? Why is it not efficient?
            When you use the + operator to concatenate strings in a loop, Java creates a new String object
            every time because Strings are immutable.

This is highly inefficient for large or frequent operations.

🧪 Example:
String result = "";
for (int i = 0; i < 5; i++) {
    result += i;  // Creates a new string object every time
}

🔴 Why inefficient?
        - Every time you use +, Java creates a new String, copies the old contents, and appends the new part.
        - This leads to high memory usage and slow performance.

✅ Better approach: Use StringBuilder for concatenation in loops:

StringBuilder sb = new StringBuilder();
for (int i = 0; i < 5; i++) {
    sb.append(i);
}
String result = sb.toString();

---------------------------

🔹 8. What is intern() method in Java?
            The intern() method is used to store or get a string from the String constant pool.
🔁 Syntax:
String s = new String("Hello");
String interned = s.intern();

✅ What it does:
    - If the string is already in the pool, intern() returns a reference to the pooled object.
    - If not, it adds it to the pool and then returns that reference.

🧪 Example:
String a = new String("Java");
String b = "Java";

System.out.println(a == b);            // false
System.out.println(a.intern() == b);   // true

🔍 Use intern() to save memory when you expect a lot of repeated strings.

----------------

🔹 2. What is the difference between == and .equals() when comparing Strings?

Comparison	        ==	                            .equals()
Compares	Reference (memory address)	            Content (value inside the object)
Returns	        true if both refer to same object	    true if content is same
Use case	When identity is important	            When equality of values is needed

Example:

String a = "Java";
String b = new String("Java");

System.out.println(a == b);       // false (different objects)
System.out.println(a.equals(b));  // true (same content)


---------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------

java.lang.String
-------------------

	The String is a class from java.lang package, used to repesent the character array in its equivalent object form.
	By default every string represented within "<>" considered as a string object. Once the String is created we are 
	unable to modify the contents. means the string object is immutable.	


	Constructors:
	- public String(): Constructs a new empty String.
	- public String(byte[] bytes): Constructs a new String by decoding the specified array of bytes using the 
		platform's default charset.
	- public String(byte[] bytes, Charset charset): Constructs a new String by decoding the specified array 
		of bytes using the specified charset.
	- public String(byte[] bytes, int offset, int length): Constructs a new String by decoding the specified subarray 
		of bytes using the platform's default charset.
	- public String(byte[] bytes, int offset, int length, Charset charset): Constructs a new String by decoding the 
		specified subarray of bytes using the specified charset.
	- public String(char[] value): Allocates a new String so that it represents the sequence of characters currently 
		contained in the character array argument.
	- public String(char[] value, int offset, int count): Allocates a new String that contains characters from a subarray 
		of the character array argument.
	- String(String original): Initializes a newly created String object so that it represents the same sequence of 
		characters as the argument; in other words, the newly created string is a copy of the argument string.
	- String(StringBuffer buffer): Allocates a new string that contains the sequence of characters currently contained 
		in the string buffer argument.
	- String(StringBuilder builder): Allocates a new string that contains the sequence of characters currently contained 
		in the string builder argument.

	Methods:

	Length and Character Access:
	- int length(): Returns the length of this string.
	- char charAt(int index): Returns the char value at the specified index.
	- boolean isEmpty(): Returns true if, and only if, length() is 0.

	Substring Extraction:
	- String substring(int beginIndex): Returns a new string that is a substring of this string.
	- String substring(int beginIndex, int endIndex): Returns a new string that is a substring of this string.

	Concatenation:
	- String concat(String str): Concatenates the specified string to the end of this string.
	- String join(CharSequence delimiter, CharSequence... elements): Returns a new string composed of the elements 
		joined together with the specified delimiter.

	Search and Replace:
	- boolean contains(CharSequence s): Returns true if and only if this string contains the specified sequence of 
		char values.
	- boolean startsWith(String prefix): Tests if this string starts with the specified prefix.
	- boolean endsWith(String suffix): Tests if this string ends with the specified suffix.
	- int indexOf(int ch): Returns the index within this string of the first occurrence of the specified character.
	- int indexOf(String str): Returns the index within this string of the first occurrence of the specified substring.
	- int lastIndexOf(int ch): Returns the index within this string of the last occurrence of the specified character.
	- int lastIndexOf(String str): Returns the index within this string of the last occurrence of the specified substring.
	- String replace(char oldChar, char newChar): Returns a new string resulting from replacing all occurrences of oldChar
		in this  string with newChar.
	- String replace(CharSequence target, CharSequence replacement): Replaces each substring of this string that matches 
		the literal target sequence with the specified literal replacement sequence.

	Modification Operations:
	- String toLowerCase(): Converts all of the characters in this String to lowercase.
	- String toUpperCase(): Converts all of the characters in this String to uppercase.
	- String trim(): Returns a copy of the string, with leading and trailing whitespace omitted.

	Comparison Operations:
	- boolean equals(Object anObject): Compares this string to the specified object.
	- boolean equalsIgnoreCase(String anotherString): Compares this String to another String, ignoring case considerations.
	- int compareTo(String anotherString): Compares two strings lexicographically.

	Regular Expression Matching:
	- boolean matches(String regex): Tells whether or not this string matches the given regular expression.
	- String[] split(String regex): Splits this string around matches of the given regular expression.

	String Conversion:
	- byte[] getBytes(): Encodes this String into a sequence of bytes using the platform's default charset.
	- byte[] getBytes(Charset charset): Encodes this String into a sequence of bytes using the given charset.
	- char[] toCharArray(): Converts this string to a new character array.




///////////////////////////////////////////////////////////////////////////////////////////////////////////////

   **********  Video  *********


 **********  java.lang.String  class
- Immutable
- Thread safe
- performance-Slow(due to immutable)
- Storage-String pool(For literals)



Public class Test{
     public static void main(String []args)
	{
 	    String s1 = "Hello"; 
             String s2 = s1.concat(World);
             System.out.println(s2);

   }

}

This will create a temperry string which leads to poor performance so StringBuilder and StringBuffer are introduced which are
 mutable without creating new object.

----------------------------

 **********  java.lang.StringBuilder : Modify the object directly. and allow method Channing. 

- Mutable 
- Method Chaining (Because it return reference)
- it is not thread safe because of it is mutable so use StingBuffer
- Fast (No synchronization)
- Storage(Heap)

Internal Woking:

        - StringBuilder consists of char Array( default capacity = 16). if we append elements then it will be add in char array and if 
        array is full it will double the size of array and new char array will be created of double the size and old elements are put into new array


Public class Test{
     public static void main(String []args)
	{
 	    String s1 = "Hello"; 
             
          StringBuilder sb = new StringBuilder("Hello"); 

            sb.append("World").append("India");  //method Chaning

            string str = sb.toString();  // obj creation which is immutable

             System.out.println(atr);

   }

}

    *******  StingBuffer
- Mutable 
- Thread safe
- performance- slow due to synchronization
- Storage-heap



///////////////////////////////////////////////////////////////////////////////////////////////////////////////



	// Creating the strings

class StringExample
{
	public static void main(String []args)
	{
		String s1="hello", s2="hello", s3="good day";

		// Note that eventhough java doesnot allow operator overloading, the + operator internally overloaded
		// to join two or more strings.

		String s="i said: "+s2+" to you,"+s3+" was the second statement";
		System.out.println("The s is: "+s);
	}
}
//----------------------------------------------------------------

// Using String class Constructors

class StringExample1
{
	public static void main(String []args)
	{
		// creating the using direct assignment
		String s1="hello", s2="hello", s3="good day";

		// Note that eventhough java doesnot allow operator overloading, the + operator internally overloaded
		// to join two or more strings.
		String s="i said: "+s2+" to you,"+s3+" was the second statement";
		System.out.println("The s is: "+s);
		//------------------------
		boolean b=s1.equals(s2);
		System.out.println("s1 equals s2 is: "+b);
		b=s1.equals(s3);
		System.out.println("s1 equals s3 is: "+b);
		// when two same string literals are used to create the string objects
		// then it wil creates the shallow copies.
		//-----------------------------
		int len="good day".length();
		System.out.println("length is: "+len);
		// which will proves the string literal are objects.

		String str1=new String();
		System.out.println("str1 is: "+str1);
		//------------------------------------------------
		byte []bvals={65,66,67,68,69,70,71,72};
		String str2=new String(bvals);
		System.out.println("str2 is: "+str2);

		String str3=new String(bvals,2,5); // starting from pos 2(including), and 5 character after it
		System.out.println("str2 is: "+str3);
		//----------------------------------------------
		char []ch={'h','o','w',' ','a','r','e',' ','y','o','u'};
		String str4=new String(ch);
		System.out.println("str4 is: "+str4);

		String str5=new String(s3);
		System.out.println("str5 is: "+str5);
	}
}

//-----------------------------------------------------------------------------------------------

	// Using charAt() and length()

class StringExample1 
{
	public static void main(String[] args) 
	{
		String s1="hello good day";
		int len=s1.length();
		System.out.println("length of s1: "+len);

		String s2="";
		System.out.println("length of s2: "+s2.length());

	//	String s3; // error: variable s3 might not have been initialized
	//	System.out.println("length of s3: "+s3.length());

		// using charAt()
		System.out.print("String s1 is: ");
		for(int i=0 ; i<s1.length();i++)
		{
			System.out.println(s1.charAt(i));
		}
		System.out.println();
	}
}
//---------------------------------------------------------------------

	// using some other methods

import java.util.Arrays;
class StringExample2 
{
	public static void main(String[] args) 
	{
		String s1="hello good day to all";

		String s2=s1.substring(2);
		System.out.println("s2: "+s2);

		String s3=s1.substring(6, 13);
		System.out.println("s3: "+s3);

		String s4=s1.concat(" All the best");
		System.out.println("s4: "+s4);

		
		System.out.println("All the best".contains("e"));
		System.out.println(s1.contains("ll"));

		
		System.out.println("----------------------------------------------");
		System.out.println("All the best".startsWith("e"));
		System.out.println("All the best".startsWith("A"));
		System.out.println("All the best".startsWith("All"));

		System.out.println(s1.endsWith("l"));
		System.out.println(s1.endsWith("all"));
		System.out.println(s1.endsWith("to"));

		
		System.out.println("----------------------------------------------");
		System.out.println(s1.indexOf("o"));
		System.out.println(s1.lastIndexOf("o"));
		System.out.println(s1.indexOf("ll"));
		System.out.println(s1.lastIndexOf("ll"));

		System.out.println("----------------------------------------------");
		String s5=s1.replace('o','#');
		System.out.println("s5: "+s5);
		s5=s1.replace("ll","LL");
		System.out.println("s5: "+s5);
		
		System.out.println("----------------------------------------------");
		String s6=s1.toUpperCase();
		System.out.println("s6: "+s6);
		System.out.println("How ARE yoU".toLowerCase());
		String s7="      java programming      ";
		System.out.println("Length of String: "+s7.length());
		s7=s7.trim();		
		System.out.println("Length of String: "+s7.length());

		System.out.println("----------------------------------------------");
		String s8="good";
		String s9="good";
		String s10="day";
		System.out.println("s8 equals s9: "+s8.equals(s9));
		System.out.println("s8 equals s10: "+s8.equals(s10));
		System.out.println("s8 Compare to s9: "+s8.compareTo(s9));
		System.out.println("s8 Compare to s10: "+s8.compareTo(s10));

		System.out.println("----------------------------------------------");
		byte []b=s1.getBytes();
		System.out.println("bytes of s1: "+Arrays.toString(b));

	}
}

//------------------------------------------------------------------------------------------------------//------------------------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------------------

java.lang.StringBuffer
-----------------------
	A thread-safe, mutable sequence of characters. A string buffer is like a String, but can be modified. At any point in 
	time it contains some particular sequence of characters, but the length and content of the sequence can be changed 
	through certain method calls.

	The principal operations on a StringBuffer are the append and insert methods, which are overloaded so as to accept 
	data of any type.

	Constructors:
	- public StringBuffer(): Constructs an empty StringBuffer with the initial capacity of 16 characters.
	- public StringBuffer(int capacity): Constructs an empty StringBuffer with the specified initial capacity.
	- public StringBuffer(String str): Constructs a StringBuffer with the specified initial value.

	Methods:

	Append Operations:
	- StringBuffer append(Object obj): Appends the string representation of the specified object to this StringBuffer.
	- StringBuffer append(String str): Appends the specified string to this StringBuffer.
	- StringBuffer append(StringBuffer sb): Appends the specified StringBuffer to this StringBuffer.
	- StringBuffer append(CharSequence s): Appends the specified character sequence to this StringBuffer.
	- StringBuffer append(CharSequence s, int start, int end): Appends a subsequence of the specified character sequence 
		to this StringBuffer.
	- StringBuffer append(char[] str): Appends the string representation of the specified character array to this StringBuffer.
	- StringBuffer append(char[] str, int offset, int len): Appends a subarray of the specified character array to 
		this StringBuffer.
	- StringBuffer append(boolean b): Appends the string representation of the specified boolean value to this StringBuffer.
	- StringBuffer append(char c): Appends the specified character to this StringBuffer.
	- StringBuffer append(int i): Appends the string representation of the specified integer to this StringBuffer.
	- StringBuffer append(long lng): Appends the string representation of the specified long to this StringBuffer.
	- StringBuffer append(float f): Appends the string representation of the specified float to this StringBuffer.
	- StringBuffer append(double d): Appends the string representation of the specified double to this StringBuffer.

	Insert Operations:
	- StringBuffer insert(int offset, Object obj): Inserts the string representation of the specified object into 
		this StringBuffer.
	- StringBuffer insert(int offset, String str): Inserts the specified string into this StringBuffer.
	- StringBuffer insert(int offset, char[] str): Inserts the string representation of the specified character array 
		into this StringBuffer.
	- StringBuffer insert(int offset, CharSequence s): Inserts the specified character sequence into this StringBuffer.
	- StringBuffer insert(int offset, CharSequence s, int start, int end): Inserts a subsequence of the specified 
		character sequence into this StringBuffer.
	- StringBuffer insert(int offset, boolean b): Inserts the string representation of the specified boolean value 
		into this StringBuffer.
	- StringBuffer insert(int offset, char c): Inserts the specified character into this StringBuffer.
	- StringBuffer insert(int offset, int i): Inserts the string representation of the specified integer into this StringBuffer.
	- StringBuffer insert(int offset, long l): Inserts the string representation of the specified long into this StringBuffer.
	- StringBuffer insert(int offset, float f): Inserts the string representation of the specified float into this StringBuffer.
	- StringBuffer insert(int offset, double d): Inserts the string representation of the specified double into this StringBuffer.

	Other Operations:
	- void setLength(int newLength): Sets the length of this StringBuffer.
	- int capacity(): Returns the current capacity of this StringBuffer.
	- void ensureCapacity(int minimumCapacity): Ensures that the capacity of the buffer is at least equal to the 
		specified minimum capacity.
	- void trimToSize(): Attempts to reduce storage used for the character sequence.

	String Conversion:
	- char charAt(int index): Returns the character at the specified index.
	- int length(): Returns the length (character count) of this StringBuffer.
	- String substring(int start): Returns a new String that contains a subsequence of characters currently contained 
		in this StringBuffer.
	- String substring(int start, int end): Returns a new String that contains a subsequence of characters currently 
		contained in this StringBuffer.

	Modification Operations:
	- void setCharAt(int index, char ch): Sets the character at the specified index to the specified character.
	- StringBuffer	deleteCharAt(int index): Removes the char at the specified position in this sequence.
	- StringBuffer	delete(int start, int end): Removes the characters in a substring of this sequence.
	- StringBuffer replace(int start, int end, String str): Replaces the characters in a substring of this sequence 
		with characters in the specified String.
	- StringBuffer reverse(): Causes this character sequence to be replaced by the reverse of the sequence.	
	- void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin): Copies characters from this sequence into the 
		destination character array.

//-------------------------------------------------------------------------------------------------------------------------------

	// Using StringBuffer constructors and capacity() 

class StringBufferExample1 
{
	public static void main(String[] args) 
	{
		StringBuffer s1=new StringBuffer();
		System.out.println("Capacity of s1: "+s1.capacity());

		StringBuffer s2=new StringBuffer(5);
		System.out.println("Capacity of s2: "+s2.capacity());

		s1.append("hello all, how are you");
		System.out.println("Capacity of s1: "+s1.capacity());

		StringBuffer s3=new StringBuffer("hello");
		System.out.println("Data of S3: "+s3);
		System.out.println("Capacity of s3: "+s3.capacity());
	}
}


class StringBufferExample1 
{
	public static void main(String[] args) 
	{
		StringBuffer s=new StringBuffer("hello");
		System.out.println("Data of S: "+s);

		s.append(" How are you");
		System.out.println("Data of S: "+s);

		String str=" all";
		s.append(str);
		System.out.println("Data of S: "+s);

		StringBuffer sb=new StringBuffer(" of you ");
		s.append(sb);
		System.out.println("Data of S: "+s);

		char []ch={'a','l','l',' ','t','h','e',' ','b','e','s','t'};
		s.append(ch);
		System.out.println("Data of S: "+s);
		s.append(ch,7,5);
		System.out.println("Data of S: "+s);
		s.append('A');
		System.out.println("Data of S: "+s);
		s.append(123);
		System.out.println("Data of S: "+s);

		//-------------------------------------------------

		s.insert(37,"All the ");
		System.out.println("Data of S: "+s);
		s.setCharAt(0,'H');
		s.setCharAt(10,'A');
		System.out.println("Data of S: "+s);
		System.out.println("default Capacity of s: "+s.capacity());
		s.trimToSize();
		System.out.println("After trim - Capacity of s: "+s.capacity());
		System.out.println("Data of S: "+s);

		s.setLength(40);
		System.out.println("Data of S: "+s);
		s.setLength(75);
		System.out.println("Data of S: "+s);
		System.out.println("Now Capacity of s: "+s.capacity());
		s.trimToSize();
		System.out.println("Now After trim - Capacity of s: "+s.capacity());

		StringBuffer s1=s.delete(6,18);
		System.out.println("Data of S1: "+s1);

		char []c=new char[100];
		s.getChars(2,10,c,0);
		String t=new String(c);
		System.out.println("gained characters: "+t);

		StringBuffer src=new StringBuffer("How are you");
		StringBuffer s2=src.replace(9,11,"All of you?");
		System.out.println("String src: "+src);
		System.out.println("String s2: "+s2);
		
		StringBuffer s3=src.reverse();
		System.out.println("String s3: "+s3);

	}
}
//----------------------------------------------------------
class StringBufferExample
{
  public static void main(String[] args)
  {
    // create a string buffer
    StringBuffer str = new StringBuffer();

    // add string to string buffer
    str.append("Java");
    str.append(" is");
    str.append(" popular.");
    System.out.println("StringBuffer: " + str);

    // clear the string
    // using delete()
    str.delete(0, str.length());
    System.out.println("Updated StringBuffer: " + str);
  }
}

//-----------------------------------------------------------------------------------------------


public class StringBufferDemo
{
	public static void main(String args[])
	{
		StringBuffer sBuffer1=new StringBuffer("Welcome");
		System.out.println("Original String is ::: " + sBuffer1 + ":: having length " + sBuffer1.length());
		//using append method
		sBuffer1.append(" To Edubca");
		System.out.println("Modified String after append is :: " + sBuffer1 + " :: having length " + sBuffer1.length());
		//using reverse method
		sBuffer1.reverse();
		System.out.println("Modified String after Reverse is :: " + sBuffer1);
	}
}
//-----------------------------------------------------------------
public class StringBufferDemo
{
	public static void main(String args[])
	{
		StringBuffer sBuffer=new StringBuffer ("WelcomeToJava");
		System.out.println("Original String is ::: " + sBuffer + ":: having length " + sBuffer.length());
		//using replace method
		sBuffer.replace(0,9,"This is ");
		System.out.println("Modified String after replace is :: " + sBuffer + " :: having length " + sBuffer.length());
		//using delete method
		sBuffer.delete(0,7);
		System.out.println("Modified String after delete is :: " + sBuffer);
	}
}
//---------------------------------------------------------------------------------------------------------------------------

java.lang.StringBuilder 
-------------------------
	A mutable sequence of characters. This class provides an API compatible with StringBuffer, but with no guarantee of
	synchronization. This class is designed for use as a drop-in replacement for StringBuffer in places where the string 
	buffer was being used by a single thread (as is generally the case). Where possible, it is recommended that this class 
	be used in preference to StringBuffer as it will be faster under most implementations.

	The principal operations on a StringBuilder are the append and insert methods, which are overloaded so as to accept 
	data of any type. Instances of StringBuilder are not safe for use by multiple threads. If such synchronization is 
	required then it is recommended that StringBuffer be used.

	Constructors:
	- public StringBuilder(): Constructs an empty StringBuilder with a default initial capacity.
	- public StringBuilder(int capacity): Constructs a StringBuilder with the specified initial capacity.
	- public StringBuilder(CharSequence seq): Constructs a StringBuilder that contains the same characters as the 
		specified CharSequence.
	- public StringBuilder(String str): Constructs a StringBuilder initialized to the contents of the specified string.

	Methods:
	Append Operations:
	- StringBuilder append(boolean b): Appends the string representation of the specified boolean value.
	- StringBuilder append(char c): Appends the specified character.
	- StringBuilder append(char[] str): Appends the string representation of the specified character array.
	- StringBuilder append(char[] str, int offset, int len): Appends a subarray of the specified character array.
	- StringBuilder append(CharSequence s): Appends the specified character sequence.
	- StringBuilder append(CharSequence s, int start, int end): Appends a subsequence of the specified character sequence.
	- StringBuilder append(double d): Appends the string representation of the specified double value.
	- StringBuilder append(float f): Appends the string representation of the specified float value.
	- StringBuilder append(int i): Appends the string representation of the specified integer value.
	- StringBuilder append(long l): Appends the string representation of the specified long value.
	- StringBuilder append(Object obj): Appends the string representation of the specified object.

	Insert Operations:
	- StringBuilder insert(int offset, boolean b): Inserts the string representation of the specified boolean value.
	- StringBuilder insert(int offset, char c): Inserts the specified character.
	- StringBuilder insert(int offset, char[] str): Inserts the string representation of the specified character array.
	- StringBuilder insert(int offset, char[] str, int offset, int len): Inserts a subarray of the specified character array.
	- StringBuilder insert(int offset, CharSequence s): Inserts the specified character sequence.
	- StringBuilder insert(int offset, CharSequence s, int start, int end): Inserts a subsequence of the specified 
		character sequence.
	- StringBuilder insert(int offset, double d): Inserts the string representation of the specified double value.
	- StringBuilder insert(int offset, float f): Inserts the string representation of the specified float value.
	- StringBuilder insert(int offset, int i): Inserts the string representation of the specified integer value.
	- StringBuilder insert(int offset, long l): Inserts the string representation of the specified long value.
	- StringBuilder insert(int offset, Object obj): Inserts the string representation of the specified object.

	String Conversion:
	- int length(): Returns the length (character count) of the sequence of characters currently in the StringBuilder.
	- StringBuilder setLength(int newLength): Sets the length of the character sequence.
	- String toString(): Returns a string representing the data in this StringBuilder.

	Modification Operations:
	- void setCharAt(int index, char ch): Sets the character at the specified index to the specified character.

	Other Operations:
	- void ensureCapacity(int minimumCapacity): Ensures that the capacity is at least equal to the specified minimum.
	- int capacity(): Returns the current capacity of the StringBuilder.


public class StringBuilderDemo 
{
    public static void main(String[] args) 
    {
        // Create a StringBuilder object
        StringBuilder sb = new StringBuilder("Hello");

        // Append text
        sb.append(" World");
        System.out.println("After appending: " + sb);

        // Insert text at a specific position
        sb.insert(5, ", ");
        System.out.println("After inserting: " + sb);

        // Delete characters
        sb.delete(5, 8);
        System.out.println("After deleting: " + sb);

        // Reverse the StringBuilder
        sb.reverse();
        System.out.println("After reversing: " + sb);

        // Get the length of the StringBuilder
        System.out.println("Length of StringBuilder: " + sb.length());

        // Get capacity of the StringBuilder
        System.out.println("Capacity of StringBuilder: " + sb.capacity());

        // Replace text
        sb.replace(0, 5, "Hey");
        System.out.println("After replacing: " + sb);

        // Set length of the StringBuilder
        sb.setLength(3);
        System.out.println("After setting length: " + sb);

        // Convert StringBuilder to String
        String str = sb.toString();
        System.out.println("Converted to String: " + str);
    }
}

//--------------------------------------------------------------------------------------------------------------
//--------------------------------------------------------------------------------------------------------------
//--------------------------------------------------------------------------------------------------------------

	// Functional Interface in Java

	A Functional Interface in Java is an interface that contains exactly one abstract method. 
	These interfaces are essential for using lambda expressions and functional programming concepts 
	introduced in Java 8.


	1. What is a Functional Interface?
	A functional interface is an interface that has only one abstract method but can have multiple 
	default or static methods.

	It is primarily used for defining a target type for lambda expressions.
	Java provides a special annotation @FunctionalInterface to enforce this constraint at compile time.


	@FunctionalInterface
	interface MyFunctionalInterface {
    		void doSomething();  // Only one abstract method
	}


	2. Why Functional Interfaces?
	Functional interfaces allow us to write concise, readable, and efficient code by leveraging 
	lambda expressions instead of anonymous classes.

	// Initially 

interface MyInterface {
   	void show();
}

class Demo implements MyInterface {		
	public void show() {
		System.out.println("Hello, class implementing Interface!");
	}
}
public class TestFI {
	public static void main(String[] args) {		
		Demo ob = new Demo();		
		ob.show();
	}
}


//----------------------------------------------------------------------------------------

	Before Java 8 (Using Anonymous Classes):

interface MyInterface {
   void show();
}

public class TestFI {
	public static void main(String[] args) {		
		MyInterface ob = new MyInterface(){ // Anonymous Class	
			public void show() {
				System.out.println("Hello, Anonymous class implementing Interface!");
			}
		};
		ob.show();
	}
}


Can be further modified using functions interface as

	- remove Anonymous Class implementation, i.e. new <interface_name()> 
	- {} of class implemntation
	- As it is functional interface, there is only one method to call, 
  	  so remove the <visibility> <ret_type> <method_name>, keep() add -> after it 
	  and keep {} of method with method body

interface MyInterface {
   	void show();
}
public class TestFI {
	public static void main(String[] args) {		
		MyInterface ob = () -> {
				System.out.println("Hello, Anonymous class implementing Interface!");
			}
		;
		ob.show();
	}
}

 // again remove {} of method body, and ; after the instruction. Then 

interface MyInterface {
   	void show();
}
public class TestFI {
	public static void main(String[] args) {		
		MyInterface ob = () -> System.out.println("Hello, Anonymous class implementing Interface!");
		ob.show();
	}
}

//-----------------------------------------------------------------------------------------

	// With arguments

interface AddOperation
{
	void add(int a, int b); // must write variable name, name a and b can be changed in impl.
}
class DemoFIwithArguments
{
	public static void main(String[] args) 
	{
		AddOperation ob = (int x, int y) -> System.out.println("Addition: "+ (x+y) );
		ob.add(10,20);
	}
}

//----------

	In the expression, AddOperation ob = (int x, int y) -> System.out.println("Addition: "+ (x+y) );
		in (int x, int y), only int is a option and as functional interface, only one is there.
	so presence of data types become optional.

lets rewrite,

interface AddOperation
{
	void add(int a,int b); // must write variable name, name a and b can be changed in impl.
}
class DemoFIwithArguments
{
	public static void main(String[] args) 
	{
		AddOperation ob = (x,y) -> System.out.println("Addition: "+ (x+y) );
		ob.add(10,20);
	}
}

//-----------------------------------------------------------------------------------------

	// with return


interface MathCube
{
	int getCube(int no);
}
class DemoFiWithReturn
{
	public static void main(String[] args) 
	{
		MathCube ob = (n) ->  n*n*n; // return statement taken as per the function prototype from interface
		int ans = ob.getCube(3);

		System.out.println("Answer is: "+ans);
	}
}
//---------------------------------------------------------------------

	// Multiple Statements in Lambda Expression

	when implementing a Functional Interface using a lambda expression, you can include multiple 
	statements in the function body by enclosing them within curly braces {}.

interface PrimeCalculator
{
	void isPrime(int no);
}
class DemoFIWithMultiState
{
	public static void main(String[] args) 
	{
		PrimeCalculator ob = (n) -> {
			
			int d=2, flg=0;
			while(d<=(n/2)){
				if(n%d==0){
					flg=1;
					break;
				}
				d++;
			}
			if(flg==1)
				System.out.println("Number is not prime");
			else 				
				System.out.println("Number is prime");
		};

		ob.isPrime(5);
	}
}
//-----------------------------------
// Same Program with return

@FunctionalInterface  // ----> generates the compiletime error when two or more abstract methods are there.
interface PrimeCalculator
{
	boolean isPrime(int no);
}
class DemoFIWithMultiState
{
	public static void main(String[] args) 
	{
		PrimeCalculator ob = (n) -> {
			
			int d=2;
			boolean flg=true;

			while(d<=(n/2)){
				if(n%d==0){
					flg=false;
					break;
				}
				d++;
			}
			return flg;
		};

		if(ob.isPrime(51))
			System.out.println("Number is prime");
		else 				
			System.out.println("Number is not prime");
	}
}

//--------------------------------------------------------------

	Advantages of Functional Interfaces:

	✔️ Less Boilerplate Code
	✔️ Improved Readability
	✔️ Efficient Execution


//---------------------------------------------------------------------

Introduction to java.util.function Package in Java

	The java.util.function package was introduced in Java 8 as part of the functional 
	programming paradigm. It provides a set of built-in functional interfaces that help in 
	writing cleaner and more readable lambda expressions and method references.


	Built-in Functional Interfaces (java.util.function Package)

	java.util.function
	│
	├── Function<T, R>
	│   ├── UnaryOperator<T> (extends Function<T, T>)
	│
	├── BiFunction<T, U, R>
	│   ├── BinaryOperator<T> (extends BiFunction<T, T, T>)
	│
	├── Predicate<T>
	│   └── BiPredicate<T, U>
	│
	├── Consumer<T>
	│   └── BiConsumer<T, U>
	│
	├── Supplier<T>
	│
	├── Operator Interfaces
	│   ├── UnaryOperator<T> (extends Function<T, T>)
	│   └── BinaryOperator<T> (extends BiFunction<T, T, T>)
	│
	└── Specialized Variants for Primitives
	    ├── IntFunction<R>, LongFunction<R>, DoubleFunction<R>
	    ├── IntPredicate, LongPredicate, DoublePredicate
	    ├── IntConsumer, LongConsumer, DoubleConsumer
	    ├── IntSupplier, LongSupplier, DoubleSupplier
	    ├── IntUnaryOperator, LongUnaryOperator, DoubleUnaryOperator
	    └── IntBinaryOperator, LongBinaryOperator, DoubleBinaryOperator



	The package provides several predefined functional interfaces categorized as follows:

	Functional Interface		Method Signature		Description

	Consumer<T>			void accept(T t)	Takes input but does not return a result.
	Supplier<T>			T get()			Takes no input but returns a value.
	Function<T, R>			R apply(T t)		Takes input and returns a result.
	Predicate<T>			boolean test(T t)	Evaluates a condition and returns true or false.
	UnaryOperator<T>		T apply(T t)		A special Function<T, T> where input and output types are the same.
	BinaryOperator<T>		T apply(T t1, T t2)	A special BiFunction<T, T, T> that operates on two inputs of the same type.



	// Using the Consumer: Consumer<T> (T → void)
		Performs an operation on an input without returning a result.

	Example: Printing a Message

import java.util.function.Consumer;
public class ConsumerExample {
    public static void main(String[] args) {
        Consumer<String> printMessage = message -> System.out.println("Message: " + message);
        printMessage.accept("Hello, Java!");
    }
}


	// Example displaying the array elements

import java.util.function.Consumer;
class DemoConsumer
{
	public static void main(String[] args) 
	{
		Integer []ar = {11,22,33,44,55};
		Consumer<Integer> ob = n -> System.out.println(" "+n);

		for(int val : ar)
			ob.accept(val);
	}
}

//----------------------------------------------
	// Passing Integer array

import java.util.function.Consumer;
import java.util.Arrays;
class DemoConsumer
{
	public static void main(String[] args) 
	{
		Integer []ar = {11,22,33,44,55};
		Consumer<Integer[]> ob = n -> System.out.print(" "+Arrays.toString(n));
		ob.accept(ar);
	}
}

//-----------------------------------------------

 // passing int array: 

import java.util.function.Consumer;
import java.util.Arrays;
class DemoConsumer
{
	public static void main(String[] args) 
	{
		int []ar = {11,22,33,44,55};
		Consumer<int[]> ob = n -> System.out.print(" "+Arrays.toString(n));
		ob.accept(ar);
	}
}

//-----------------------------------------------------------------------------------------------------

	// Supplier<T> (() → T): Returns a result without taking any input.

	Example: Generating a Random Number


import java.util.function.Supplier;

public class SupplierExample {
    public static void main(String[] args) {
        Supplier<Double> randomSupplier = () -> Math.random();

        System.out.println("Random Value: " + randomSupplier.get());
    }
}


//-------------------------------------------------------------------------------------------------

	// Function<T, R> (T → R): Takes an input and returns a transformed output.

import java.util.function.Function;
public class FunctionExample {
    public static void main(String[] args) {
        Function<Integer, String> intToString = num -> "Number: " + num;
        System.out.println(intToString.apply(10));
    }
}

//----------------

	// Find length using Function

import java.util.function.Function;
class FindLength
{
	public static void main(String[] args) 
	{
		Function<String, Integer> ob = (s) -> s.length();
		System.out.println(ob.apply("Hello World!"));
	}
}

//--------------------------

	// using the BiFunction<T, U, R>

 you can use the Function interface from the java.util.function package to create a lambda expression. 
However, the Function<T, R> interface takes a single argument of type T and returns a result of type R. 
Since we need to add two numbers, it's more appropriate to use the BiFunction<T, U, R> interface, 
which accepts two arguments.

import java.util.function.BiFunction;

public class AdditionUsingLambda {
    public static void main(String[] args) {
        // Lambda expression to add two numbers
        BiFunction<Integer, Double, Double> add = (a, b) -> a + b;

        // Test the lambda expression
        double result = add.apply(10, 2.5);
        System.out.println("The sum is: " + result);
    }
}


// If there are more than two arguments the Functions will not provide direct class. then use

	- Custom Interface and class
	- Nest the Function and BiFunction
	- Use another data Structures like Map
	- passing custom object

	lets see last option

	// passing custom object: create the custom class to encapsulate all the numbers(arguments) and 
	      			  pass to Function in form of object.

import java.util.function.Function;

class Data {
    int a, b, c;
    Data(int a, int b, int c) {
        this.a = a;
        this.b = b;
        this.c = c;
    }
}

public class FunctionWithWrapper {
    public static void main(String[] args) {
        Function<Data, Integer> sum = data -> data.a + data.b + data.c;
        System.out.println(sum.apply(new Data(5, 10, 15)));  // Output: 30
    }
}


//---------------------------------------------------------------------------------------

	// UnaryOperator and BinaryOperator in java.util.function

	Both UnaryOperator and BinaryOperator are specialized forms of the Function and BiFunction interfaces. 
	They are designed to operate on the same type of operands and return the same type.


	// UnaryOperator<T>: A functional interface that takes one argument and returns a result of the same type.


import java.util.function.Function;
import java.util.function.UnaryOperator;
  
public class UnaryOperatorFunctionExample{
    public static void main(String args[]){
        UnaryOperator<Integer> not = a -> a ^ 1;
        System.out.println(not.apply(0));
    }
}

	// BinaryOperator<T>: A functional interface that takes two arguments of the same type and returns a 
			      result of the same type.


import java.util.function.Function;
import java.util.function.BinaryOperator;
  
public class BinaryOperatorFunctionExample{
    public static void main(String args[]){
        BinaryOperator<Integer> and = (a,b) -> a & b;
        System.out.println(and.apply(13, 3));
    }
}


//-----------------------------------------------------------

  - Predicate<T>:
	The Predicate<T> interface in Java represents a predicate(a statement, action), which is a boolean-valued 
	function of one argument. It's commonly used when you need to test a condition or filter elements based on 
	some criteria.

	public interface Predicate<T>{
    		boolean test(T t)
	}

Example

import java.util.function.Predicate;

public class PredicateExample {
    public static void main(String[] args) {
        // Creating a Predicate to check if a number is even
        Predicate<Integer> isEven = new IsEvenPredicate();

        // Testing the Predicate with some numbers
        System.out.println("Is 4 even? " + isEven.test(4));   // true
        System.out.println("Is 7 even? " + isEven.test(7));   // false
    }
}

class IsEvenPredicate implements Predicate<Integer> {
    public boolean test(Integer number) {
        return number % 2 == 0;
    }
}

	// Same can be written in functional style as, i.e. using lambda expression

import java.util.function.Predicate;
public class PredicateExample {
    public static void main(String[] args) {
        // Creating a Predicate to check if a number is even
        Predicate<Integer> isEven = (number) -> number % 2 == 0;

        // Testing the Predicate with some numbers
        System.out.println("Is 4 even? " + isEven.test(4));   // true
        System.out.println("Is 7 even? " + isEven.test(7));   // false
    }
}

//==============================================================================================================
//================================================================================================================================
//================================================================================================================================

	Java Collection Framework: 
	===========================

	Getting started with Collection Framework: Basically, if you want to represent the bunch of elements as a single unit then 
	the collection is used. 
	
	If we want to store the data in the memory, we have different options. Let’s see
	- If we want to store the single data element then we declare the simple variables, Such as 

		int a=10;	double b=45.3486;
	
	These variables allow you to store the single data element.

	- If we want to store the more elements the array is the perfect choice.

		i.e.  	int []ar=new int[10];

	Array will allow us to store fix number of elements having same type, the elements may of any built-in type or may be of 
	any object type also. Suppose if class Student is defined in the program, the we can use array to store the group of 
	students as 

	Student s=new Student [10];
 
	Where S1, S2, .........S10 are the objects of student class.


	- The problem with is that, array collect the elements having same type together. But what is the option if you want to
	  collect the elements of different type. The option is java is using Object class from Java.  

		i.e.	Object []arr=new Object[5];

	- The problem with array of elements having type Object is
		- It having fix in size, means it is not a growable in nature
		- It will create the data structure which is not with readymade methods.
		- Not Array using Object class but other arrays are homogeneous in nature.

	The solution to all these problems is the collection of classes and interfaces which will provides the internal data 
	structure which will grow and shrink according to need and are with some predefined or readymade methods, 
	known as Java Collection Framework. 

	The Java Collections Framework is a powerful built-in library that provides a unified approach to storing and manipulating
	groups of objects. 

	It offers a variety of benefits for Java programmers:

	- Reduced effort:  The framework provides pre-built implementations of common data structures like ArrayLists, LinkedLists, 
	and HashSets, saving you time and effort compared to writing your own from scratch.

	- Improved performance: The implementations in the Collections Framework are well-optimized for efficiency, ensuring your 
	code runs smoothly.

	- Consistent behavior:  Collections that implement the same interface (like List or Set) share a common set of methods, 
	making it easier to learn and use.

	- Reusability: The framework promotes code reuse by allowing you to work with different collections in a similar way.


          java.lang.Object(C)
            │
          java.lang.Iteriable(I)
            │
            └─ java.util.Collection(I)
               │
               ├─── java.util.List(I)
               │    ├── java.util.ArrayList(C)
               │    ├── java.util.LinkedList(C)
               │    └── java.util.Vector(C)
               │         └── java.util.Stack(C)
               │
               ├─── java.util.Queue(I)
               │    ├── java.util.Deque(I)
               │    │    ├── java.util.ArrayDeque(C)
               │    │    └── java.util.LinkedList(C)
               │    └── java.util.PriorityQueue(C)
               │
               └─── java.util.Set(I)
                    ├── java.util.HashSet(C)
                    │    └── java.util.LinkedHashSet(C)
                    └── java.util.TreeSet(C)
     
               java.util.Map
                    ├── java.util.HashMap(C)
                    │    └── java.util.LinkedHashMap(C)  
             	    ├── java.util.SortedMap(I)
             	    │    └── java.util.TreeMap(C)
          	    ├── java.util.WeakHashMap(C)
                    ├── java.util.HashTable(C)
                    └── java.util.IdentityHashMap(C)



	Description of each class and interface in the Java Collections Framework hierarchy:
	-----------------------------------------------------------------------------------------

	- java.lang.Object (C): The root class for all Java classes. All other classes in Java inherit directly or 
	  indirectly from this class.


	- java.util.Collection (I): The root interface in the collection hierarchy. It represents a group of objects 
	  known as elements.


	- java.util.List (I): An ordered collection that allows duplicate elements.

	- java.util.ArrayList (C): Resizable-array implementation of the List interface. It's a dynamic array that can 
	  grow or shrink as needed.

	- java.util.LinkedList (C): Doubly-linked list implementation of the List interface. It provides sequential 
	  access and efficient insertion/deletion operations.

	- java.util.Vector (C): A legacy class similar to ArrayList but synchronized. It's rarely used in modern Java 
	  development.

	- java.util.Stack (C): A subclass of Vector that represents a last-in, first-out (LIFO) stack of objects.


	
	- java.util.Queue (I): A collection designed for holding elements prior to processing. Queues typically 
	  order elements in a FIFO (first-in-first-out) manner.

	- java.util.Deque (I): A linear collection that supports element insertion and removal at both ends. Stands for 
	  "Double Ended Queue".

	- java.util.ArrayDeque (C): Resizable-array implementation of the Deque interface. It provides more efficient 
	  insertion and removal operations than LinkedList in most cases.

	- java.util.PriorityQueue (C): An unbounded priority queue based on a priority heap. The elements are ordered 
	  according to their natural ordering or by a specified comparator.



	- java.util.Set (I): A collection that contains no duplicate elements.

	- java.util.HashSet (C): Implementation of the Set interface based on a hash table. It does not guarantee the 
	  order of its elements.

	- java.util.LinkedHashSet (C): A hash table and linked list implementation of the Set interface, with predictable 
	  iteration order.

	- java.util.TreeSet (C): A NavigableSet implementation based on a TreeMap. It orders its elements using their 
	  natural ordering or a comparator.



	- java.util.Map (I): An object that maps keys to values. A map cannot contain duplicate keys; each key can map 
	  to at most one value.

	- java.util.HashMap (C): Hash table-based implementation of the Map interface. It provides constant-time 
	  performance for basic operations (add, remove, get) on average.

	- java.util.LinkedHashMap (C): Hash table and linked list implementation of the Map interface. It maintains the 
	  insertion order of elements.

	- java.util.SortedMap (I): A map that maintains its mappings in ascending order, sorted according to the keys 
	  natural ordering or a custom comparator.

	- java.util.TreeMap (C): Red-black tree-based implementation of the SortedMap interface. It maintains the keys 
	  in sorted order.

	- java.util.WeakHashMap (C): An implementation of the Map interface with weak keys. Entries in the WeakHashMap 
	  will be automatically removed when they are no longer reachable from the program.

	- java.util.HashTable (C): A legacy class similar to HashMap but synchronized. It's not commonly used in modern 
	  Java development due to its synchronization overhead.

	- java.util.IdentityHashMap (C): An implementation of the Map interface based on reference-equality in place of 
	  object-equality. It's useful when object-equality semantics are not desired.

//----------------------------------------------------------------------------------------------------------------

	1. List
	- Definition: Ordered collection that allows duplicates.
	- Duplicates Allowed? Yes.
	- Ordering: Maintains insertion order (e.g., ArrayList, LinkedList).
	- Null Values Allowed? Yes.
	- Implementation Classes: ArrayList, LinkedList, Vector, Stack.
	- Performance: Fast random access in ArrayList (O(1)), slower in LinkedList (O(n)).
	- Thread Safety: Vector is synchronized; others require Collections.synchronizedList().
	- Best Use Case: When maintaining order and allowing duplicates is required.

	2. Queue
	- Definition: Collection that processes elements in FIFO/LIFO or priority order.
	- Duplicates Allowed? Yes (depends on implementation).
	- Ordering: FIFO (LinkedList, ArrayDeque), LIFO (Deque), Priority-based (PriorityQueue).
	- Null Values Allowed? No in PriorityQueue, Yes in LinkedList.
	- Implementation Classes: PriorityQueue, ArrayDeque, LinkedList.
	- Performance: PriorityQueue efficiently retrieves elements based on priority.
	- Thread Safety: Not thread-safe by default.
	- Best Use Case: When elements need to be processed in a specific order.

	3. Set
	- Definition: Unordered collection that does not allow duplicate elements.
	- Duplicates Allowed? No.
	- Ordering: No guarantee (HashSet), Maintains insertion order (LinkedHashSet), Sorted order (TreeSet).
	- Null Values Allowed? Yes in HashSet, LinkedHashSet; No in TreeSet.
	- Implementation Classes: HashSet, TreeSet, LinkedHashSet.
	- Performance: HashSet is fast for search (O(1)), TreeSet has slower lookup (O(log n)).
	- Thread Safety: Not thread-safe by default.
	- Best Use Case: When only unique elements are needed.

	4. Map
	- Definition: Key-value pair collection where keys are unique, but values can be duplicate.
	- Duplicates Allowed? Keys: No; Values: Yes
	- Ordering: No guarantee (HashMap), Maintains insertion order (LinkedHashMap), Sorted order (TreeMap).
	- Null Values Allowed? One null key allowed in HashMap, LinkedHashMap; No null key in TreeMap; Multiple null values allowed.
	- Implementation Classes: HashMap, TreeMap, LinkedHashMap, Hashtable.
	- Performance: HashMap provides fast lookups (O(1)), TreeMap is slower (O(log n)).
	- Thread Safety: Hashtable is synchronized, ConcurrentHashMap is thread-safe.
	- Best Use Case: When key-value associations are required.

//----------------------------------------------------------------------------------------------------------------

Iterable interface
====================

In Java, the Iterable interface is a fundamental part of the Java Collections Framework. It provides a way to 
iterate over the elements of a collection, such as ArrayList, LinkedList, HashSet, etc., in a uniform and consistent 
manner. By implementing the Iterable interface, a class indicates that it can be iterated over using the enhanced 
for loop (for-each loop) or by explicitly obtaining an iterator.

import java.util.Iterator;
// Define a custom iterable class
class MyIterable implements Iterable<String> 
{
    private String[] data;
    public MyIterable(String[] data) 
    {
        this.data = data;
    }
    // Implement the iterator() method required by Iterable interface
    @Override
    public Iterator<String> iterator() 
    {
        return new Iterator<String>() {
            private int index = 0;

            @Override
            public boolean hasNext() {
                return index < data.length;
            }

            @Override
            public String next() {
                if (!hasNext()) {
                    throw new java.util.NoSuchElementException();
                }
                return data[index++];
            }
        };
    }
}

public class MyIterableExample 
{
    public static void main(String[] args) 
    {
        // Create an instance of the iterable class
        MyIterable myIterable = new MyIterable(new String[]{"Hello", "World", "Iterable"});

        // Iterate over the elements using a for-each loop
        for (String item : myIterable) 
	{
            System.out.println(item);
        }
    }
}
//----------------------------------------------------------------------------------------------------------------------

	// what is comparator and Comparable 

	In Java, Comparator and Comparable are two interfaces used for sorting objects. They allow you to define 
	custom sorting logic.

	1. Comparable (java.lang.Comparable)
	- Used to define natural ordering of objects.
	- The class that needs to be sorted implements Comparable<T>.
	- It overrides the compareTo(T obj) method.
	- It allows sorting based on one attribute only.
	- Modifies the class itself to provide sorting logic.



import java.util.*;
class Student implements Comparable<Student> {
    int rollNumber;
    String name;

    public Student(int rollNumber, String name) {
        this.rollNumber = rollNumber;
        this.name = name;
    }

    @Override
    public int compareTo(Student other) {
        return this.rollNumber - other.rollNumber; // Ascending order
    }
}

// Usage
public class DemoComparable {
    public static void main(String[] args) {
        List<Student> students = new ArrayList<>();
        students.add(new Student(3, "Sagar"));
        students.add(new Student(1, "Sourabh"));
        students.add(new Student(2, "Kiran"));

        Collections.sort(students); // Uses compareTo()

        for (Student s : students) {
            System.out.println(s.rollNumber + " - " + s.name);
        }
    }
}


	2. Comparator (java.util.Comparator)
	- Used to define custom ordering externally without modifying the class.
	- You create a separate class or use a lambda expression to implement Comparator<T>.
	- It overrides the compare(T obj1, T obj2) method.
	- It allows multiple sorting criteria (e.g., sorting by name or roll number).


import java.util.*;

class Student {
    int rollNumber;
    String name;

    public Student(int rollNumber, String name) {
        this.rollNumber = rollNumber;
        this.name = name;
    }
}

// Comparator to sort students by name
class NameComparator implements Comparator<Student> {
    @Override
    public int compare(Student s1, Student s2) {
        return s1.name.compareTo(s2.name); // Alphabetical order
    }
}

// Usage
public class DemoComparator {
    public static void main(String[] args) {
        List<Student> students = new ArrayList<>();
        students.add(new Student(3, "Sagar"));
        students.add(new Student(1, "Sourabh"));
        students.add(new Student(2, "Kiran"));

        Collections.sort(students, new NameComparator()); // Uses Comparator

        for (Student s : students) {
            System.out.println(s.rollNumber + " - " + s.name);
        }
    }
}

//---------------------------------------------------------------------------------------------------------

	// java.util.Collection Interface in Java
	The java.util.Collection interface is the root interface of the Java Collections Framework (JCF). 
	It is part of the java.util package and provides a unified way to work with groups of objects.

	1. Overview of Collection Interface
	- Package: java.util
	- Super Interface: Iterable<T> (allows iteration using forEach, iterator())
	- Subinterfaces: List<T>, Queue<T>, Set<T>
	- Implementation Classes: ArrayList, LinkedList, HashSet, TreeSet, PriorityQueue, etc.
	- Purpose: Provides common operations for all collection types, such as addition, removal, checking size, and iteration.


	2.  Methods in Collection Interface

	- boolean add(E e): Adds an element to the collection.
	- boolean remove(Object o): Removes a single instance of the specified element.
	- boolean contains(Object o): Checks if the collection contains the specified element.
	- int size(): Returns the number of elements in the collection.
	- boolean isEmpty(): Checks if the collection is empty.

	- boolean addAll(Collection<? extends E> c): Adds all elements from another collection.
	- boolean removeAll(Collection<?> c):Removes all elements present in another collection.
	- boolean retainAll(Collection<?> c):Retains only elements that are also in another collection.
	- void clear():Removes all elements from the collection.


	- Iterator<E> iterator():Returns an iterator to traverse elements.
	- default void forEach(Consumer<? super E> action): Performs the given action for each element (Java 8+).

	- Object[] toArray(): Converts the collection to an array of Object[].
	- <T> T[] toArray(T[] a): Converts the collection to an array of the specified type.


 //--------------------------------------------------------------------------------------------------

	//     Using Lists:

	java.util.List Interface in Java
	The List interface in Java is part of the Java Collections Framework (JCF) and extends Collection<T>. 
	It represents an ordered collection (also called a sequence) and allows duplicate elements.

	 Characteristics of List Interface
	 - Ordered Collection: Maintains the insertion order of elements.
	 - Allows Duplicates: Multiple elements with the same value are permitted.
	 - Indexed Access: Supports index-based retrieval, insertion, and removal of elements.
	 - Allows Null Values: Can store null values.
	 - Provides ListIterator: Supports both forward and backward traversal using ListIterator.


           java.util.Collection(I)
               │
               ├─── java.util.List(I)
               │    ├── java.util.ArrayList(C)
               │    ├── java.util.LinkedList(C)
               │    └── java.util.Vector(C)
               │         └── java.util.Stack(C)


	Methods: 

	 - void add(int index, E element): Inserts an element at a specific index.
	 - boolean add(E element): Appends the element to the list.
	 - E get(int index): Retrieves the element at a specific index.
	 - E set(int index, E element): Replaces an element at the given index.
	 - E remove(int index): Removes an element at a specific index.
	 - boolean remove(Object o): Removes the first occurrence of the specified element.
	 - int size(): Returns the number of elements.
	 - boolean contains(Object o): Checks if the list contains a specific element.

	 - int indexOf(Object o): Returns the first index of an element, or -1 if not found.
	 - int lastIndexOf(Object o): Returns the last index of an element.
	 - List<E> subList(int fromIndex, int toIndex): Returns a portion of the list.

	 - Iterator<E> iterator(): Returns an iterator to traverse elements forward.
	 - ListIterator<E> listIterator(): Returns a ListIterator for bidirectional traversal.
	 - ListIterator<E> listIterator(int index): Returns a ListIterator starting at the specified index.


//------------------------------------------------------------------------------------------------------------------------------

- java.util.ArrayList class:
-------------------------------

	Resizable-array implementation of the List interface. Implements all optional list operations, and permits 
	all elements,including null. In addition to implementing the List interface, this class provides methods to 
	manipulate the size of the array that is used internally to store the list. 
	(This class is roughly equivalent to Vector, except that it is unsynchronized.)

	Constructor and Description
	----------------------------

	- ArrayList(): Constructs an empty list with an initial capacity of ten.
	
	- ArrayList(Collection<? extends E> c): Constructs a list containing the elements of the specified collection, 
	  in the order they are returned by the collection's iterator.

	- ArrayList(int initialCapacity): Constructs an empty list with the specified initial capacity.


	// Allow store any type of object (not type-safe).

import java.util.*;
class DemoArrayList 
{
	public static void main(String[] args) 
	{
		// A collection may be a group of any type of objects.

		// ref by Collection interface
		Collection c = new ArrayList(); // as Collection is base interface, its reference able to refer ArrayList object
		c.add(11);
		c.add("Hi");
		c.add(34.73);
		System.out.println("Collection C is: "+c);

		// ref by list interface
		List l = new ArrayList(c); // As list acts as a base interface ....
		l.add(true);
		System.out.println("List l is: "+l);

		// ref by ArrayList reference
		ArrayList al = new ArrayList(20);
		al.addAll(l);
		al.add(56.89);
		System.out.println("Arraylist al is: "+al);
	}
}

//----------------------------------------

	// Using generics (<T>) to specify the type of elements.(Type-safe)


// Restricted arraylist of <T>
import java.util.*;
class DemoTList
{
	public static void main(String[] args) 
	{
		ArrayList<String> stringlist = new ArrayList<>();
		stringlist.add("hello");
		//stringlist.add(56);  // error
		stringlist.add("all");
		//stringlist.add(2.3); // error

		System.out.println("String List: "+stringlist);
	}
}


/-------------------------------------------------------------------------------------------------------------

	// Adding/inserting the elements in ArrayList

	- boolean add(E e): Appends the specified element to the end of this list.

	- void add(int index, E element): Inserts the specified element at the specified position in this list.

	- boolean addAll(Collection<? extends E> c): Appends all of the elements in the specified collection to 
	  the end of this list, in the order that they are returned by the specified collection's Iterator.

	- boolean addAll(int index, Collection<? extends E> c): Inserts all of the elements in the specified collection 
	  into this list, starting at the specified position.

	- E set(int index, E element): Replaces the element at the specified position in this list with the 
	  specified element.

import java.util.ArrayList;
public class ArrayListAddInsertExample {

	public static void main(String[] args) {

		ArrayList<String> arraylist=new ArrayList<>(9); 
		arraylist.add("C++");
		arraylist.add("Java");
		arraylist.add(0,"C");
		System.out.println(arraylist); 

		ArrayList<String> al=new ArrayList<>(); 
		al.add("Android");
		al.addAll(arraylist);
		System.out.println(al); 
		
		ArrayList<String> a2=new ArrayList<>(); 
		a2.add("SQL");
		a2.add("NoSQL");
		a2.addAll(1,al);
		System.out.println(a2); 
		
		String str = a2.set(5, "Oracle");
		System.out.println("After removing "+str+" Arrays List is: "+a2);
	}
}


//------------------------------------------------------------

	// Search and remove operations

	- boolean contains(Object o): Returns true if this list contains the specified element.

	- E get(int index): Returns the element at the specified position in this list.

	- int indexOf(Object o): Returns the index of the first occurrence of the specified element in this list, or -1 
		if this list does not contain the element.

	- boolean isEmpty(): Returns true if this list contains no elements.

	- int lastIndexOf(Object o): Returns the index of the last occurrence of the specified element in this list, 
	  or -1 if this list does not contain the element.

	- E remove(int index): Removes the element at the specified position in this list.
	
	- boolean remove(Object o): Removes the first occurrence of the specified element from this list, if it is present.

	- boolean removeAll(Collection<?> c): Removes from this list all of its elements that are contained in the 
	  specified collection.

	- List<E> subList(int fromIndex, int toIndex): Returns a view of the portion of this list between the specified 
	  fromIndex, inclusive, and toIndex, exclusive.

import java.util.ArrayList;
import java.util.List;
public class ArrayListExample {

	public static void main(String[] args) {

		ArrayList<String> arraylist=new ArrayList<>(9); 
		arraylist.add("C++");
		arraylist.add("Python");
		arraylist.add("Java");
		arraylist.add(0,"C");
		System.out.println("Arraylist contains Java: "+arraylist.contains("Java")); 

		ArrayList<String> al=new ArrayList<>(); 
		al.add("Android");
		al.addAll(arraylist);
		System.out.println(al); 
		System.out.println("2nd element in al: "+al.get(2)); 
		
		ArrayList<String> a2=new ArrayList<>(); 
		a2.add("SQL");
		a2.add("NoSQL");
		a2.addAll(1,al);
		System.out.println("a2 contains arraylist: "+a2.containsAll(arraylist)); 		
		a2.set(5, "Oracle");
		System.out.println(a2);
		
		List<String> sl=a2.subList(2, 5);
		System.out.println("Sublist: "+sl);
		
		if(a2.indexOf("Java")!=-1)
		{
			System.out.println("Java present at "+a2.indexOf("Java")+" position");
		}
		else
		{
			System.out.println("Java is not present in the List");
		}
		
		a2.add("C");
		a2.add("Java");
		System.out.println(a2);
		System.out.println("Last index of C in a2: "+a2.lastIndexOf("C"));
		
		a2.remove("C"); // removes first ocr
		System.out.println(a2);
		
		a2.add("Java");
		a2.removeAll(arraylist); // remove all ocr of elm in arraylist from a2
		System.out.println(a2);
	}
}

//-------------------------------

	// List iterating 
		
	- Iterator<E> iterator(): This method returns a basic Iterator object that allows you to iterate through the 
	  elements of the ArrayList in forward order only. It provides methods like hasNext() to check if there's a 
	  next element and next() to retrieve the next element.

	- ListIterator<E> listIterator(): This method returns a more versatile ListIterator object. It allows you to 
	  iterate forward and backward through the ArrayList. Similar to iterator(), it has hasNext(), next(), but 
	  also offers methods like hasPrevious() to check for a previous element and previous() to retrieve the 
	  previous element.

	- ListIterator<E> listIterator(int index): This method provides even more control. It returns a ListIterator 
	  that starts iterating from the specified index position in the ArrayList. The initial call to next() will 
	  return the element at the provided index, and subsequent calls will iterate forward. An initial call 
	  to previous() will return the element at index - 1 (if it exists).

	Using forEach(): 

	- void	forEach(Consumer<? super E> action): Performs the given action for each element of the Iterable until all elements 
		have been processed or the action throws an exception.


 //  Iterating over userdefined class using iterator: It is just to know how collection classes defined
     iterator inside. 

import java.util.Iterator;

// Define a custom iterable class
class Demo implements Iterable<String> 
{
    private String[] data;
    public Demo(String[] data) 
    {
        this.data = data;
    }
    // Implement the iterator() method required by Iterable interface
    @Override
    public Iterator<String> iterator() 
	{
        return new Iterator<String>() {
            private int index = 0;

            @Override
            public boolean hasNext() {
                return index < data.length;
            }

            @Override
            public String next() {
                if (!hasNext()) {
                    throw new java.util.NoSuchElementException();
                }
                return data[index++];
            }
        };
    }
}

public class MyIterableExample 
{
    public static void main(String[] args) 
	{
        // Create an instance of the iterable class
        Demo demo = new Demo(new String[]{"Hello", "World", "Iterable"});

        // Iterate over the elements using a for-each loop
        for (String item : demo) 
	{
            System.out.println(item);
        }

	System.out.println("Using iterator: ");
	Iterator<String> ob=demo.iterator();
	while(ob.hasNext())
	{
		System.out.println(ob.next());
	}
    }
}

	// Actually we have use only in case of collection classes as...

import java.util.*;
class IteratingOverCollectionClass
{
	public static void main(String[] args) 
	{
		ArrayList<String> arraylist=new ArrayList<>(9); 
		arraylist.add("C++");
		arraylist.add("Python");
		arraylist.add("Java");
		arraylist.add(0,"C");

		 // Iterate over the elements using a for-each loop
		System.out.println("Using for-each loop: ");
       		for(String str : arraylist) 
		{
            		System.out.println(str);
        	}

		 // Iterate over the elements using iterator
		System.out.println("Using iterator: ");
		Iterator<String> ob = arraylist.iterator();
		while(ob.hasNext())
		{
			System.out.println(ob.next());
		}

		// Iterate over the elements using list-iterator
		System.out.println("Using listiterator:(FWD)");
		ListIterator<String> itr = arraylist.listIterator();
		while(itr.hasNext())
		{
			System.out.println(itr.next());
		}
 
 		System.out.println("Using listiterator:(PRV)");
		// As it starts from 0th location, prv option give values only when you attend non-zero index, otherwise blank
		while(itr.hasPrevious())
		{
			System.out.println(itr.previous());
		}

		// Using forEach with a Lambda Expression
        	System.out.println("Using Lambda Expression:");
        	arraylist.forEach(e -> System.out.println(e));

		// Using forEach with a Method Reference
        	System.out.println("\nUsing Method Reference:");
        	arraylist.forEach(System.out::println);
	}
}

//----------------------------------------------------------------------

	// Using removeIf()

	boolean	removeIf(Predicate<? super E> filter)
	Removes all of the elements of this collection that satisfy the given predicate.

import java.util.ArrayList;
import java.util.function.Predicate;

public class RemoveIfArrayListExample {

    public static void main(String[] args) {
        ArrayList<Integer> numbers = new ArrayList<>();
        numbers.add(11);
        numbers.add(20);
        numbers.add(33);
        numbers.add(40);
        numbers.add(50);
        numbers.add(61);
        numbers.add(70);
        numbers.add(15);
		System.out.println("Numbers: " + numbers);

        // Predicate to check if a number is even
        Predicate<Integer> isEven = number -> number % 2 == 0;

        // Remove all even numbers using removeIf and Predicate
        numbers.removeIf(isEven);
        System.out.println("Numbers after removing even numbers: " + numbers);

        // Another Predicate to check if a number is greater than 30
        Predicate<Integer> greaterThan30 = number -> number > 30;
		numbers.removeIf(greaterThan30);		
        System.out.println("Numbers after removing >30 numbers: " + numbers);
    }
}

//------------------------------------------------------------------------

	- void replaceAll(UnaryOperator<E> operator): Replaces each element of this list with the result of applying
	  the operator to that element.

import java.util.*;
public class ArrayListExampleReplaceAll {
    public static void main(String[] args) {

        // Creating an ArrayList of Integers
        List<Integer> numbers = new ArrayList<>();
        
        // Adding elements to the ArrayList
        numbers.add(1);
        numbers.add(2);
        numbers.add(3);
        numbers.add(4);
        numbers.add(5);
        
        // Printing the original ArrayList
        System.out.println("Original ArrayList: " + numbers);
        
        // Replacing each element with its square
        numbers.replaceAll(n -> n * n);
        
        // Printing the modified ArrayList
        System.out.println("Modified ArrayList: " + numbers);
    }
}

//------------------------------------------------------------------------

	- boolean retainAll(Collection<?> c): Retains only the elements in this list that are contained in the specified 
		collection. In other words, it removes all elements from the current collection that are not contained in 
		the specified collection.

package collectionexamples;
import java.util.ArrayList;
import java.util.Collection;

public class RetainAllExample {
    public static void main(String[] args) {
        // Creating two ArrayLists
        ArrayList<String> list1 = new ArrayList<>();
        ArrayList<String> list2 = new ArrayList<>();
        
        // Adding elements to the first ArrayList
        list1.add("apple");
        list1.add("banana");
        list1.add("orange");
        list1.add("grapes");
        
        // Adding elements to the second ArrayList
        list2.add("banana");
        list2.add("orange");
        list2.add("kiwi");
        
        // Printing the original lists
        System.out.println("Original list1: " + list1);
        System.out.println("Original list2: " + list2);
        
        // Retaining only the elements that are common in both lists
        boolean changed = list1.retainAll(list2);
        
        // Printing the modified list1
        System.out.println("Modified list1: " + list1);
        
        // Checking if the list1 has been modified
        System.out.println("List1 has been modified: " + changed);
    }
}

//------------------------------------------------------------------------
	- void sort(Comparator<? super E> c): Sorts this list according to the order induced by the specified Comparator.
	 	This method is used for sorting elements in a list based on a custom comparison logic. 

		- void: This indicates that the method doesn't return any value after execution.
		- sort: This signifies that the method sorts the elements within a list.
		- <E>: This represents the generic type of the elements in the list.
		- Comparator<? super E> c: This parameter is of type Comparator. It defines a custom comparison logic 
		  that determines the sorting order of the elements. The ? super E part allows the comparator to work 
		  with elements that are subtypes of E. This provides flexibility in sorting elements of different but 
		  related types.
		- c: This is a reference to a Comparator object. A comparator defines how to compare two elements of 
		   the list.

	Note: # The sorting is done by the provided method sort() itself, only you have to provide the comparisation
	        logic, that should be provided using Comparator.
	
	      # for that cerate the custum class which implements Comparator<>, and overrides the method
	
			public int compare( <> p1, <> p2) {
        			return <wrapper_class>.compare(p1.get...(), p2.get...());
    			}

	      # This method will be used as comparisation logic by the sort method internally, and sorts the collection
                automatically for you.
	      # After that, you can go for lambda expression for optimization.


import java.util.*;

 class Product {
    private String name;
    private double price;
    private int id;

    public Product(int id, String name, double price) {
		this.id = id;
        this.name = name;
        this.price = price;
    }

    public String getName() {
        return name;
    }

    public double getPrice() {
        return price;
    }

    public int getId() {
        return id;
    }

    @Override
    public String toString() {
        return id+" - "+name + ":Rs." + price;
    }
}

// Comparator implementation to sort products based on their prices
class ProductPriceComparator implements Comparator<Product> {
    @Override
    public int compare(Product p1, Product p2) {
        return Double.compare(p1.getPrice(), p2.getPrice());
    }
}

public class SortProductsExample {
    public static void main(String[] args) {
        // Create a list of products
        List<Product> products = new ArrayList<>();

        products.add(new Product(12,"Laptop", 90999.99));
        products.add(new Product(89,"Smartphone", 64599.99));
        products.add(new Product(2,"Headphones", 1249.99));
        products.add(new Product(34,"Tablet", 8399.99));

        // Output the list before sorting
        /// System.out.println("Before sorting: " + products);
		System.out.println("\n -------------- Before price sorting -------------------");
		Iterator<Product> ob1 = products.iterator();
		while(ob1.hasNext())
		{
			System.out.println(ob1.next());
		}

        // Sort the list based on product price
        products.sort(new ProductPriceComparator());

        // Output the list after sorting
        ///System.out.println("After price sorting: " + products);
		System.out.println("\n -------------- After price sorting -------------------");
		Iterator<Product> ob = products.iterator();
		while(ob.hasNext())
		{
			System.out.println(ob.next());
		}
    }
}

//----------------------------------------------------------------

	// can be written using anonymous implementation

import java.util.*;

 class Product {
    private String name;
    private double price;
    private int id;

    public Product(int id, String name, double price) {
		this.id = id;
        this.name = name;
        this.price = price;
    }

    public String getName() {
        return name;
    }

    public double getPrice() {
        return price;
    }

    public int getId() {
        return id;
    }

    @Override
    public String toString() {
        return id+" - "+name + ":Rs." + price;
    }
}

public class SortProductsExample {
    public static void main(String[] args) {
        // Create a list of products
        List<Product> products = new ArrayList<>();

        products.add(new Product(12,"Laptop", 90999.99));
        products.add(new Product(89,"Smartphone", 64599.99));
        products.add(new Product(2,"Headphones", 1249.99));
        products.add(new Product(34,"Tablet", 8399.99));

        // Output the list before sorting
        /// System.out.println("Before sorting: " + products);
		System.out.println("\n -------------- Before price sorting -------------------");
		Iterator<Product> ob1 = products.iterator();
		while(ob1.hasNext())
		{
			System.out.println(ob1.next());
		}

        // Sort the list based on product price
        products.sort(new Comparator<Product>(){
			@Override
			public int compare(Product p1, Product p2) {
				return Double.compare(p1.getPrice(), p2.getPrice());
			}
        });

        // Output the list after sorting
        ///System.out.println("After price sorting: " + products);
		System.out.println("\n -------------- After price sorting -------------------");
		Iterator<Product> ob = products.iterator();
		while(ob.hasNext())
		{
			System.out.println(ob.next());
		}
    }
}


//----------------------------------------------------------------

	// Can be optimized using -> functions 

import java.util.*;

 class Product {
    private String name;
    private double price;
    private int id;

    public Product(int id, String name, double price) {
		this.id = id;
        this.name = name;
        this.price = price;
    }

    public String getName() {
        return name;
    }

    public double getPrice() {
        return price;
    }

    public int getId() {
        return id;
    }

    @Override
    public String toString() {
        return id+" - "+name + ":Rs." + price;
    }
}

public class SortProductsExample {
    public static void main(String[] args) {
        // Create a list of products
        List<Product> products = new ArrayList<>();

        products.add(new Product(12,"Laptop", 90999.99));
        products.add(new Product(89,"Smartphone", 64599.99));
        products.add(new Product(2,"Headphones", 1249.99));
        products.add(new Product(34,"Tablet", 8399.99));

        // Output the list before sorting
        /// System.out.println("Before sorting: " + products);
		System.out.println("\n -------------- Before price sorting -------------------");
		Iterator<Product> ob1 = products.iterator();
		while(ob1.hasNext())
		{
			System.out.println(ob1.next());
		}

        // Sort the list based on product price
        products.sort((Product p1, Product p2) -> {
				return Double.compare(p1.getPrice(), p2.getPrice());
			}
        );

        // Output the list after sorting
        ///System.out.println("After price sorting: " + products);
		System.out.println("\n -------------- After price sorting -------------------");
		Iterator<Product> ob = products.iterator();
		while(ob.hasNext())
		{
			System.out.println(ob.next());
		}
    }
}


//----------------------------------------------------------------

	// can further optimized as 

import java.util.*;

 class Product {
    private String name;
    private double price;
    private int id;

    public Product(int id, String name, double price) {
		this.id = id;
        this.name = name;
        this.price = price;
    }

    public String getName() {
        return name;
    }

    public double getPrice() {
        return price;
    }

    public int getId() {
        return id;
    }

    @Override
    public String toString() {
        return id+" - "+name + ":Rs." + price;
    }
}

public class SortProductsExample {
    public static void main(String[] args) {
        // Create a list of products
        List<Product> products = new ArrayList<>();

        products.add(new Product(12,"Laptop", 90999.99));
        products.add(new Product(89,"Smartphone", 64599.99));
        products.add(new Product(2,"Headphones", 1249.99));
        products.add(new Product(34,"Tablet", 8399.99));

        // Output the list before sorting
        /// System.out.println("Before sorting: " + products);
		System.out.println("\n -------------- Before price sorting -------------------");
		Iterator<Product> ob1 = products.iterator();
		while(ob1.hasNext())
		{
			System.out.println(ob1.next());
		}

        // Sort the list based on product price
        products.sort((p1, p2) ->  Double.compare(p1.getPrice(), p2.getPrice()));
			
  
        // Output the list after sorting
        ///System.out.println("After price sorting: " + products);
		System.out.println("\n -------------- After price sorting -------------------");
		Iterator<Product> ob = products.iterator();
		while(ob.hasNext())
		{
			System.out.println(ob.next());
		}
    }
}

//---------------------------------------------------------------------

	// You can use Collections class, having sort() method 
	
	- static <T extends Comparable<? super T>> void	sort(List<T> list)
	  Sorts the specified list into ascending order, according to the natural ordering of its elements.

	- static <T> void sort(List<T> list, Comparator<? super T> c)
	  Sorts the specified list according to the order induced by the specified comparator.

 
import java.util.*;

 class Product {
    private String name;
    private double price;
    private int id;

    public Product(int id, String name, double price) {
		this.id = id;
        this.name = name;
        this.price = price;
    }

    public String getName() {
        return name;
    }

    public double getPrice() {
        return price;
    }

    public int getId() {
        return id;
    }

    @Override
    public String toString() {
        return id+" - "+name + ":Rs." + price;
    }
}

public class SortProductsExample {
    public static void main(String[] args) {
        // Create a list of products
        List<Product> products = new ArrayList<>();

        products.add(new Product(12,"Laptop", 90999.99));
        products.add(new Product(89,"Smartphone", 64599.99));
        products.add(new Product(2,"Headphones", 1249.99));
        products.add(new Product(34,"Tablet", 8399.99));

        // Output the list before sorting
        /// System.out.println("Before sorting: " + products);
		System.out.println("\n -------------- Before price sorting -------------------");
		Iterator<Product> ob1 = products.iterator();
		while(ob1.hasNext())
		{
			System.out.println(ob1.next());
		}

        // Sort the list based on product price
        //products.sort((p1, p2) ->  Double.compare(p1.getPrice(), p2.getPrice()));
		
		Collections.sort(products, (p1, p2) -> Double.compare(p1.getPrice(), p2.getPrice()));
  
        // Output the list after sorting
        ///System.out.println("After price sorting: " + products);
		System.out.println("\n -------------- After price sorting -------------------");
		Iterator<Product> ob = products.iterator();
		while(ob.hasNext())
		{
			System.out.println(ob.next());
		}
    }
}


//---------------------------------------------------------------------------------------------------


	// Now Using  void sort(Comparator<? super E> c) from Array List to sort Numbers

import java.util.*;
class CollectiosDemo {
	public static void main(String []args)
	{
		ArrayList<Integer> arlst=new ArrayList<Integer>();
		arlst.add(12);
		arlst.add(32);
		arlst.add(142);
		arlst.add(127);
		arlst.add(42);
		arlst.add(16);
		arlst.add(112);
		System.out.println("Entered Arraylist is: "+arlst);

		arlst.sort( (x,y)-> Integer.compare((int)x,(int)y) );
		System.out.println("Entered(ascending) Arraylist is: "+arlst);

		arlst.sort( (x,y)-> Integer.compare((int)y,(int)x) );
		System.out.println("Entered(descending) Arraylist is: "+arlst);

		// Using Collections
		
		Collections.sort(arlst);
		System.out.println("Entered(ascending) Arraylist is: "+arlst);


		// Collections.sort(arlst,	(x,y)-> Integer.compare((int)y,(int)x));
		// for reverse order Collections class provides the prdefined comparator, Collections.reverseOrder()
		Collections.sort(arlst,	Collections.reverseOrder());
		System.out.println("Entered(descending) Arraylist is: "+arlst);
	}
}

//------------------------------------------------------------------------------------------------------------


- Spliterator<E> spliterator(): Creates a late-binding and fail-fast Spliterator over the elements in this list.
	
	Fail-Fast vs. Fail-Safe in Java (Short Explanation)

		1. Fail-Fast
		- Throws ConcurrentModificationException if the collection is modified while iterating.
		- Works directly on the original collection.
		- Faster but not thread-safe.
		- Example: ArrayList, HashSet, HashMap (normal iterators).

		2. Fail-Safe
		- Does not throw exceptions if modified during iteration.
		- Iterates over a separate copy (snapshot).
		- Slower but thread-safe.
		- Example: CopyOnWriteArrayList, ConcurrentHashMap

	In Java, a Spliterator is an interface introduced in Java 8 as part of the Stream API(Application Programming Interface). 
	It provides a way to perform parallel traversal over the elements of a source, such as an array, a generator function, etc.
		
	The ArrayList class in Java also implements the Spliterator interface using the .spliterator() method. This method returns a
	Spliterator over the elements in ArrayList. It is considered a better way to iterate over elements as it gives more 
	control over them.

	The .spliterator() method can be combined with a number of other methods:

	- tryAdvance(): This method is used to iterate elements separately in several threads to enable parallel processing.
	- forEachRemaining(): This method is used to iterate elements consecutively in a single thread.
	- trySplit(): This method splits the obtained Spliterator into separate parts to facilitate parallel processing.


package collectionexamples;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.Spliterator;

public class UsingsplIterator {

	public static void main(String []args) {
		
		ArrayList<Integer> arlst=new ArrayList<Integer>();
		arlst.add(12);
		arlst.add(32);
		arlst.add(142);
		arlst.add(127);
		arlst.add(42);
		arlst.add(16);
		arlst.add(112);
		System.out.println("Entered Arraylist is: "+arlst);
		
		Iterator<Integer> ob=arlst.iterator();
		System.out.println("Entered Arraylist(using iterator) is: ");
		while(ob.hasNext())
		{
			System.out.print("  "+ob.next());
		}
		
		ob=arlst.iterator();
		System.out.println("\n Entered Arraylist(using foreach) is: ");
		ob.forEachRemaining(element -> System.out.print(" "+element));
		
		//----------------
		
		Spliterator<Integer> sob = arlst.spliterator();
		System.out.println("\n using spiterator tryadvance()-I: ");
		while(sob.tryAdvance(element -> System.out.print(" "+element)));
		
		sob = arlst.spliterator();
		System.out.println("\n using spiterator tryadvance()-II: ");
		while(sob.tryAdvance(System.out::println)); // shorter way of above
		
		//---------------
		
		sob = arlst.spliterator();
		Spliterator<Integer> sob1 = sob.trySplit(); // a part of sob is separated 
		System.out.println("\n Entered Arraylist(split part) is: ");
		if(sob1!=null)
			sob1.forEachRemaining(element -> System.out.print(" "+element)); // separated part display
		
		System.out.println("\n Entered Arraylist(split part) is: ");
		sob.forEachRemaining(element -> System.out.print(" "+element)); // remaining part display
		
	}

}

//------------------------------------------------------------------------
The important points about Java ArrayList class are:

	- Java ArrayList class can contain duplicate elements.
	- Java ArrayList class maintains insertion order.
	- Java ArrayList class is non-synchronized.
	- Java ArrayList allows random access because array works at the index basis.
	- In Java ArrayList class, manipulation is slow because a lot of shifting needs to have occurred if any element is removed 
	  from the array list.
	- You cannot create an ArrayList of primitive types like int, char, etc. You need to use boxed types like Integer, 
	  Character, Boolean, etc.

//---------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------------------------------------

interface Queue<E>
--------------------

A collection designed for holding elements prior to processing. Besides basic Collection operations, queues provide additional 
insertion, extraction, and inspection operations. Each of these methods exists in two forms: one throws an exception if the 
operation fails, the other returns a special value (either null or false, depending on the operation). The latter form of the 
insert operation is designed specifically for use with capacity-restricted Queue implementations; in most implementations, insert 
operations cannot fail.

Summary of Queue methods

 - Insert: add(e) and offer(e): The offer method inserts an element at end if possible, otherwise returning false. This differs from the
 	   Collection.add method, which can fail to add an element only by throwing an unchecked exception. The offer method is 
	   designed for use when failure is a normal, rather than exceptional occurrence, for example, in fixed-capacity (or 
	   "bounded") queues.

 - Remove: remove() and poll(): The remove() and poll() methods remove and return the head of the queue. The remove() and poll() 
	methods differ only in their behavior when the queue is empty: the remove() method throws an exception, while the poll() 
	method returns null.
		
 - Examine: element() and peek(): The element() and peek() methods return, but do not remove, the head of the queue.

 - Methods in Queue Interface

  public abstract boolean add(E);
  public abstract boolean offer(E);
  public abstract E remove();
  public abstract E poll();
  public abstract E element();
  public abstract E peek();

//-----------------------------------------------------------------

interface Deque<E>
--------------------
 - A linear collection that supports element insertion and removal at both ends. The name deque is short 
   for "double ended queue" 

- Methods in Deque Interface

  public abstract void addFirst(E);
  public abstract void addLast(E);
  public abstract boolean offerFirst(E);
  public abstract boolean offerLast(E);
  public abstract E removeFirst();
  public abstract E removeLast();
  public abstract E pollFirst();
  public abstract E pollLast();
  public abstract E getFirst();
  public abstract E getLast();
  public abstract E peekFirst();
  public abstract E peekLast();
  public abstract boolean removeFirstOccurrence(java.lang.Object);
  public abstract boolean removeLastOccurrence(java.lang.Object);
  public abstract boolean add(E);
  public abstract boolean offer(E);
  public abstract E remove();
  public abstract E poll();
  public abstract E element();
  public abstract E peek();
  public abstract boolean addAll(java.util.Collection<? extends E>);
  public abstract void push(E);
  public abstract E pop();
  public abstract boolean remove(java.lang.Object);
  public abstract boolean contains(java.lang.Object);
  public abstract int size();
  public abstract java.util.Iterator<E> iterator();
  public abstract java.util.Iterator<E> descendingIterator();
  public default java.util.Deque<E> reversed();
  public default java.util.SequencedCollection reversed();
}

//-------------------------------------
	
 Using Java.util.LinkedList:
 ---------------------------
 	- Decl: public class LinkedList<E> extends AbstractSequentialList<E> implements List<E>, Deque<E>, 
	  Cloneable, Serializable

 	- Doubly-linked list implementation of the List and Deque interfaces. Implements all optional list operations, 
	  and permits all elements (including null).


	- Constructors: 

	 - LinkedList(): Constructs an empty list.
 	 - LinkedList(Collection<? extends E> c): Constructs a list containing the elements of the specified collection, 
   	   in the order they are returned by the collection's iterator.

	- LinkedList Methods:

	First we will discuss some of the useful and frequently used Java LinkedList methods. 
	The following methods are inherited from List or Collection interface:

	- int size(): to get the number of elements in the list.
	- boolean isEmpty(): to check if list is empty or not.
	- boolean contains(Object o): Returns true if this list contains the specified element.
	- Iterator iterator(): Returns an iterator over the elements in this list in proper sequence.
	- Object[] toArray(): Returns an array containing all of the elements in this list in proper sequence.
	- boolean add(E e): Appends the specified element to the end of this list.
	- boolean remove(Object o): Removes the first occurrence of the specified element from this list.
	- boolean retainAll(Collection c): Retains only the elements in this list that are contained in the 
	  specified collection.
	- void clear(): Removes all the elements from the list.
	- E get(int index): Returns the element at the specified position in the list.
	- E set(int index, E element): Replaces the element at the specified position in the list with the 
	  specified element.
	- ListIterator listIterator(): Returns a list iterator over the elements in the list.
	- List subList(int fromIndex, int toIndex): Returns a view of the portion of this list between the 
	  specified fromIndex, inclusive, and toIndex, exclusive. The returned list is backed by this list, 
	  so non-structural changes in the returned list are reflected in this list, and vice-versa.

	Java LinkedList Deque Methods
	The following methods are specific to LinkedList class which are inherited from Deque interface:

	- void addFirst(E e): Inserts the specified element at the beginning of this list.
	- void addLast(E e): Inserts the specified element at the end of this list.
	- E getFirst(): Retrieves, but does not remove, the first element of this list. 
	  This method differs from peekFirst only in that it throws an exception if this list is empty.
	- E getLast(): Retrieves, but does not remove, the last element of this list. This method differs 
	  from peekLast only in that it throws an exception if this list is empty.
	- E remvoeFirst(): Removes and returns the first element from this list.
	- E removeLast(): Removes and returns the last element from this list.
	- boolean offerFirst(E e): Inserts the specified element at the front of this list.
	- boolean offerLast(E e): Inserts the specified element at the end of this list.
	- E pollFirst(): Retrieves and removes the first element of this list, or returns null if this list is empty.
	- E pollLast(): Retrieves and removes the last element of this list, or returns null if this list is empty.
	- E peekFirst(): Retrieves, but does not remove, the first element of this list, or returns null if this list 
	  is empty.
	- E peekLast(): Retrieves, but does not remove, the last element of this list, or returns null if this list 
	  is empty.
	- public E pop(): Pops an element from the stack represented by this list. In other words, 
	  removes and returns the first element of this list.

	Java LinkedList Queue Methods
	The following methods are specific to LinkedList class which are inherited from Queue interface:

	- boolean add(E e): Inserts the specified element into this queue if it is possible to do so immediately 
	  without violating capacity restrictions, returning true upon success and throwing an IllegalStateException 
	  if no space is currently available.
	- E element(): Retrieves, but does not remove, the head of this queue.
	- boolean offer(E e): Inserts the specified element into this queue if it is possible to do so 
	  immediately without violating capacity restrictions.
	- E peek(): Retrieves, but does not remove, the head of this queue, or returns null if this queue is empty.
	- E poll(): Retrieves and removes the head of this queue, or returns null if this queue is empty.
	- E remove(): Retrieves and removes the head of this queue.NoSuchElementException - if this list is empty

import java.util.ArrayList;
import java.util.LinkedList;

public class LinkListExample {

	public static void main(String[] args) {
//		LinkedList<Integer> l1=new LinkedList<>(); // Empty list
//		System.out.println(l1.remove()); // generates an Exception 
//		System.out.println(l1.poll()); // gives null as output
		
		ArrayList<Integer> al=new ArrayList();
		al.add(12);
		al.add(23);
		al.add(90);
		al.add(32);
		al.add(100);
		LinkedList<Integer> l2=new LinkedList<>(al);

		System.out.println("Element at start: "+l2.element());
		System.out.println("Element at start: "+l2.getFirst());
		System.out.println("Element at start: "+l2.peek());
		System.out.println("Element at start: "+l2.peekFirst());
		System.out.println("Element at start: "+l2.poll());
		System.out.println("Element at start: "+l2.pollFirst());
		System.out.println("Element at start: "+l2.pop());
		System.out.println("Element at start: "+l2.remove());
	}

}

//-----------------------------------------------------

//-----------------------------------------------------

	// iterating in LinkedList using iterator(), listIterator() and spliterator()

package collectionexamples;
import java.util.LinkedList;
import java.util.ListIterator;
import java.util.Spliterator;
import java.util.function.Consumer;

public class UsingIteratorInLinkedList {
    public static void main(String[] args) {
        LinkedList<String> linkedList = new LinkedList<>();
        linkedList.add("Apple");
        linkedList.add("Banana");
        linkedList.add("Cherry");
        linkedList.add("Date");
        linkedList.add("Elderberry");

        // Using iterator() to print all elements
        System.out.println("Using iterator:");
        var iterator = linkedList.iterator();
        // The var keyword in Java is a feature introduced in Java 10 as part of the local 
        // variable type inference. It allows the compiler to infer the type of a local variable 
        // based on the type of the initializer. 
        while (iterator.hasNext()) {
            System.out.println(iterator.next());
        }

        // Using listIterator() to traverse forward and backward, modifying elements
        System.out.println("\nUsing listIterator (forward and backward):");
        ListIterator<String> listIterator = linkedList.listIterator();
        System.out.println("Traversing forward and modifying:");
        while (listIterator.hasNext()) {
            String fruit = listIterator.next();
            if (fruit.equals("Banana")) {
                listIterator.set("Blueberry");
            }
            System.out.println(fruit);
        }

        System.out.println("Traversing backward:");
        while (listIterator.hasPrevious()) {
            System.out.println(listIterator.previous());
        }

        // Using spliterator() to split and process the list
        System.out.println("\n Using spliterator:");
        Spliterator<String> spliterator1 = linkedList.spliterator();
        Spliterator<String> spliterator2 = spliterator1.trySplit();

        // Consumer to process elements
        Consumer<String> consumer = fruit -> System.out.println("Processing: " + fruit);

        // Process first half of the list
        System.out.println("First spliterator:");
        spliterator1.forEachRemaining(consumer);

        // Process second half of the list
        System.out.println("Second spliterator:");
        if (spliterator2 != null) {
            spliterator2.forEachRemaining(consumer);
        } else {
            System.out.println("Spliterator could not split further.");
        }
    }
}

//-----------------------------------------------------

	// use forEach() and toArray()

package collectionexamples;
import java.util.LinkedList;

public class LinkedListDemo {

    public static void main(String[] args) {
        // Create a LinkedList
        LinkedList<String> fruits = new LinkedList<>();
        fruits.add("Apple");
        fruits.add("Banana");
        fruits.add("Orange");
        fruits.add("Mango");

        // 1. Print elements using forEach()
        System.out.println("Printing fruits using forEach():");
        fruits.forEach(fruit -> System.out.println(fruit));

        // 2. Modify elements using forEach()
        System.out.println("\nModifying fruits (uppercase) using forEach():");
        fruits.forEach(fruit -> fruits.set(fruits.indexOf(fruit), fruit.toUpperCase()));
        fruits.forEach(fruit -> System.out.println(fruit));

        // 3. Convert LinkedList to Object array using toArray()
        System.out.println("\nConverting fruits to Object array using toArray():");
        Object[] fruitsArray = fruits.toArray();
        for (Object fruit : fruitsArray) {
            System.out.println(fruit);
        }

        // 4. Convert LinkedList to String array using toArray(String[])
        System.out.println("\nConverting fruits to String array using toArray(String[]):");
        String[] fruitsStringArray = fruits.toArray(new String[fruits.size()]);
        for (String fruit : fruitsStringArray) {
            System.out.println(fruit);
        }
    }
}


//-----------------------------------------------------

//-----------------------------------------------------

	// implement Queue operations using LinkedList

package collectionexamples;
import java.util.LinkedList;
import java.util.Queue;
import java.util.Scanner;

public class QueueOperations {
    public static void main(String[] args) {
        Queue<String> queue = new LinkedList<>();
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        while (running) {
            System.out.println("\n Queue Operations Menu:");
            System.out.println("1. Enqueue");
            System.out.println("2. Dequeue");
            System.out.println("3. Peek");
            System.out.println("4. Check if Queue is Empty");
            System.out.println("5. Display Queue");
            System.out.println("6. Exit");
            System.out.print("Enter your choice: ");
            int choice = scanner.nextInt();
            scanner.nextLine();  // Consume the newline

            switch (choice) {
                case 1:
                    System.out.print("Enter element to enqueue: ");
                    String element = scanner.nextLine();
                    queue.add(element);
                    System.out.println("Enqueued: " + element);
                    break;
                case 2:
                    if (!queue.isEmpty()) {
                        String removedElement = queue.remove();
                        System.out.println("Dequeued: " + removedElement);
                    } else {
                        System.out.println("Queue is empty. Nothing to dequeue.");
                    }
                    break;
                case 3:
                    if (!queue.isEmpty()) {
                        String frontElement = queue.peek();
                        System.out.println("Front element: " + frontElement);
                    } else {
                        System.out.println("Queue is empty. Nothing to peek.");
                    }
                    break;
                case 4:
                    System.out.println("Is the queue empty? " + queue.isEmpty());
                    break;
                case 5:
                    System.out.println("Queue: " + queue);
                    break;
                case 6:
                    running = false;
                    System.out.println("Exiting...");
                    break;
                default:
                    System.out.println("Invalid choice. Please try again.");
            }
        }
        scanner.close();
    }
}

//-----------------------------------------------------
	// implement stack operations using LinkedList

package collectionexamples;
import java.util.LinkedList;
import java.util.Scanner;

public class StackOperations {
    public static void main(String[] args) {
        LinkedList<String> stack = new LinkedList<>();
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        while (running) {
            System.out.println("\nStack Operations Menu:");
            System.out.println("1. Push");
            System.out.println("2. Pop");
            System.out.println("3. Peek");
            System.out.println("4. Check if Stack is Empty");
            System.out.println("5. Display Stack");
            System.out.println("6. Exit");
            System.out.print("Enter your choice: ");
            int choice = scanner.nextInt();
            scanner.nextLine();  // Consume the newline

            switch (choice) {
                case 1:
                    System.out.print("Enter element to push: ");
                    String element = scanner.nextLine();
                    stack.push(element); // Push element onto the stack
                    System.out.println("Pushed: " + element);
                    break;
                case 2:
                    if (!stack.isEmpty()) {
                        String poppedElement = stack.pop(); // Pop element from the stack
                        System.out.println("Popped: " + poppedElement);
                    } else {
                        System.out.println("Stack is empty. Nothing to pop.");
                    }
                    break;
                case 3:
                    if (!stack.isEmpty()) {
                        String topElement = stack.peek(); // Peek at the top element of the stack
                        System.out.println("Top element: " + topElement);
                    } else {
                        System.out.println("Stack is empty. Nothing to peek.");
                    }
                    break;
                case 4:
                    System.out.println("Is the stack empty? " + stack.isEmpty());
                    break;
                case 5:
                    System.out.println("Stack: " + stack);
                    break;
                case 6:
                    running = false;
                    System.out.println("Exiting...");
                    break;
                default:
                    System.out.println("Invalid choice. Please try again.");
            }
        }        
        scanner.close();
    }
}

//-------------------------------------------------------------------------------------

 // implement All linked list operations using LinkedList

package collectionexamples;
import java.util.LinkedList;
import java.util.ListIterator;
import java.util.Collections;
import java.util.Scanner;

public class LinkedListOperations {
    public static void main(String[] args) {
        LinkedList<Integer> linkedList = new LinkedList<>();
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        while (running) {
            System.out.println("\nLinkedList Operations Menu:");
            System.out.println("1. Add to the front");
            System.out.println("2. Add to the end");
            System.out.println("3. Add at a specific position");
            System.out.println("4. Remove from the front");
            System.out.println("5. Remove from the end");
            System.out.println("6. Remove by value");
            System.out.println("7. Get first element");
            System.out.println("8. Get last element");
            System.out.println("9. Get element at a specific position");
            System.out.println("10. Update element at a specific position");
            System.out.println("11. Traverse the list forward");
            System.out.println("12. Search by value");
            System.out.println("13. Size of the list");
            System.out.println("14. Check if the list is empty");
            System.out.println("15. Clear the list");
            System.out.println("16. Convert to array");
            System.out.println("17. Sort the list");
            System.out.println("18. Exit");
            System.out.print("Enter your choice: ");
            int choice = scanner.nextInt();
            scanner.nextLine();  // Consume the newline

            switch (choice) {
                case 1:
                    System.out.print("Enter element to add to the front: ");
                    int element1 = scanner.nextInt();
                    linkedList.addFirst(element1);
                    System.out.println("List: " + linkedList);
                    break;
                case 2:
                    System.out.print("Enter element to add to the end: ");
                    int element2 = scanner.nextInt();
                    linkedList.addLast(element2);
                    System.out.println("List: " + linkedList);
                    break;
                case 3:
                    System.out.print("Enter position: ");
                    int position = scanner.nextInt();
                    scanner.nextLine();  // Consume the newline
                    System.out.print("Enter element to add: ");
                    int element3 = scanner.nextInt();
                    linkedList.add(position, element3);
                    System.out.println("List: " + linkedList);
                    break;
                case 4:
                    if (!linkedList.isEmpty()) {
                        linkedList.removeFirst();
                        System.out.println("List: " + linkedList);
                    } else {
                        System.out.println("The list is empty.");
                    }
                    break;
                case 5:
                    if (!linkedList.isEmpty()) {
                        linkedList.removeLast();
                        System.out.println("List: " + linkedList);
                    } else {
                        System.out.println("The list is empty.");
                    }
                    break;
                case 6:
                    System.out.print("Enter element to remove: ");
                    int element4 = scanner.nextInt();
                    if (linkedList.remove(Integer.valueOf(element4))) {
                        System.out.println("Element removed. List: " + linkedList);
                    } else {
                        System.out.println("Element not found in the list.");
                    }
                    break;
                case 7:
                    if (!linkedList.isEmpty()) {
                        System.out.println("First element: " + linkedList.getFirst());
                    } else {
                        System.out.println("The list is empty.");
                    }
                    break;
                case 8:
                    if (!linkedList.isEmpty()) {
                        System.out.println("Last element: " + linkedList.getLast());
                    } else {
                        System.out.println("The list is empty.");
                    }
                    break;
                case 9:
                    System.out.print("Enter position: ");
                    int position2 = scanner.nextInt();
                    if (position2 >= 0 && position2 < linkedList.size()) {
                        System.out.println("Element at position " + position2 + ": " + linkedList.get(position2));
                    } else {
                        System.out.println("Invalid position.");
                    }
                    break;
                case 10:
                    System.out.print("Enter position: ");
                    int position3 = scanner.nextInt();
                    scanner.nextLine();  // Consume the newline
                    if (position3 >= 0 && position3 < linkedList.size()) {
                        System.out.print("Enter new element: ");
                        int newElement = scanner.nextInt();
                        linkedList.set(position3, newElement);
                        System.out.println("List: " + linkedList);
                    } else {
                        System.out.println("Invalid position.");
                    }
                    break;
                case 11:
                    System.out.println("Forward traversal:");
                    ListIterator<Integer> iterator = linkedList.listIterator();
                    while (iterator.hasNext()) {
                        System.out.println(iterator.next());
                    }
                    break;
                case 12:
                    System.out.print("Enter element to search: ");
                    int element5 = scanner.nextInt();
                    boolean contains = linkedList.contains(element5);
                    System.out.println("Contains " + element5 + "? " + contains);
                    break;
                case 13:
                    System.out.println("Size of the list: " + linkedList.size());
                    break;
                case 14:
                    boolean isEmpty = linkedList.isEmpty();
                    System.out.println("Is the list empty? " + isEmpty);
                    break;
                case 15:
                    linkedList.clear();
                    System.out.println("List cleared. Current list: " + linkedList);
                    break;
                case 16:
                    Object[] array = linkedList.toArray();
                    System.out.println("List converted to array: " + java.util.Arrays.toString(array));
                    break;
                case 17:
                    Collections.sort(linkedList);
                    System.out.println("Sorted list: " + linkedList);
                    break;
                case 18:
                    running = false;
                    System.out.println("Exiting...");
                    break;
                default:
                    System.out.println("Invalid choice. Please try again.");
            }
        }

        scanner.close();
    }
}

//------------------------------------------------------------------------------------------------------

// Attending Thread safety using Collections.synchronizedList() 


	Collections.synchronizedList() in Java is used to create a synchronized wrapper around an 
	existing list, making it thread-safe for modifications.

package collectionexamples;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class SynchronizedListExample  {

    public static void main(String[] args) throws InterruptedException {
        // Create an ArrayList
        List<Integer> numbers = new LinkedList<>();

        // Wrap it in a synchronized list
        List<Integer> synchronizedNumbers = Collections.synchronizedList(numbers);

        // Thread 1 keeps adding numbers
        Thread thread1 = new Thread(() -> {
            for (int i = 1; i <= 100; i++) {
                synchronizedNumbers.add(i);
                try {
                    Thread.sleep(200); // Simulate some work
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });

        // Thread 2 keeps printing the list size
        Thread thread2 = new Thread(() -> {
            while (true) {
                System.out.println("List Size: " + synchronizedNumbers.size());
                try {
                    Thread.sleep(100); // Simulate some work
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });

        // Start both threads
        thread1.start();
        thread2.start();

        // Wait for threads to finish (unlikely due to the infinite loop in thread2)
        thread1.join();
        thread2.join();
    }
}

//-----------------------------------------------------

	// Attaending immutability in Collections

	An object is considered immutable if its state cannot change after it is constructed. In Java, you can create immutable 
	lists using various approaches. Immutable lists are lists whose elements cannot be changed, added, or removed after the 
	list is created. 

	1. Using Collections.unmodifiableList():

	This method takes an existing mutable list and returns a wrapper that prevents modifications to the list structure 
	(adding, removing, or replacing elements). However, the elements themselves can still be mutable if they are 
	mutable objects.

package collectionexamples;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;

public class UnmodifiableListDemo {

    public static void main(String[] args) {
        // Create a LinkedList
        LinkedList<String> fruits = new LinkedList<>();
        fruits.add("Apple");
        fruits.add("Banana");
        fruits.add("Orange");

        System.out.println("Original List (LinkedList): ");
        printList(fruits);

        // Create an unmodifiable view using Collections.unmodifiableList()
        List<String> unmodifiableList = Collections.unmodifiableList(fruits);

        System.out.println("\nUnmodifiable List: ");
        printList(unmodifiableList);

        // Trying to modify the unmodifiable list throws an exception
        try {
            unmodifiableList.add("Mango");
            System.out.println("Successfully added Mango (should not happen!)");
        } catch (UnsupportedOperationException e) {
            System.out.println("Adding element to unmodifiable list: " + e);
        }

        // Modifications to the original list are still reflected
        fruits.addFirst("Grape");
        System.out.println("\nAfter modifying original list (LinkedList): ");
        printList(fruits);

        System.out.println("\nUnmodifiable List (after modification): ");
        printList(unmodifiableList);
    }

    private static void printList(List<String> list) {
        for (String fruit : list) {
            System.out.print(fruit + " ");
        }
        System.out.println();
    }
}

//---------

	2. Using Java 9+ List.of() Factory Method:

	Java 9 introduced a factory method List.of() that can be used to create immutable lists. 
	This method is convenient for creating small, fixed-size lists.
		e.g.
			List<String> colors = List.of("Red", "Green", "Blue");

package collectionexamples;
import java.util.LinkedList;
import java.util.List;

public class ListOfDemo {

    public static void main(String[] args) {
        // LinkedList cannot be used directly with List.of()
        // System.out.println(List.of(new LinkedList<>())); // Compilation error

        // Option 1: Convert LinkedList to an array and use List.of()
        LinkedList<String> fruits = new LinkedList<>();
        fruits.add("Apple");
        fruits.add("Banana");
        fruits.add("Orange");

        String[] fruitsArray = fruits.toArray(new String[fruits.size()]);
        List<String> immutableList = List.of(fruitsArray);

        System.out.println("Original List (LinkedList): ");
        printList(fruits);

        System.out.println("\nImmutable List (using List.of() with array): ");
        printList(immutableList);

        // Trying to modify the immutable list throws an exception
        try {
            immutableList.add("Mango");
            System.out.println("Successfully added Mango (should not happen!)");
        } catch (UnsupportedOperationException e) {
            System.out.println("Adding element to unmodifiable list: " + e);
        }

        // Modifications to the original list (LinkedList) are not reflected
        fruits.addFirst("Grape");
        System.out.println("\nAfter modifying original list (LinkedList): ");
        printList(fruits);

        System.out.println("\nImmutable List (after modification - not reflected): ");
        printList(immutableList);
    }

    private static void printList(List<String> list) {
        for (String fruit : list) {
            System.out.print(fruit + " ");
        }
        System.out.println();
    }
}

//----------------------------------------------------------------------------------------------------------------------------------

	Using java.util.Vector: 
	Vector is a resizable array implementation of the List interface, synchronized for thread safety. 
	It is part of java.util and provides dynamic storage like ArrayList, but with synchronization.

	Constructors of Vector:
	- Vector()	Creates an empty vector with an initial capacity of 10.
	- Vector(int initialCapacity)	Creates a vector with the specified initial capacity.
	- Vector(int initialCapacity, int capacityIncrement)	Creates a vector with specified initial capacity and increment value when resizing.
	- Vector(Collection<? extends E> c)	Creates a vector containing elements from the given collection.

	Methods in Vector:

	- boolean add(E e)	Appends the element to the end of the vector.
	- void add(int index, E element)	Inserts the element at the specified index.
	- boolean addAll(Collection<? extends E> c)	Appends all elements from the given collection.
	- boolean addAll(int index, Collection<? extends E> c)	Inserts all elements from a collection at the specified index.
	- void addElement(E obj)	Adds an element to the vector (legacy method).

	- E get(int index)	Returns the element at the specified index.
	- E firstElement()	Returns the first element in the vector.
	- E lastElement()	Returns the last element in the vector.
	- boolean contains(Object o)	Checks if the vector contains the specified element.
	- int indexOf(Object o)	Returns the index of the first occurrence of the element.
	- int indexOf(Object o, int index)	Returns index of the element starting from a given index.
	- int lastIndexOf(Object o)	Returns the index of the last occurrence of the element.
	- int lastIndexOf(Object o, int index)	Returns the last index before a given position.


	- E remove(int index)	Removes the element at the specified index.
	- boolean remove(Object o)	Removes the first occurrence of the specified object.
	- void removeElementAt(int index)	Removes the element at the specified index (legacy method).
	- void removeElement(Object obj)	Removes the first occurrence of the specified element (legacy method).
	- void removeAllElements()	Removes all elements from the vector.
	- boolean removeAll(Collection<?> c)	Removes all elements from the collection.

	- E set(int index, E element)	Replaces the element at the specified index.
	- void setElementAt(E obj, int index)	Sets the element at the specified index (legacy method).
	- void insertElementAt(E obj, int index)	Inserts an element at the specified index (legacy method).


	- int size()	Returns the number of elements in the vector.
	- boolean isEmpty()	Checks if the vector is empty.
	- void ensureCapacity(int minCapacity)	Ensures minimum capacity.
	- int capacity()	Returns the current capacity of the vector.
	- void trimToSize()	Reduces capacity to match the size of the vector.
	- void setSize(int newSize)	Sets the vector size, truncating or padding with null.


	- Iterator<E> iterator()	Returns an iterator over elements in order.
	- ListIterator<E> listIterator()	Returns a list iterator for bidirectional traversal.
	- ListIterator<E> listIterator(int index)	Returns a list iterator starting from a given index.
	- Enumeration<E> elements()	Returns an enumeration of the vector elements.
	- void forEach(Consumer<? super E> action)	Performs an action for each element.

	- static <T> List<T> synchronizedList(List<T> list)	Returns a synchronized list for thread safety.

	- Object[] toArray()	Converts the vector into an object array.
	- <T> T[] toArray(T[] a)	Converts the vector into a typed array.
	- boolean containsAll(Collection<?> c)	Checks if the vector contains all elements of a collection.
	- boolean retainAll(Collection<?> c)	Retains only elements in the given collection.
	- void clear()	Removes all elements from the vector.
	- Vector<E> clone()	Creates a shallow copy of the vector.
	- Spliterator<E> spliterator()	Returns a spliterator for parallel processing.
	- int hashCode()	Returns the hash code of the vector.
	- boolean equals(Object obj)	Compares this vector with another object


	Difference Between size() and capacity() in Vector
	- size(): Returns the number of elements currently present in the Vector.
	- capacity(): Returns the total allocated storage space in the Vector, 
	  which may be larger than size().

import java.util.Vector;

public class VectorSizeCapacityExample {
    public static void main(String[] args) {
        // Creating a Vector with an initial capacity of 5
        Vector<String> fruits = new Vector<>(5);

        // Displaying initial size and capacity
        System.out.println("Initial Size: " + fruits.size());  // 0
        System.out.println("Initial Capacity: " + fruits.capacity()); // 5

        // Adding elements
        fruits.add("Apple");
        fruits.add("Banana");
        fruits.add("Orange");

        // Displaying size and capacity after adding elements
        System.out.println("\nAfter Adding 3 Elements:");
        System.out.println("Size: " + fruits.size());  // 3
        System.out.println("Capacity: " + fruits.capacity()); // Still 5

        // Adding more elements beyond initial capacity
        fruits.add("Mango");
        fruits.add("Grapes");
        fruits.add("Pineapple");  // This triggers capacity expansion

        // Displaying size and capacity after exceeding initial capacity
        System.out.println("\nAfter Adding 6 Elements:");
        System.out.println("Size: " + fruits.size());  // 6
        System.out.println("Capacity: " + fruits.capacity()); // Increased (default doubles to 10)
    }
}

//-----------------------------------------------------------------------------------------------------

	// Different Ways to Iterate Over a Vector in Java


import java.util.Vector;

public class ForLoopExample {
    public static void main(String[] args) {
        Vector<String> fruits = new Vector<>();
        fruits.add("Apple");
        fruits.add("Banana");
        fruits.add("Orange");

	// ndex-based Iteration
        System.out.println("Using for loop:");
        for (int i = 0; i < fruits.size(); i++) {
            System.out.println(fruits.get(i));
        }

	System.out.println("Using for-each loop:");
        for (String fruit : fruits) {
            System.out.println(fruit);
        }

 	System.out.println("Using Iterator:");
        Iterator<String> iterator = fruits.iterator();
        while (iterator.hasNext()) {
            System.out.println(iterator.next());
        }

	 System.out.println("Using ListIterator (Forward Direction):");
        ListIterator<String> listIterator = fruits.listIterator();
        while (listIterator.hasNext()) {
            System.out.println(listIterator.next());
        }

        System.out.println("\nUsing ListIterator (Backward Direction):");
        while (listIterator.hasPrevious()) {
            System.out.println(listIterator.previous());
        }

	System.out.println("Using Enumeration:");
        Enumeration<String> enumeration = fruits.elements();
        while (enumeration.hasMoreElements()) {
            System.out.println(enumeration.nextElement());
        }

	System.out.println("Using forEach() with Lambda:");
        fruits.forEach(fruit -> System.out.println(fruit));

	System.out.println("Using Method Reference:");
        fruits.forEach(System.out::println);

    }
}

//---------------------------------------------------------------------------

	// java.util.Stack Overview
	Stack is a subclass of Vector that implements a Last-In, First-Out (LIFO) data structure.

	Constructors of Stack
		Stack() – Creates an empty stack with an initial capacity of 10 (inherited from Vector).

	Methods of Stack
	1. Stack-Specific Methods
		E push(E item) – Pushes an element onto the top of the stack.
		E pop() – Removes and returns the top element of the stack.
		E peek() – Returns the top element without removing it.
		boolean empty() – Checks if the stack is empty.
		int search(Object o) – Returns the 1-based position of an element from the top of the stack, or -1 if not found.
	2. Inherited from Vector
		boolean add(E e) – Adds an element at the end.
		void add(int index, E element) – Inserts an element at a specific position.
		boolean addAll(Collection<? extends E> c) – Appends all elements from a collection.
		boolean remove(Object o) – Removes the first occurrence of an element.
		E remove(int index) – Removes the element at a specific index.
		void clear() – Removes all elements from the stack.
		E get(int index) – Retrieves the element at a specific index.
		E set(int index, E element) – Updates the element at a given index.
		int size() – Returns the number of elements in the stack.
		boolean contains(Object o) – Checks if the stack contains a specific element.
		int indexOf(Object o) – Returns the index of the first occurrence of an element.
		int lastIndexOf(Object o) – Returns the last occurrence index of an element.
		Object[] toArray() – Converts the stack to an array.
		Iterator<E> iterator() – Returns an iterator for iterating over the stack.
		ListIterator<E> listIterator() – Returns a list iterator for bidirectional iteration.

	Key Points
	- Stack is synchronized as it extends Vector, making it thread-safe but slower than Deque (ArrayDeque).
	- Preferred alternative: Deque (ArrayDeque) is recommended for better performance in stack operations.













